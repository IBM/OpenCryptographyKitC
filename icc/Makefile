#******************************************************************************
#******************************************************************************

#- Default targets, before the makefile stubs below (some of which
# have their own targets) so it *IS* the default

default: help

# Makefile needs to define this as relative path from Makefile's dir to the base of ICC source dir
ICC_ROOT=..

# This is the version tag inserted into the ICC shared library names
# This exists to allow us to have both a certified and non-certified ICC in
# the same process space. Namespacing takes care of MOST of the issues,
# but some OS configs will not load two libs of the same name on different paths
# so the libraries have their own name and SONAME as well
# 
include ./VTAG.mk

#--- Adjust this to your current operating system, or override it from the
#       command line when invoking make.
######################################################
# DO NOT CHANGE THIS or production builds will break #
######################################################
OPSYS  = AMD64_LINUX
# CONFIG=<debug|release|asan> MUST be lowercase

CONFIG = debug
# [devloper] or OFFICIAL build
BUILD  = developer
#developer_CFLAGS = -DVTAG=$(VTAG) -DBURST_READ # Allows testing of ARM code paths on x86
developer_CFLAGS = -DVTAG=$(VTAG)
OFFICIAL_CFLAGS = -DICC_OFFICIAL_BUILD -DVTAG=$(VTAG)
#
# Windows only, the signing script
#
ifeq ($(findstring VS2022, $(OPSYS)), VS2022)
SIGN_COMMAND = ../../signwindowsfile.ksh
else
SIGN_COMMAND    = /build/build/scripts/signwindowsfile.ksh
endif


#-- Directories

# Note: match same definitions in other Makefiles
PACKAGE_DIR    = $(ICC_ROOT)/package
RTE_DIR        = $(PACKAGE_DIR)/icc
SDK_DIR        = $(PACKAGE_DIR)/iccsdk

NOSHIP_DIR 	   = $(PACKAGE_DIR)/NOSHIP
NOSHIP_RTE_DIR = $(NOSHIP_DIR)/icc
PRNG_DIR       = fips-prng
TRNG_DIR       = TRNG
OSSL_RTE_DIR   = $(RTE_DIR)/osslib
ICC_RTE_DIR    = $(RTE_DIR)/icclib
NOSHIP_ICC_RTE_DIR = $(NOSHIP_RTE_DIR)/icclib

#- Default targets, before the makefile stubs below (some of which
# have their own targets) so it *IS* the default
#- Do everything EXCEPT create sources (default target)

default: all

# Stub that lets us know standalone ICC and FIPS ICC
# written by create_all (java pre-build)
# we may override MUPPET in platforms.mk
include $(ICC_ROOT)/iccpkg/muppet.mk


# Define what OpenSSL version we are using.
include ./opensslver.mk
include ./platforms.mk
include ./icc_defs.mk


# Include the components for building the zlib files we use in ICC
include ./zlib.mk

# Support tools
include ./tools.mk

#--- What we need to build
# Moved to icc_defs.mk , platform specific
#ICCDLL_NAME = $(SHLPRFX)icclib$(VTAG)$(SHLSUFX)
ICCDLL   = $(ICC_RTE_DIR)/$(ICCDLL_NAME)
ICCLIB   = $(STLPRFX)icc$(STLSUFX)
ICCLIB_SDK = $(SDK_DIR)/$(STLPRFX)icc$(STLSUFX)
OSSLLIB  = $(OSSLOBJ_DIR)/$(OSSLLIB_NAME)$(STLSUFX)
ICCTEST  = icctest$(EXESUFX)
PRNGTST1 = fips-prng-testprg$(EXESUFX)
PRNGTST2 = fips-prng-testprg2$(EXESUFX)
ICCSDK   = $(PACKAGE_DIR)/iccsdk.tar
ICCRTE   = $(PACKAGE_DIR)/iccrte.tar


MYOPENSSL  = $(SDK_DIR)/openssl$(EXESUFX)
REALOPENSSL  = $(ICC_ROOT)/$(OPENSSL_VER)/apps/openssl$(EXESUFX)
DOXYFILE   = $(SDK_DIR)/ICC_API_htm.tar
ICCREAD    = iccread$(EXESUFX)
ICC400     = icc400$(EXESUFX)
ICCPKG_DIR = $(ICC_ROOT)/iccpkg
ICCPKG_TEST = $(ICCPKG_DIR)/$(ICCTEST)

# Autogenerated code. (Also export files)
AUTOGEN = icc_a.c icc_a.h icclib_a.c icclib_a.h \
	$(ICC_ROOT)/iccpkg/iccpkg_a.c $(ICC_ROOT)/iccpkg/iccpkg_a.h $(ICC_ROOT)/iccpkg/gsk_wrap.c \
	$(ICC_ROOT)/iccpkg/gsk_wrap2_a.c $(ICC_ROOT)/iccpkg/icc_aux_a.c $(ICC_ROOT)/iccpkg/icc_aux_a.h $(ICC_ROOT)/iccpkg/jcc_a.h

# define OpenSSL related variables
include ./ossl.mk

# Include platform specific make functions. These can use "native"
# make features if necessary.

include platforms/$(OPENSSL_LIBVER)/$(OPSYS)_.mk
# Builds a special package for GSKit.
# iccpkg: comes from ICCPKG.mk
include ./ICCPKG.mk

# Delta timing code. High res counters
include ./delta.mk

# Pick up default install path for fallback code
include $(ICC_ROOT)/iccpkg/gsk_crypto.mk

# Handle Argon2 MAKE
# Note: iccpkg/Argon2/Argon2.mk gets copied with edits to icc to resolve file namespacing problem on Z
-include $(ICC_ROOT)/icc/Argon2/Argon2.mk

#Argon Create target
CREATE_ARGON = create_libArgon

# Note tools.mk also uses ARGON

# default add argon to module
$(OPSYS)_ARGON = $(argon2_obj)
ARGON = $($(OPSYS)_ARGON)

help:
	echo make targets:
	echo    create_all - clean_all - scrubbed, create_all_no_legacy, create_all_FIPS
	echo         e.g: make -C icc OPSYS=WIN64_VS2022 CONFIG=debug create_all
	echo         PQC=NONE, PQC=LIBOQS, PQC= (default LIBDKS)
	echo    set_icc_version
	echo         e.g: 'make ... ICC_VERSION_VER=x ICC_VERSION_REL=y ICC_VERSION_MOD=z set_icc_version' to get "x.y.z" as version number
	echo    build_all
	echo    create_pqc, build_pqc, clean_pqc
	echo    backup_libdks
	echo         tars up libdks which can be checked in to avoid git clones
	echo    show_config, show_version_info

# Fix a problem only on z/OS, the two stub loaders created from icc.c need to have 
# different object names on this platform
# Since the FIPS ICC was already built, change ONLY the name of the object used in non-FIPS mode
# This gets linked into step library for ICCN_ symbols

ifeq ($(strip $(IS_FIPS)),)
   MYICC = newicc
else
   MYICC = icc
endif		

API_DIR = platforms/$(OPENSSL_LIBVER)/API

# What we build.

TARGETS = $(MYOPENSSL) tmp/dummyfile  \
	signer$(EXESUFX) \
	$(DELTA) \
	$(STLPRFX)zlib$(STLSUFX)  \
	$(ICCDLL) $(ICCLIB_SDK)  \
	$(ICCTEST) \
	$(ICCRTE) \
	$(TOOLS) \
	$(ICCSDK) \
	$(ICCPKG_TEST)


# These headers will link an application to the ICC module library - icc_a.h has the ICCX_ prefix
SDK_TARGETS: $(SDK_DIR)/icc.h $(SDK_DIR)/icc_a.h $(SDK_DIR)/iccglobals.h
	ls $(SDK_DIR)

# These headers will link an application to the ICC step library - icc_a.h (iccpkg_a.h) has the ICC_ prefix - ref gsk_crypto.mk 
ICCPKG_SDK_HEADERS: $(GSK_SDK)/icc.h $(GSK_SDK)/icc_a.h $(GSK_SDK)/iccglobals.h
	ls $(GSK_SDK)

#	$(CAVSON)

#-------------------------------------------------------------------------------
#- Targets
#-------------------------------------------------------------------------------

# log our build machine name and working directory
ctx: show_version_info
	-uname -a; pwd

all: ctx create_dirs build_all package_all
	@echo $@ made

#- Create the ICC source code
#- This is typically run once on one machine then tar'd up and distributed
#- to the real build machines.
create_all:  create_openssl create_zlib create_icc_no_legacy $(CREATE_ARGON) $(PQC_CREATE)
create_all_FIPS:  create_icc_FIPS create_all

#- Create the OpenSSL sources from tarfile and patches
#- This has NO automated dependencies as that messes the automated builds
#- this MUST be tripped manually.
#-
create_openssl: $(ICC_ROOT)/openssl_source/$(OPENSSL_VER)-icc.tar.gz
# Untar the sources for the version of OpenSSL we use
# sometimes get permission denied on the mv after the tar - delay
# since 1.1.1u the OpenSSL tar has icc patches applied
# the first dir name in the archive will vary so we make an empty directory to extract
# old mv:
#	   mv `ls -d *`/openssl $(ICC_ROOT)/$(OPENSSL_VER) ;
	if [ -e $(ICC_ROOT)/$(OPENSSL_VER) ] ; then rm -r $(ICC_ROOT)/$(OPENSSL_VER) ; fi
	if [ -e $(ICC_ROOT)/openssl ] ; then rm -r $(ICC_ROOT)/openssl ; fi
	[ -n "$(EX_SUFFIX)" ] || \
	( \
	   cd .. ; \
	   rm -rf x; mkdir x; cd x; \
	   tar xzf ../openssl_source/$(OPENSSL_VER)-icc.tar.gz ; \
	   sleep 1; \
	   mv openssl ../$(OPENSSL_VER) ; \
	   chmod +x ../$(OPENSSL_VER)/Configure ; \
	   cd ..; \
	   rm -rf x; \
	)
# test if the extract worked
	cd $(ICC_ROOT)/$(OPENSSL_VER)
	-rm Build_OSSL_Complete

#- Create the OpenSSL sources from tarfile and patches on zOS
#- This has NO automated dependencies as that messes the automated builds
#- this MUST be tripped manually.
#-
create_openssl_zos: $(ICC_ROOT)/openssl_source/$(OPENSSL_VER).tar.gz
# Untar the sources for the version of OpenSSL we use
# Skip this step if using extracted openssl files in Clearcase
	[ -n "$(EX_SUFFIX)" ] || \
	( \
	   cd .. ;\
	   gzip -d -c openssl_source/$(OPENSSL_VER).tar.gz | pax -ofrom=ISO8859-1,to=IBM-1047 -rv  ; \
	)

### Argon2

clean_argon:
	-rm $(ICC_ROOT)/icc/Argon2/*.o $(ICC_ROOT)/icc/Argon2/*.obj

clean_libArgon:
	-rm -rf $(ICC_ROOT)/libArgon
	-rm -rf $(ICC_ROOT)/icc/Argon2

create_libArgon: $(ICC_ROOT)/libArgon $(ICC_ROOT)/libArgon/phc-winner-argon2
	
$(ICC_ROOT)/libArgon:
	$(MKDIR) $@
$(ICC_ROOT)/icc/Argon2:
	$(MKDIR) $@

# get a local copy of mystdint.h from DilKyb dir
$(ICC_ROOT)/icc/Argon2/mystdint.h: $(ICC_ROOT)/icc/Argon2 $(ICC_ROOT)/iccpkg/mystdint.h
	$(CP) $(ICC_ROOT)/iccpkg/mystdint.h $@

$(ICC_ROOT)/libArgon/phc-winner-argon2: $(ICC_ROOT)/icc/Argon2 $(ICC_ROOT)/icc/Argon2/mystdint.h
	-rm -rf $(ICC_ROOT)/libArgon/*
	if [ -e $(ICC_ROOT)/libArgon.tar.gz ] ; then \
		 ( cd ..; tar xzf libArgon.tar.gz -C libArgon/ ) ; \
	else \
	    git clone https://github.com/P-H-C/phc-winner-argon2.git --depth 1 -b standard $(ICC_ROOT)/libArgon/Argon2; \
        echo Argon2 > $(ICC_ROOT)/libArgon/log.txt ; \
		git -C $(ICC_ROOT)/libArgon/Argon2 log >> $(ICC_ROOT)/libArgon/log.txt ; \
		cat $(ICC_ROOT)/libdks/log.txt ; \
	fi
	$(CP) -r $(ICC_ROOT)/libArgon/phc-winner-argon2/src/* $(ICC_ROOT)/icc/Argon2/
	$(CP) $(ICC_ROOT)/libArgon/phc-winner-argon2/include/* $(ICC_ROOT)/icc/Argon2/
# sed -i wont work on some platforms but this runs on linux pre-build as part of create
	cd $(ICC_ROOT)/icc/Argon2 ; sed -i "s/^#include <stdint.h>/#include <mystdint.h>/" argon2.h \
	       	blake2/blake2-impl.h blake2/blake2b.c opt.c ref.c test.c bench.c run.c
# make sure the sed worked
	grep mystdint.h $(ICC_ROOT)/icc/Argon2/argon2.h
# resolve Z's 'file name clash with openssl's blake2b - some sharing with iccpkg/Argon2 so fix that copy too
# Note: We include Argon2.mk so this needs to be done in the pre-build/create so it is ready for the build which includes Argon2.mk
	$(CP) $(ICC_ROOT)/icc/Argon2/blake2/blake2b.c $(ICC_ROOT)/icc/Argon2/blake2/blake2b_icc.c
	sed "s/blake2b/blake2b_icc/g" $(ICC_ROOT)/iccpkg/Argon2/Argon2.mk >  $(ICC_ROOT)/icc/Argon2/Argon2.mk
# make sure the sed worked
	grep blake2b_icc.c $(ICC_ROOT)/icc/Argon2/Argon2.mk
	
# command to make the argon archive to checkin
tar_libArgon:
	cd libArgon ; tar czf $(ICC_ROOT)/libArgon.tar.gz phc-winner-argon2

#Build_Argon: create_libArgon $(ICC_ROOT)/libArgon/phc-winner-argon2/Makefile
#	$(MAKE) -C $(ICC_ROOT)/libArgon/phc-winner-argon2/ $(DKS_MAKE_FLAGS) libs


### Dilithium Kyber Sphincs
 
clean_dks:
	-rm -rf $(ICC_ROOT)/libdks

create_dks: $(ICC_ROOT)/libdks $(ICC_ROOT)/libdks/kyber $(ICC_ROOT)/libdks/dilithium $(ICC_ROOT)/libdks/sphincs

# if the tar archive is available then use it otherwise git clone it
# Note: use backup_libdks target to create the tar archive
# our makefile patches that are in libdks_icc will just overwrite originals so back them up too

$(ICC_ROOT)/libdks:
	$(MKDIR) $@

$(ICC_ROOT)/libdks/kyber $(ICC_ROOT)/libdks/dilithium $(ICC_ROOT)/libdks/sphincs:
	-rm -rf $(ICC_ROOT)/libdks/*
	if [ -e $(ICC_ROOT)/libdks$(LIBDKS_VER).tar.gz ] ; then \
		 ( cd ..; tar xzf libdks$(LIBDKS_VER).tar.gz ) ; \
	else \
		git clone https://github.com/pq-crystals/kyber.git --depth 1 -b standard $(ICC_ROOT)/libdks/kyber ; \
		git clone https://github.com/pq-crystals/dilithium.git --depth 1 $(ICC_ROOT)/libdks/dilithium ; \
		git clone https://github.com/sphincs/sphincsplus.git --depth 1 $(ICC_ROOT)/libdks/sphincs ; \
		echo kyber > $(ICC_ROOT)/libdks/log.txt ; \
		git -C $(ICC_ROOT)/libdks/kyber log >> $(ICC_ROOT)/libdks/log.txt ; \
		echo dilithium >> $(ICC_ROOT)/libdks/log.txt ; \
		git -C $(ICC_ROOT)/libdks/dilithium log >> $(ICC_ROOT)/libdks/log.txt ; \
		echo sphincs >> $(ICC_ROOT)/libdks/log.txt ; \
		git -C $(ICC_ROOT)/libdks/sphincs log >> $(ICC_ROOT)/libdks/log.txt ; \
		cat $(ICC_ROOT)/libdks/log.txt ; \
	fi
	$(CP) $(ICC_ROOT)/libdks/kyber/ref/Makefile $(ICC_ROOT)/libdks_icc/kyber/ref/Makefile.orig
	( cd $(ICC_ROOT)/libdks/kyber/ref ; for i in $$(ls *.c) ; do for j in 512 768 1024 ; do cp $$i $$j-$$i ; done ; done )
	$(CP) $(ICC_ROOT)/libdks/dilithium/ref/Makefile $(ICC_ROOT)/libdks_icc/dilithium/ref/Makefile.orig
	( cd $(ICC_ROOT)/libdks/dilithium/ref ; for i in $$(ls *.c) ; do for j in 2 3 5 ; do cp $$i $$j-$$i ; done ; done )
	$(CP) $(ICC_ROOT)/libdks/sphincs/ref/Makefile $(ICC_ROOT)/libdks_icc/sphincs/ref/Makefile.orig
# copy in our patched files
	$(CP) -r $(ICC_ROOT)/libdks_icc/* $(ICC_ROOT)/libdks/
# edit in remaining changes
	sed -i "s/SPX_##s/SPX_SHAKE_128s_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-shake-128s.h
	sed -i "s/SPX_##s/SPX_SHAKE_128f_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-shake-128f.h
	sed -i "s/SPX_##s/SPX_SHA2_128s_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-sha2-128s.h
	sed -i "s/SPX_##s/SPX_SHA2_128f_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-sha2-128f.h
	sed -i "s/SPX_##s/SPX_SHAKE_192s_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-shake-192s.h
	sed -i "s/SPX_##s/SPX_SHAKE_192f_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-shake-192f.h
	sed -i "s/SPX_##s/SPX_SHA2_192s_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-sha2-192s.h
	sed -i "s/SPX_##s/SPX_SHA2_192f_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-sha2-192f.h
	sed -i "s/SPX_##s/SPX_SHAKE_256s_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-shake-256s.h
	sed -i "s/SPX_##s/SPX_SHAKE_256f_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-shake-256f.h
	sed -i "s/SPX_##s/SPX_SHA2_256s_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-sha2-256s.h
	sed -i "s/SPX_##s/SPX_SHA2_256f_##s/" $(ICC_ROOT)/libdks/sphincs/ref/params/params-sphincs-sha2-256f.h
# There is a symbol clash that can be resolved by moving some functions from one file to another
	( cd $(ICC_ROOT)/libdks/sphincs/ref; \
		linenum=$$(grep -n "void mgf1_256(unsigned char \*out, unsigned long outlen," sha2.c | head -n 1 | cut -d: -f1); \
		head -n $$((linenum-7)) sha2.c > file_temp.txt; \
		tail -n +$$((linenum-7)) sha2.c >> hash_sha2.c; \
		mv file_temp.txt sha2.c; \
		for i in $$(ls *.c) ; do for j in 128 192 256 ; do for k in shake sha2 ; do for m in s f ; do cp $$i $$k-$$j$$m-$$i ; done ; done ; done ; done ; \
	)

# nistkat needs to link to openssl so only build it for 64 bit linux
AMD64_LINUX_PQCKAT=nistkat tests
# the nistkat test is crashing in 32 bit linux. Some linking problem
LINUX_PQCKAT=nistkat
WIN64_VS2022_PQCKAT=nistkat tests
AIX64_PQCKAT=nistkat tests
PQCKAT=$($(OPSYS)_PQCKAT)

# the build (make) should always run
build_dks: create_dks $(ICC_ROOT)/libdks/defs.mk $(ICC_ROOT)/libdks/kyber/ref/Makefile $(ICC_ROOT)/libdks/dilithium/ref/Makefile \
		$(ICC_ROOT)/libdks/sphincs/ref/Makefile $(ICC_ROOT)/libdks/sphincs/ref/api.h
	$(MAKE) -C $(ICC_ROOT)/libdks/kyber/ref $(DKS_MAKE_FLAGS) static $(PQCKAT)
	$(MAKE) -C $(ICC_ROOT)/libdks/dilithium/ref $(DKS_MAKE_FLAGS) static $(PQCKAT)
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=shake-128s static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=shake-128f static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=shake-192s static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=shake-192f static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=shake-256s static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=shake-256f static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=sha2-128s static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=sha2-128f static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=sha2-192s static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=sha2-192f static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=sha2-256s static
	$(MAKE) -C $(ICC_ROOT)/libdks/sphincs/ref $(DKS_MAKE_FLAGS) VARIANT=sha2-256f static

# update from our Makefile patches
$(ICC_ROOT)/libdks/defs.mk: $(ICC_ROOT)/libdks_icc/defs.mk
	$(CP) $< $@
$(ICC_ROOT)/libdks/kyber/ref/Makefile: $(ICC_ROOT)/libdks_icc/kyber/ref/Makefile
	$(CP) $< $@
$(ICC_ROOT)/libdks/dilithium/ref/Makefile: $(ICC_ROOT)/libdks_icc/dilithium/ref/Makefile
	$(CP) $< $@
$(ICC_ROOT)/libdks/sphincs/ref/Makefile: $(ICC_ROOT)/libdks_icc/sphincs/ref/Makefile
	$(CP) $< $@
$(ICC_ROOT)/libdks/sphincs/ref/api.h: $(ICC_ROOT)/libdks_icc/sphincs/ref/api.h
	$(CP) $< $@

backup_original_makefiles:

# remember to backup any DKS makefile changes with backup_dks_makefiles target and checkin changes
# not needed if you already modified in libdks_icc
backup_dks_makefiles:
	$(CP) $(ICC_ROOT)/libdks/defs.mk $(ICC_ROOT)/libdks_icc/defs.mk
	$(CP) $(ICC_ROOT)/libdks/kyber/ref/Makefile $(ICC_ROOT)/libdks_icc/kyber/ref/Makefile
	$(CP) $(ICC_ROOT)/libdks/dilithium/ref/Makefile $(ICC_ROOT)/libdks_icc/dilithium/ref/Makefile
	$(CP) $(ICC_ROOT)/libdks/sphincs/ref/Makefile $(ICC_ROOT)/libdks_icc/sphincs/ref/Makefile
	$(CP) $(ICC_ROOT)/libdks/sphincs/ref/Makefile $(ICC_ROOT)/libdks_icc/sphincs/ref/api.h

# make the libdks backup that we can check in to repo to avoid git clone calls in build
# remove all the stuff we dont need since this may be checked into repo
# keep git files
#	find $(ICC_ROOT)/libdks -name ".git" -exec rm -rf {} +
$(ICC_ROOT)/libdks$(LIBDKS_VER).tar.gz: create_dks Makefile
	find $(ICC_ROOT)/libdks -name ".github" -exec rm -rf {} +
	find $(ICC_ROOT)/libdks -name "avx2" -exec rm -rf {} +
	find $(ICC_ROOT)/libdks -name ".gitignore" -exec rm {} +
	find $(ICC_ROOT)/libdks -name ".gitattributes" -exec rm {} +
	find $(ICC_ROOT)/libdks -name ".travis" -exec rm {} +
	find $(ICC_ROOT)/libdks -name "*.yml" -exec rm {} +
	tar czf $(ICC_ROOT)/libdks$(LIBDKS_VER).tar.gz $(ICC_ROOT)/libdks

rm_libdks_backup:
	$(RM) $(ICC_ROOT)/libdks$(LIBDKS_VER).tar.gz

backup_libdks: rm_libdks_backup $(ICC_ROOT)/libdks$(LIBDKS_VER).tar.gz Makefile

### liboqs

clean_oqs:
	-rm -rf $(ICC_ROOT)/liboqs icc_oqs build_oqs

create_oqs: $(ICC_ROOT)/liboqs/CMakeLists.txt

# if the tar archive is available then use it otherwise git clone it

$(ICC_ROOT)/liboqs/CMakeLists.txt :
	if [ -e $(ICC_ROOT)/liboqs$(LIBOQS_VER).tar.gz ] ; then \
		mkdir $(ICC_ROOT)/liboqs ; cd $(ICC_ROOT)/liboqs ; \
		tar xzf $(ICC_ROOT)/liboqs$(LIBOQS_VER).tar.gz ; \
		mv liboqs$(LIBOQS_VER)/* . ; mv liboqs$(LIBOQS_VER)/.* . ; \
		rmdir liboqs$(LIBOQS_VER) ; \
	else \
		git clone https://github.com/open-quantum-safe/liboqs.git --depth 1 $(ICC_ROOT)/liboqs ; \
		echo liboqs > $(ICC_ROOT)/liboqs/log.txt ; \
		git -C $(ICC_ROOT)/liboqs log >> $(ICC_ROOT)/liboqs/log.txt ; \
	fi

$(ICC_ROOT)/liboqs$(LIBOQS_VER).tar.gz: create_oqs Makefile
	find $(ICC_ROOT)/liboqs -name ".github" -exec rm -rf {} +
	find $(ICC_ROOT)/liboqs -name "avx2" -exec rm -rf {} +
	find $(ICC_ROOT)/liboqs -name ".gitignore" -exec rm {} +
	find $(ICC_ROOT)/liboqs -name ".gitattributes" -exec rm {} +
	find $(ICC_ROOT)/liboqs -name ".travis" -exec rm {} +
	find $(ICC_ROOT)/liboqs -name "*.yml" -exec rm {} +
	tar czf $(ICC_ROOT)/liboqs$(LIBDKS_VER).tar.gz $(ICC_ROOT)/liboqs

rm_liboqs_backup:
	$(RM) $(ICC_ROOT)/liboqs$(LIBOQS_VER).tar.gz

backup_liboqs: rm_liboqs_backup $(ICC_ROOT)/liboqs$(LIBOQS_VER).tar.gz Makefile

$(ICC_ROOT)/liboqs/CMakeCache.txt: $(ICC_ROOT)/liboqs/CMakeLists.txt 
	cd $(ICC_ROOT)/liboqs && $(CMAKE_OQS)

config_oqs: $(ICC_ROOT)/liboqs/CMakeCache.txt

clean_config_oqs:
	$(RM) $(ICC_ROOT)/liboqs/CMakeCache.txt

# the build (make) should always run
build_oqs: $(ICC_ROOT)/liboqs/CMakeCache.txt
	cd $(ICC_ROOT)/liboqs && $(BUILD_OQS)

# our local liboqs integration and test code
#icc_oqs: build_oqs
#	$(MAKE) -C $(ICC_ROOT)/iccpkg/liboqs all

create_pqc: $(PQC_CREATE)
	echo "create: configured for: $(PQC_CREATE)"
build_pqc: $(PQC_TARGET)
	echo "build: configured for: $(PQC_TARGET)"
clean_pqc: clean_oqs clean_dks
	echo "clean: configured for: $(PQC_CREATE)"
	-$(MAKE) -C $(ICC_ROOT)/iccpkg/pqc clean

$(PACKAGE_DIR):
	$(MKDIR) $@

$(SDK_DIR): $(PACKAGE_DIR)
	$(MKDIR) $@

$(RTE_DIR): $(PACKAGE_DIR)
	$(MKDIR) $@

$(ICC_RTE_DIR): $(RTE_DIR)
	$(MKDIR) $@

#- Make directory for OpenSSL shared library
$(OSSL_RTE_DIR): $(RTE_DIR)
	$(MKDIR) $@

$(NOSHIP_DIR): $(PACKAGE_DIR)
	$(MKDIR) $@

$(NOSHIP_RTE_DIR): $(NOSHIP_DIR)
	$(MKDIR) $@

$(NOSHIP_ICC_RTE_DIR): $(NOSHIP_RTE_DIR)
	$(MKDIR) $@

create_dirs: $(NOSHIP_DIR) $(NOSHIP_RTE_DIR) $(NOSHIP_ICC_RTE_DIR) $(SDK_DIR) $(ICC_RTE_DIR) $(OSSL_RTE_DIR) exports $(ICC_ROOT)/iccpkg/exports

# Forces a rebuild in case we have a leftover .o or .exe from create_all from another system
clean_iccVdump:
	-$(RM) iccVdump$(EXESUFX) iccVdump$(OBJSUFX)

iccVdump$(EXESUFX): iccVdump.c buildinfo.h
	$(CC) $(CFLAGS) iccVdump.c
	$(LD) $(LDFLAGS) iccVdump$(OBJSUFX)

# we need to build then delete iccVdump because the build is split with a pre-build on linux then build on the target build machine.
# So a pre-built binary may not run on the target build machine.
# So we dont depend on iccVdump binary but we force the build if we actually need it - then delete it.
ICC_ver.txt: buildinfo.h
	$(MAKE) clean_iccVdump
	$(MAKE) iccVdump$(EXESUFX)
	./iccVdump$(EXESUFX) >ICC_ver.txt
	$(MAKE) clean_iccVdump

exports:
	$(MKDIR) $@

$(ICC_ROOT)/iccpkg/exports:
	$(MKDIR) $@

#- Build and run the code generator if necsssary
#- We typically only do this on one (fast) platform as setup for the
#- builds. Then copy the populated source tree to the other build machines
#- 
ICCencapsulator.class: ICCencapsulator.java
	javac ICCencapsulator.java

# the create_all_* needs to be ran manually
icc_a.h icc_a.c icclib_a.h icclib_a.c:
	echo please make create_all
	false

#
# Create the _a.[ch] files and export files for ICC
# create a .0 file to indicate if we have legacy FIPS icc so we can test for it
# muppet.mk also records the FIPS build state
#
create_icc: ICC_ver.txt create_dirs functions.txt \
		ICCencapsulator.class OLD_ICC/functions.txt ICC_ver.txt
	java ICCencapsulator OLD_ICC/functions.txt
	-$(RM) create*.0
	touch create_icc.0
	echo muppet.mk
	cat $(ICC_ROOT)/iccpkg/muppet.mk

#- Run the code generator for those OS's where there's
#- no "old/FIPS" ICC
#- We assume the pre-req dirs were created already
create_icc_no_legacy: ICC_ver.txt create_dirs functions.txt \
			ICCencapsulator.class ICC_ver.txt
	java ICCencapsulator
	-$(RM) create*.0
	touch create_icc_no_legacy.0
	echo muppet.mk
	cat $(ICC_ROOT)/iccpkg/muppet.mk

# Note that this will edit a controlled file (icc/functions.txt) so don't check it in!
create_icc_FIPS:
	-$(RM) create*.0
	touch create_fips.0
	if [ ! -e functions.txt.bak ] ; then cp functions.txt functions.txt.bak ; fi
	sed -i 's/^# non-FIPS;$$/# FIPS;/' functions.txt
	sed -i 's/^PREFIX=N;$$/PREFIX=C;/' functions.txt
	sed -i 's/VTAG=085$$/VTAG=084/' VTAG.mk
	echo 'FIPS ICC builds have convention of even number release, E.g. 8.8.1, non-FIPS 8.9.1'
	cat icc_curr_version

# needs 'make ... ICC_VERSION_VER=x ICC_VERSION_REL=y ICC_VERSION_MOD=z set_icc_version' to get "x.y.z" as version number
set_icc_version: buildinfo.h
	echo 'ICC_VERSION_VER.ICC_VERSION_REL.ICC_VERSION_MOD=$(ICC_VERSION_VER).$(ICC_VERSION_REL).$(ICC_VERSION_MOD)'
	if [ ! -e iccversion.h.bak ] ; then cp iccversion.h iccversion.h.bak ; fi
	sed -i 's/ICC_VERSION_REL .$$/ICC_VERSION_REL $(ICC_VERSION_REL)/' iccversion.h
	sed -i 's/ICC_VERSION_MOD .$$/ICC_VERSION_MOD $(ICC_VERSION_MOD)/' iccversion.h
	if [ ! -e icc_minor_version.h.bak ] ; then cp icc_minor_version.h icc_minor_version.h.bak ; fi
	sed -i 's/ICC_VERSION_MOD .$$/ICC_VERSION_MOD $(ICC_VERSION_MOD)/' icc_minor_version.h
	if [ ! -e buildinfo.h.bak ] ; then cp buildinfo.h buildinfo.h.bak ; fi
	sed -i 's/ICC_VERSION_MOD .$$/ICC_VERSION_MOD $(ICC_VERSION_MOD)/' buildinfo.h
	sed -i 's/8.9/$(ICC_VERSION_VER).$(ICC_VERSION_REL)/' buildinfo.h
	if [ ! -e icc_curr_version.bak ] ; then cp icc_curr_version icc_curr_version.bak ; fi
	echo '$(ICC_VERSION_VER).$(ICC_VERSION_REL).$(ICC_VERSION_MOD)' > icc_curr_version
	sed -i 's/ICC_VER "8.."$$/ICC_VER "$(ICC_VERSION_VER).$(ICC_VERSION_REL)"/' $(ICC_ROOT)/icc_test/test_common.c

# MUPPET comes from muppet.mk written by the ICCencapsulator
# - it causes FIPS module from OLD_ICC to get linked in to step library
# triggered by create_all (defined) or create_all_no_legacy (empty)
# Also, iccpkg/gsk_wrap2_a.c written by the ICCencapsulator
# - will select Module functions ICCN_ or ICCC_ or both

show_version_info: buildinfo.h ICC_ver.txt
	echo ICC_ver.txt
	cat ICC_ver.txt
	echo VTAG.mk
	cat VTAG.mk
	echo buildinfo.h
	cat buildinfo.h
	echo iccversion.h
	cat iccversion.h
	echo icc_minor_version.h
	cat icc_minor_version.h
	echo icc_curr_version
	cat icc_curr_version
	grep "PREFIX=" functions.txt
	head -20 $(ICC_ROOT)/iccpkg/gsk_wrap2_a.c
	cat $(ICC_ROOT)/iccpkg/muppet.mk
	echo MUPPET=$(MUPPET)
	echo MYICC=$(MYICC)
	echo IS_FIPS=$(IS_FIPS)
	-ls create*.0

#
# Just an annoyance during dev. builds. It's fine if it's empty. Typically a dev build.
# buildinfo.h is normally written by the build system at extract time.
# Note: buildinfo.h is only included (in iccversion.h) if ICC_OFFICIAL_BUILD is defined in CFLAGS,
# or make ... BUILD=OFFICIAL ...
#
ifeq ($(strip $(ICC_VERSION_MOD)),)
ICC_VERSION_MOD = 0
endif

buildinfo.h:
	touch $@
	echo '#define ICC_PRODUCT_NAME "icc_$(ICC_VERSION_VER).$(ICC_VERSION_REL)"' >> $@
	echo '#define ICC_VERSION_MOD $(ICC_VERSION_MOD)' >> $@
	echo '#define ICC_VERSION_FIX 0' >> $@
	echo '#define ICC_BUILD_DATE ""' >> $@
	echo '#define ICC_BUILD_TIME ""' >> $@
	echo '#define ICC_CMVC_INFO ""' >> $@
	echo '#define ICC_GIT_BRANCH ""' >> $@
	echo '#define ICC_GIT_HASH ""' >> $@
	echo '#define OCKC_GIT_BRANCH ""' >> $@
	echo '#define OCKC_GIT_HASH ""' >> $@

#- Run BVT

# make sure we show the log even if the test fails
log_init:
	touch GSKIT_CRYPTO.log; $(RM) GSKIT_CRYPTO.log; touch GSKIT_CRYPTO.log
log_cat:
	cat GSKIT_CRYPTO.log
	$(RM) GSKIT_CRYPTO.log
log_rm:
	-$(RM) GSKIT_CRYPTO.log

# no dependancies - that causes re-signing into .sig files since they've been deleted
tests: show_version_info pre_test log_init icctest_module log_cat icctest_openssl iccpkg_tests
	@echo $@ complete

# run this before running tests - note: zosa defines this
pre_test:
	$(ICC_RUN_SETUP)

# This runs $(ICCTEST) which is icctest linked to the module, not the step library
# TEST_CMD is set per platform in icc_defs.mak
icctest_module: $(TEST_CMD)
	$(TEST_CMD)
	@echo $@ complete

icctest_openssl:
	$(OPENSSL_PATH_SETUP) $(OPENSSL_TEST_CMD)
	@echo $@ complete

iccpkg_tests: $(ICCPKG_TEST)
	unset MAKEOVERRIDES MAKELEVEL MAKEFILES; \
	$(MAKE) -C $(ICC_ROOT)/iccpkg tests
	@echo $@ complete

# not FIPS:
#LINUX_TARGETS = CAVS
#IA64_LINUX_TARGETS = CAVS

# disable/enable liboqs for all platforms
disable_oqs_build:
	touch icc_oqs build_oqs
enable_oqs_build:
	$(RM) icc_oqs build_oqs

# fix up gsk_wrap2_a.c which may want FIPS module but it is not present
# if it is NOT present then remove calls to it that may be in the step library
gsk_wrap: $(ICC_ROOT)/iccpkg/gsk_wrap2_a.c
	if [ ! -e $(ICC_ROOT)/iccpkg/$(OLD_ICC) ] ; \
	then \
		echo 'FIPS module Not found:' $(ICC_ROOT)/iccpkg/$(OLD_ICC) ; \
		$(CP) $(ICC_ROOT)/iccpkg/gsk_wrap2_a.c $(ICC_ROOT)/iccpkg/gsk_wrap2_a.c.bak ;\
		sed 's/^#define HAVE_C_ICC$$//' $(ICC_ROOT)/iccpkg/gsk_wrap2_a.c.bak > $(ICC_ROOT)/iccpkg/gsk_wrap2_a.c ;\
	fi

#- Just build
# show which pre-build "create" variant we are working with

build_all: gsk_wrap Build_OSSL_Complete SDK_TARGETS ICCPKG_SDK_HEADERS $(PQC_TARGET) $(TARGETS)

# obsolete
#build_all_os400: Build_OSSL_Complete $(TARGETS400)

# Build the performance test code for ICC
$(ICC_PERF): $(ICCLIB_SDK)
	unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
	$(MAKE) -C $(ICC_ROOT)/iccspeed icc;
	$(CP) $(ICC_ROOT)/iccspeed/bin/$(OPSYS)/icc_thread$(EXESUFX) $(ICC_PERF)

icc_test:
	if [ -d $(ICC_ROOT)/icc_test/ ] ; then \
		unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
		$(MAKE) -C $(ICC_ROOT)/icc_test all ; \
	fi

$(ICCPKG_TEST): $(ICCLIB_SDK) PKCS11
	unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
	$(MAKE) -C $(ICC_ROOT)/iccpkg all

# note from icc_defs.mk
# ..._EXTRAS         = PKCS11 PKCS11_PERF
# and $(ICCSDK): $(ICC_PERF) $(EXTRAS)
# So EXTRAS are only for the ICC SDK

# Build the performance test code for PKCS#11
PKCS11_PERF: $(ICCLIB_SDK) PKCS11
	if [ -d $(ICC_ROOT)/pkcs11/ ] ; then \
		unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
		$(MAKE) -C $(ICC_ROOT)/iccspeed pkcs11 ; \
		$(CP) $(ICC_ROOT)/iccspeed/bin/$(OPSYS)/pkcs11_thread$(EXESUFX) $(SDK_DIR)/ ; \
   	fi

$(ICC_ROOT)/pkcs11:
	$(MKDIR) $@

create_pkcs11: $(ICC_ROOT)/pkcs11
	cd $(ICC_ROOT)/pkcs11 && tar xzf $(ICC_ROOT)/openssl_source/pkcs11_v2.20.tar.gz


#
# Note, to build PKCS#11 you need the headers.
# We expect to have installed 
#
PKCS11: $(ICCLIB_SDK)
	if [ -d $(ICC_ROOT)/pkcs11/ ] ; then \
		unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
		$(MAKE) -C $(ICC_ROOT)/pk11/ all ; \
	fi;


#- Clean both ICC & OpenSSL
# use scrubbed to remove openssl (need create_all to get it back)
#- Note the OS400 clean is done directly here, not as a dependency as it won't exist on some platforms
clean_all: clean_openssl clean clean_tools clean_pqc clean_argon
	-$(RM) *.0
	-$(CLEAN400_ICC)
	-$(CLEAN400_OSSL)
	-$(CLEAN400_MODS)	

#- will need a create_all (includes patching) to get it back
remove_openssl:
	-$(RM) -r $(OSSL_DIR)

#- Clean just OpenSSL
clean_openssl:
	-$(CLEAN_OSSL)
	-$(RM) tmp/tmp/*
	-$(RM) tmp/*$(OBJSUFX) tmp/dummyfile
	-$(RM) Build_OSSL_Complete


#- Clean just ICC
clean: clean_perf clean_pkcs11 clean_iccpkg clean_icc clean_icc_test

# Note: some artifacts may be from older builds that are not used anymore but can interfere (like .h files)
clean_icc:
	-$(RM) $(TARGETS) *.o *.obj $(EXTRA_FILES) $(SDK_DIR)/*.h $(ASMOBJS)
	-$(RM) ./openssl$(EXESUFX) $(SHLPRFX)icclib$(SHLSUFX) $(STLPRFX)icc$(STLSUFX)
	-$(RM) *.so *.dylib *.dll *.sl *.x *.lib
	-$(RM) aes_gcm.* aes_ccm.* nist_algs1.c
	-$(RM) delta.exp
	-$(RM) ICCTEST_BUILT
	-$(RM) *.ilk *.manifest *.pdb *.class
	-$(RM) -r $(ICC_ROOT)/package
	-$(RM) -r $(SDK_DIR)/*
	-$(RM) openssl.c high_res_timer.c
	-$(RM) iccVdump$(EXESUFX)
	-$(RM) ICCSIG.txt ICCLIB_SA.txt newicc.c
	-$(RM) -r $(ZLIB_DIR)/x64
	-find $(ICC_ROOT)/msvc -name "x64" -type d -exec rm -rf {} +
	-find $(ICC_ROOT)/msvc -name "*.user" -exec rm {} +

clean_icc_test:
	if [ -d $(ICC_ROOT)/icc_test/ ] ; then \
		unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
		$(MAKE) -C $(ICC_ROOT)/icc_test clean ; \
	fi

# tools has no Makefile
clean_tools:
	-$(RM) $(TOOLS)

clean_perf:
	if [ -d $(ICC_ROOT)/iccspeed/ ] ; then \
		unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
		$(MAKE) -C $(ICC_ROOT)/iccspeed clean ; \
	fi

clean_pkcs11:
	if [ -d $(ICC_ROOT)/pk11/ ] ; then \
		unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
		$(MAKE) -C $(ICC_ROOT)/pk11 clean ; \
	fi

clean_iccpkg:
	if [ -d $(ICC_ROOT)/iccpkg/ ] ; then \
		unset MAKEOVERRIDES MAKELEVEL MAKEFILES ; \
		$(MAKE) -C $(ICC_ROOT)/iccpkg clean ; \
	fi

#- Clean out everything including the autogenerated files
# Will need a create_all after this to get openssl back

scrubbed: clean clean_libArgon
	-$(RM) $(AUTOGEN) exports/* $(ICC_ROOT)/iccpkg/exports/* ICCencapsulator.class
	-$(RM) -r $(OSSL_DIR)

#- Build ICC package files (SDK & RTE)
package_all: $(ICCSDK) $(ICCRTE)


#- Build ICC SDK
$(ICCSDK): $(ICC_PERF) $(EXTRAS)
	- cd $(PACKAGE_DIR); $(TARCMD) iccsdk.tar iccsdk

#- Build ICC RTE
$(ICCRTE): $(RTE_DIR)/ReadMe.txt $(NOSHIP_RTE_DIR)/ReadMe.txt
	- cd $(PACKAGE_DIR); $(RM) icc/icclib/*.exp icc/icclib/*.lib
	- cd $(PACKAGE_DIR); $(TARCMD) iccrte.tar icc/ReadMe.txt icc/icclib

# SDK_DIR, iccpkg - These headers will link an application to the ICC module, not the step library
# GSK_SDK, gsk_sdk - is the step library includes - icc_a.h (iccpkg_a.h) has the ICC_ prefix - ref gsk_crypto.mk 

$(SDK_DIR)/icc.h: icc.h $(SDK_DIR)
	$(CP) icc.h $@

$(SDK_DIR)/icc_a.h: icc_a.h $(SDK_DIR)
	$(CP) icc_a.h $@

$(SDK_DIR)/iccglobals.h: iccglobals.h $(SDK_DIR)
	$(CP) iccglobals.h $@

# get a local copy of mystdint.h from DilKyb dir - icclib.c needs it for Argon2
$(SDK_DIR)/mystdint.h: $(ICC_ROOT)/iccpkg/mystdint.h $(SDK_DIR)
	$(CP) $(ICC_ROOT)/iccpkg/mystdint.h $@

# List of objs - minus the trigger for exec on load in a shared object
LIBOBJS1 =   fips$(OBJSUFX)  \
	platform$(OBJSUFX) \
	iccerr$(OBJSUFX) status$(OBJSUFX) \
	fips-prng-RAND$(OBJSUFX) fips-prng-err$(OBJSUFX) \
	SP800-90$(OBJSUFX) \
	SP800-90HashData$(OBJSUFX) \
	ds$(OBJSUFX)  \
	SP800-90Cipher$(OBJSUFX) utils$(OBJSUFX) \
	SP800-90HMAC$(OBJSUFX) \
	SP800-108$(OBJSUFX) \
	$(ASMOBJS) $($(OPSYS)_LIBOBJS) \
	timer_entropy$(OBJSUFX) \
	personalise$(OBJSUFX) \
	noise_to_entropy$(OBJSUFX) \
	entropy_estimator$(OBJSUFX) \
	nist_algs$(OBJSUFX) \
	entropy_to_NRBG$(OBJSUFX) \
	timer_fips$(OBJSUFX) \
	TRNG_FIPS$(OBJSUFX) \
	TRNG_ALT$(OBJSUFX) \
	TRNG_ALT4$(OBJSUFX) \
	ICC_NRBG$(OBJSUFX) \
	SP800-90TRNG$(OBJSUFX) \
	extsig$(OBJSUFX) \
	SP80038F$(OBJSUFX) \
	OS_helpers$(OBJSUFX) \
	looper$(OBJSUFX) \

#- define the set of objects that end up in the ICC shared library
#- OSSL_XTRA_OBJ are files that massage the OpenSSL API to preserve
#- the ICC API across releases
LIBOBJS =   $(LIBOBJS1) platfsl$(OBJSUFX) $(OSSL_XTRA_OBJ)

#
# Get the OpenSSL objects expanded (tmp/dummyfile)
# and selectively copied
#
#Note: BUILD_OBJS coming from $(OPSYS)_.mk includes BASE_OBJS (from BASE_OSSL_FILES.mk)

tmp/tmp/dummyfile:  Build_OSSL_Complete tmp/dummyfile
	-$(MKDIR) tmp/tmp
	(cd tmp ; \
	$(CP) $(BUILD_OBJS) tmp/ ;\
	cd .. ; \
	)
	touch tmp/tmp/dummyfile

#- Build ICC shared library
#- $(ASMOBJS) is required to cater for small assembler files
#- needed on some platforms
#- Split this into 2 phases for the OS/X fat binaries work - resolves circular dependencies
# this is target for icclib085 shared library (icclib084 if FIPS)
# the target for the step library is in iccpkg/platforms/*

$(ICCDLL_NAME): Makefile $(PQC_TARGET) privkey.rsa icclib$(OBJSUFX) $(LIBOBJS) $(STLPRFX)zlib$(STLSUFX) tmp/tmp/dummyfile signer$(EXESUFX) tracer.h extsig.h $(GSK_SDK) $(ICC_RTE_DIR) $(NOSHIP_ICC_RTE_DIR) $(ARGON)
	$(SLD) $(SLDFLAGS) $(ICCLIB_LNK) $(EXPORT_FLAG)$(ICCLIB_EXPFILE)  icclib$(OBJSUFX) $(LIBOBJS) $(STLPRFX)zlib$(STLSUFX) \
		$(ARGON) tmp/tmp/*$(OBJSUFX) $(LDLIBS) $(PQCLIBS)
#- Unstripped goes into NOSHIP and sdk
	$(OPENSSL_PATH_SETUP) ./signer$(EXESUFX) ICCSIG.txt privkey.rsa -SELF -FILE $(ICCDLL_NAME) $(TWEAKS) "ICC_ALLOW_2KEY3DES=1"
	$(CP) ICCSIG.txt $(NOSHIP_ICC_RTE_DIR)/
#- Unstripped goes into NOSHIP and sdk
ifeq ($(findstring WIN, $(OPSYS)), WIN)
	$(CP) $@ $(GSK_SDK)/
else
	$(CP) $@ $(NOSHIP_ICC_RTE_DIR)/$@.unstripped
	$(CP) $@ $(GSK_SDK)/$@.unstripped
	$(STRIP) $@
endif
#- Regular lib
	$(OPENSSL_PATH_SETUP) ./signer$(EXESUFX) ICCSIG.txt privkey.rsa -SELF -FILE $(ICCDLL_NAME) $(TWEAKS) "ICC_ALLOW_2KEY3DES=1"
	$(CP) ICCSIG.txt $(ICC_RTE_DIR)/

#
# Add MS Authenticode signing
#
$(ICC_RTE_DIR)/$(SHLPRFX)icclib$(VTAG).dll: $(ICC_RTE_DIR) $(SDK_DIR) $(ICCDLL_NAME) signer$(EXESUFX)
	$(CP) $(ICCDLL_NAME) $@
	( \
		if [ -e $(SIGN_COMMAND) ] ; then \
			echo "Authenticode signing $@" ; \
			$(SIGN_COMMAND) $@ ; \
			$(CP) $@ $(ICCDLL_NAME) ; \
			touch $@ ; \
		else \
			echo " $(SIGN_COMMAND) is missing skip signing $@" ;\
		fi ;\
	)
	$(OPENSSL_PATH_SETUP) ./signer$(EXESUFX) ICCSIG.txt privkey.rsa -SELF -FILE  $(ICCDLL_NAME) $(TWEAKS)
	$(CP) $(ICCDLL_NAME) $@
	$(CP) ICCSIG.txt $(ICC_RTE_DIR)/ 
	-$(CP) $(SHLPRFX)icclib$(VTAG).pdb $(SDK_DIR)/
	-$(CP) tmp/*.pdb $(SDK_DIR)/ 
	-$(CP) $(SHLPRFX)icclib$(VTAG).x $(SDK_DIR)

$(ICC_RTE_DIR)/$(SHLPRFX)icclib$(VTAG).so : $(ICC_RTE_DIR) $(ICCDLL_NAME)
	$(CP) $(ICCDLL_NAME) $@

$(ICC_RTE_DIR)/$(SHLPRFX)icclib$(VTAG).sl :$(ICC_RTE_DIR) $(ICCDLL_NAME)
	$(CP) $(ICCDLL_NAME) $@

$(ICC_RTE_DIR)/$(SHLPRFX)icclib$(VTAG).dylib : $(ICC_RTE_DIR) $(ICCDLL_NAME)
	$(CP) $(ICCDLL_NAME) $@

#- Compile the ICC shared library main source
icclib$(OBJSUFX): Makefile icclib.c loaded.c loaded.h iccglobals.h platform.h iccversion.h \
	platfsl.h iccerr.h $(TRNG_DIR)/ICC_NRBG.h tracer.h icc.h icc_a.h extsig.h $(SDK_DIR)/mystdint.h
	$(CC) $(CFLAGS) -DOPSYS="\"$(OPSYS)\"" -DICCDLL_NAME="\"$(ICCDLL_NAME)\"" -DMYNAME=icclib$(VTAG) \
		-DINSTDIR=\""$(GSK_GLOBAL)"\" $(PQCINC) -I./ -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR) icclib.c


# Code specifically for Java/JCEPlus
OS_helpers$(OBJSUFX): OS_helpers.c
	$(CC) $(CFLAGS) OS_helpers.c

#===========================================================================
#
#- Build ICC TRNG code
#- Note some platforms, SUN_SOL8/SUN64 AIX/AIX64 need added assembler tweaks
#  which affect timer_entropy.c
#
TRNG_HDRS	= -I./ -I$(ICC_ROOT)/$(ZLIB) -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(TRNG_DIR) -I$(API_DIR)

TRNG_OBJS   = 	timer_entropy$(OBJSUFX) timer_fips$(OBJSUFX) \
					personalise$(OBJSUFX) nist_algs$(OBJSUFX) noise_to_entropy$(OBJSUFX) \
					entropy_estimator$(OBJSUFX) \
					TRNG_FIPS$(OBJSUFX) \
					TRNG_ALT$(OBJSUFX) \
					TRNG_ALT4$(OBJSUFX) \
					ICC_NRBG$(OBJSUFX) \
					looper$(OBJSUFX)

# Base routines to read TSC register equivalents
# Note: Depends on asm routines in OpenSSL on some platforms
timer_entropy$(OBJSUFX):  $(TRNG_DIR)/timer_entropy.c  $(TRNG_DIR)/timer_entropy.h
	$(CC) $(CFLAGS) $(TRNG_HDRS) $(ASM_TWEAKS) $(TRNG_DIR)/timer_entropy.c

# Conditioning for FIPS
# PROC_DEBIAS enables distribution squeezing. That needs to be turned
# off in all the test code.
timer_fips$(OBJSUFX):  $(TRNG_DIR)/timer_fips.c  $(TRNG_DIR)/timer_entropy.h $(TRNG_DIR)/timer_fips.h
	$(CC) $(CFLAGS) -DPROC_DEBIAS $(TRNG_HDRS) $(TRNG_DIR)/timer_fips.c


# Generic personalization routines
personalise$(OBJSUFX):  $(TRNG_DIR)/personalise.c  $(TRNG_DIR)/personalise.h
	$(CC) $(CFLAGS) $(TRNG_HDRS)  $(TRNG_DIR)/personalise.c

# Generic algs, pmax, AP, RC + self test
nist_algs$(OBJSUFX): $(TRNG_DIR)/nist_algs.c $(TRNG_DIR)/nist_algs.h
	$(CC) $(CFLAGS) $(TRNG_HDRS) $(TRNG_DIR)/nist_algs.c

# Timing delay loop, in it's own file to try and hide from optimisers
looper$(OBJSUFX): $(TRNG_DIR)/looper.c
	$(CC) $(CFLAGS) $(TRNG_HDRS) $(TRNG_DIR)/looper.c

# Take a noise source, make sure data extracted meets entropy guarantees
noise_to_entropy$(OBJSUFX):  $(TRNG_DIR)/noise_to_entropy.c  $(TRNG_DIR)/noise_to_entropy.h 
	$(CC) $(CFLAGS) $(TRNG_HDRS) $(TRNG_DIR)/noise_to_entropy.c

# Entropy to NRBG
entropy_to_NRBG$(OBJSUFX):  $(TRNG_DIR)/entropy_to_NRBG.c \
	$(TRNG_DIR)/entropy_to_NRBG.h $(TRNG_DIR)/noise_to_entropy.h
	$(CC) $(CFLAGS)  $(TRNG_HDRS) $(TRNG_DIR)/entropy_to_NRBG.c

# Code to return an entropy estimate, defences against problems the NIST algs are weak at (Patterns/counters)
entropy_estimator$(OBJSUFX):  $(TRNG_DIR)/entropy_estimator.c  $(TRNG_DIR)/entropy_estimator.h
	$(CC) $(CFLAGS) $(TRNG_HDRS)  $(TRNG_DIR)/entropy_estimator.c

# Unused
minibuf$(OBJSUFX): $(TRNG_DIR)/minibuf.c  $(TRNG_DIR)/minibuf.h
	$(CC) $(CFLAGS)  $(TRNG_HDRS)  $(TRNG_DIR)/minibuf.c


MINIMAL$(OBJSUFX):  $(TRNG_DIR)/MINIMAL.c  $(TRNG_DIR)/MINIMAL.h  $(TRNG_DIR)/timer_entropy.h
	$(CC) $(CFLAGS)  $(TRNG_HDRS)  $(TRNG_DIR)/MINIMAL.c

# FIPS variant
TRNG_FIPS$(OBJSUFX): $(TRNG_DIR)/TRNG_FIPS.c $(TRNG_DIR)/TRNG_FIPS.h  $(TRNG_DIR)/timer_entropy.h 
	$(CC) $(CFLAGS)  $(TRNG_HDRS)  $(TRNG_DIR)/TRNG_FIPS.c

# Noise ^ (/dev/(u)random | HW)
TRNG_ALT$(OBJSUFX): $(TRNG_DIR)/TRNG_ALT.c $(TRNG_DIR)/TRNG_ALT.h  $(TRNG_DIR)/timer_entropy.h 
	$(CC) $(CFLAGS)  $(TRNG_HDRS)  $(TRNG_DIR)/TRNG_ALT.c


# Direct HW, assuming that has a FIPS cert. of it's own
TRNG_ALT4$(OBJSUFX):  $(TRNG_DIR)/TRNG_ALT4.c  $(TRNG_DIR)/timer_entropy.h $(PRNG_DIR)/SP800-90.h $(TRNG_DIR)/TRNG_ALT4.h
	$(CC) $(CFLAGS) $(TRNG_HDRS)  $(TRNG_DIR)/TRNG_ALT4.c

# Common code for all the TRNG's

ICC_NRBG$(OBJSUFX): $(TRNG_DIR)/ICC_NRBG.c  $(TRNG_DIR)/ICC_NRBG.h \
	$(TRNG_DIR)/TRNG_FIPS.h $(TRNG_DIR)/TRNG_ALT.h \
	$(TRNG_DIR)/TRNG_ALT4.h
	$(CC) $(CFLAGS) $(TRNG_HDRS)   $(TRNG_DIR)/ICC_NRBG.c

# API access direct to the TRNG's, mainly for testing

SP800-90TRNG$(OBJSUFX):   $(TRNG_DIR)/SP800-90TRNG.c  $(PRNG_DIR)/SP800-90.h $(PRNG_DIR)/SP800-90i.h
	$(CC) $(CFLAGS) $(TRNG_HDRS)   $(TRNG_DIR)/SP800-90TRNG.c

# Stand alone test executables for the NIST algorithm internal tests

#nist_algs1.c: $(TRNG_DIR)/nist_algs.c 
#	$(CP)  $(TRNG_DIR)/nist_algs.c $@

nist_algs1$(OBJSUFX): $(TRNG_DIR)/nist_algs.c $(TRNG_DIR)/nist_algs.h
	$(CC) $(CFLAGS) -DSTANDALONE=1 $(TRNG_HDRS) $(TRNG_DIR)/nist_algs.c $(OUT)$@

nist_algs$(EXESUFX): nist_algs1$(OBJSUFX) 
	$(LD) $(LDFLAGS)  nist_algs1$(OBJSUFX) $(LD_LIBS)



#=============================== Code sign/verify    ==============================

#- stand alone signing tool
privkey.rsa:
	$(OPENSSL_PATH_SETUP) $(REALOPENSSL) genrsa -out privkey.rsa 2048

pubkey.h: privkey.rsa
	$(OPENSSL_PATH_SETUP) $(REALOPENSSL) rsa -in privkey.rsa -outform DER -RSAPublicKey_out > rsa_pub_key.der
	echo "/*This is an auto generated code please DO NOT modify*/" > pubkey.h
	perl bin2hex.pl rsa_pub_key.der temp.h
	cat temp.h >> pubkey.h
	rm temp.h rsa_pub_key.der

signer$(OBJSUFX): extsig.c
	$(CC) -DSTANDALONE -DOPSYS=\"$(OPSYS)\" $(CFLAGS) -I$(OSSLINC_DIR) extsig.c $(OUT)$@

signer$(EXESUFX): signer$(OBJSUFX) $(SLIBCRYPTO)
	$(LD) $(LDFLAGS) signer$(OBJSUFX) $(SLIBCRYPTO) $(LDLIBS)

# ref tools.mk icclib_sa uses extsig.o
extsig$(OBJSUFX): extsig.c
	$(CC) $(CFLAGS) -I$(SDK_DIR)  -I$(OSSLINC_DIR) extsig.c

#- Build ICC Err code
iccerr$(OBJSUFX): iccerr.c iccerr.h $(SDK_DIR)/iccglobals.h
	$(CC) $(CFLAGS)  -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) iccerr.c

#- Build ICC status message code
status$(OBJSUFX): status.c status.h icclib.h 
	$(CC) $(CFLAGS)  -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR) status.c

#- Build ICC FIPS code
fips$(OBJSUFX): pubkey.h fips.c fips.h icclib.h iccerr.h $(PRNG_DIR)/fips-prng-RAND.h tracer.h 
	$(CC) $(CFLAGS) -I./  -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR) fips.c

#- Compile the FIPS prng code
fips-prng-err$(OBJSUFX): $(PRNG_DIR)/fips-prng-err.c $(PRNG_DIR)/fips-prng-err.h
	$(CC) $(CFLAGS)  -I$(OSSLINC_DIR) -I$(OSSL_DIR) $(PRNG_DIR)/fips-prng-err.c

fips-prng-RAND$(OBJSUFX): $(PRNG_DIR)/fips-prng-RAND.c $(PRNG_DIR)/fips-prng-RAND.h $(PRNG_DIR)/fips-prng-err.h icclib.h
	$(CC) $(CFLAGS) -I./ -I$(TRNG_DIR) -I$(ICC_ROOT)/$(ZLIB) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR) $(PRNG_DIR)/fips-prng-RAND.c

SP800-90$(OBJSUFX): $(PRNG_DIR)/SP800-90.c $(PRNG_DIR)/ds.h \
	$(PRNG_DIR)/SP800-90.h $(PRNG_DIR)/SP800-90i.h
	$(CC) $(CFLAGS) -I./ -I$(ICC_ROOT)/$(ZLIB) -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR)  -I$(API_DIR) $(PRNG_DIR)/SP800-90.c

SP800-90HashData$(OBJSUFX): $(PRNG_DIR)/SP800-90HashData.c \
	 $(PRNG_DIR)/SP800-90.h $(PRNG_DIR)/SP800-90i.h
	$(CC) $(CFLAGS) -I./ -I$(ICC_ROOT)/$(ZLIB) -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR) $(PRNG_DIR)/SP800-90HashData.c

SP800-90Cipher$(OBJSUFX): $(PRNG_DIR)/SP800-90Cipher.c \
	 $(PRNG_DIR)/SP800-90.h $(PRNG_DIR)/SP800-90i.h
	$(CC) $(CFLAGS) -I./ -I$(ICC_ROOT)/$(ZLIB) -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR) $(PRNG_DIR)/SP800-90Cipher.c

SP800-90HMAC$(OBJSUFX): $(PRNG_DIR)/SP800-90HMAC.c \
	 $(PRNG_DIR)/SP800-90.h $(PRNG_DIR)/SP800-90i.h
	$(CC) $(CFLAGS) -I./ -I$(ICC_ROOT)/$(ZLIB) -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR) $(PRNG_DIR)/SP800-90HMAC.c

ds$(OBJSUFX): $(PRNG_DIR)/ds.c $(PRNG_DIR)/ds.h 
	$(CC) $(CFLAGS)  -I./ -I$(PRNG_DIR) $(PRNG_DIR)/ds.c

utils$(OBJSUFX): $(PRNG_DIR)/utils.c  $(PRNG_DIR)/utils.h
	$(CC) $(CFLAGS)  -I./ -I$(PRNG_DIR) $(PRNG_DIR)/utils.c

# KDF's

SP800-108$(OBJSUFX): SP800_108/SP800-108.c   SP800_108/SP800-108.h
	$(CC) $(CFLAGS)  -I./ -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR) SP800_108/SP800-108.c

# Key Wrap
SP80038F$(OBJSUFX): SP800_38F/SP80038F.c   SP800_38F/SP80038F.h
	$(CC) $(CFLAGS)  -I./ -Ifips-prng/ -I$(SDK_DIR) -I$(OSSLINC_DIR) -I$(OSSL_DIR) SP800_38F/SP80038F.c

#- Build platform dependent code

platform$(OBJSUFX): platform.c platform.h
	$(CC) $(CFLAGS) -I$(OSSLINC_DIR) -I$(OSSL_DIR) -I$(API_DIR)  -I./  -I$(SDK_DIR)/ platform.c

platfsl$(OBJSUFX): platfsl.c platfsl.h platform.h
	$(CC) $(CFLAGS)  -I$(OSSLINC_DIR) -I$(OSSL_DIR)  -I./  -I$(SDK_DIR)/ platfsl.c

# ICCLIB_LINK is never defined.

#- Build ICC static library stub
$(STLPRFX)icc$(STLSUFX):  $(MYICC)$(OBJSUFX)
	$(AR) $(ARFLAGS) $(MYICC)$(OBJSUFX) $(ICCLIB_LINK)  

# Copy the ICC static library stub to the sdk directory
# Done this way so we can build fat libs on OS/X without circular dependencies
$(ICCLIB_SDK): $(ICCLIB) $(SDK_DIR)
	$(CP) $< $@


#- Compile the ICC static stub library source
#- part of SDK for OS400

# note zOS
# we need the copy for this one as the linker cannot handle if there is another icc.o/icc.c
# OLD_ICC (FIPS) and non-FIPS both have icc.c that will conflict in the link
$(MYICC).c: icc.c
	$(CP) icc.c $@

$(MYICC)$(OBJSUFX): $(MYICC).c icc_a.c icc.h icc_a.h platform.h iccversion.h
	$(CC) $(CFLAGS) $(SDKFLAGS) -I./ -I$(OSSLINC_DIR) -I$(OSSL_DIR) $(MYICC).c $(OUT)$@

# Notes:
# ICCLIB is the ICC module static library
# This icctest is different from iccpkg/icctest which links to the step library
# icc_test/Makefile looks for ICCTEST_BUILT as a pre-req to running tests

#- Build ICC test executables
$(ICCTEST): $(ICCDLL) $(ICCLIB) icctest$(OBJSUFX) 
	$(LD) $(LDFLAGS) icctest$(OBJSUFX) $(ICCLIB) $(LDLIBS) 
	touch ICCTEST_BUILT

#- Compile the ICC test code source

icctest$(OBJSUFX): icctest.c icc.h icc_a.h iccglobals.h
	$(CC) $(CFLAGS) -I./ icctest.c


# libcrypto.sl.1.1.1 is another alias - usually libcrypto.sl.1.1
# probably not used - ignore error

$(OSSLOBJ_DIR)/$(SHLPRFX)crypto$(SHLSUFX).$(OPENSSL_LIBVER): Build_OSSL_Complete
	$(RM) $@
	-ln -s $(OSSLOBJ_DIR)/$(SHLPRFX)crypto$(SHLSUFX)  $@

# this is in WIN_like.mk - probably should be here instead
#$(ICC_ROOT)/$(OPENSSL_VER)/apps/openssl$(OBJSUFX): $(ICC_ROOT)/$(OPENSSL_VER)/apps/openssl.c
#	$(BUILD_OSSL)

#
# Bail if the directory isn't present - checked via the Configure script
# BUILD_OSSL is coming from icc_defs.mk It is the ./Configure command to build openssl
#
Build_OSSL_Complete: $(OSSL_DIR)/Configure
	$(BUILD_OSSL)
	$(RM) $(ICCTEST) ICCTEST_BUILT
	touch Build_OSSL_Complete

#- Copy OpenSSL crypto library to package directory
# moved to platforms/_.mk (HP is special cased)

$(SLIBCRYPTO): Build_OSSL_Complete $(OSSLOBJ_DIR)/$(SHLPRFX)crypto$(SHLSUFX).$(OPENSSL_LIBVER)


$(RTE_DIR)/ReadMe.txt: $(RTE_DIR) ICC_ReadMe.txt
	$(CP) ICC_ReadMe.txt $@
	chmod +w $@
	-cat $(OSSL_DIR)/LICENSE >> $@

$(NOSHIP_RTE_DIR)/ReadMe.txt: ICC_ReadMe.txt
	$(CP) ICC_ReadMe.txt $@
	chmod +w $@
	-cat $(OSSL_DIR)/LICENSE >> $@

#$(RTE_DIR)/Standard_International_Program_License_Agreement.pdf: $(RTE_DIR) Standard_International_Program_License_Agreement.pdf
#	$(CP) Standard_International_Program_License_Agreement.pdf $@
#	chmod +w $@
#
#$(NOSHIP_RTE_DIR)/Standard_International_Program_License_Agreement.pdf: Standard_International_Program_License_Agreement.pdf
#	$(CP) Standard_International_Program_License_Agreement.pdf $@
#	chmod +w $@


#- Assist in debugging Makefiles, show config. Also useful for build.
show_config:
	echo "Set in Makefile"
	echo "=========== Config ================"
	echo "ICC VERSION       = " "$(ICC_VERSION_VER).$(ICC_VERSION_REL)"
	echo "OPSYS  		= " "$(OPSYS)" 
	echo "CONFIG 		= " "$(CONFIG)"
	echo "BUILD  		= " "$(BUILD)"
	echo "ZLIB              = " "$(ZLIB)"
	echo "XPLINK            = " "$(XPLINK)"
	echo "PQC_TARGET    = " "$(PQC_TARGET)"
	echo "ARGON         = " "$(ARGON)"
	echo "========== Directories ============"
	echo "PACKAGE_DIR	= " "$(PACKAGE_DIR)"
	echo "RTE_DIR		= " "$(RTE_DIR)"
	echo "SDK_DIR		= " "$(SDK_DIR)"
	echo "PRNG_DIR		= " "$(PRNG_DIR)"
	echo "OSSL_RTE_DIR	= " "$(OSSL_RTE_DIR)"
	echo "ICC_RTE_DIR	= " "$(ICC_RTE_DIR)"
	echo "OSSL_DIR		= " "$(OSSL_DIR)"
	echo "ZLIB_DIR          = " "$(ZLIB_DIR)"
	echo "============= Files ==============="
	echo "ICCDLL_NAME	= " $(ICCDLL_NAME)
	echo "ICCDLL		= " $(ICCDLL)
	echo "ICCLIB		= " $(ICCLIB)
	echo "ICCLIB_SDK	= " $(ICCLIB_SDK)
	echo "OSSLLIB		= " $(OSSLLIB)
	echo "ICCTEST		= " $(ICCTEST)
	echo "PRNGTST1		= " $(PRNGTST1)
	echo "PRNGTST2		= " $(PRNGTST2)
	echo "ICCSDK		= " $(ICCSDK)
	echo "ICCRTE		= " $(ICCRTE)	
	echo "MUPPET		= " $(MUPPET)	
	echo 
	echo "From platforms.mk"
	echo "========= System utils ============" 
	echo "RM 		= " "$(RM)"
	echo "MKDIR 		= " "$(MKDIR)"
	echo "CP		= " "$(CP)"
	echo "DEBUGGER		= " "$(DEBUGGER)"
	echo "CC		= " "$(CC)"
	echo "CXX		= " "$(CXX)"
	echo "CFLAGS		= " "$(CFLAGS)"
	echo "CFLAGS2		= " "$(CFLAGS2)"
	echo "LD		= " "$(LD)"
	echo "LD_CXX		= " "$(LD_CXX)"
	echo "SLD		= " "$(SLD)"
	echo "AR		= " "$(AR)"
	echo "STRIP		= " "$(STRIP)"
	echo "OUT		= " "$(OUT)"
	echo "ICC_RUN_SETUP     = " "$(ICC_RUN_SETUP)"
	echo "=========== Flags ================="
	echo "LDFLAGS		= " "$(LDFLAGS)"
	echo "SLDFLAGS		= " "$(SLDFLAGS)"
	echo "LDFLAGS2		= " "$(LDFLAGS2)"
	echo "SLDFLAGS2		= " "$(SLDFLAGS2)"
	echo "ARFLAGS		= " "$(ARFLAGS)"
	echo "LDLIBS		= " "$(LDLIBS)"
	echo "ICCLIB_LNK        = " "$(ICCLIB_LNK)"
	echo "======= Filename extensions ======="
	echo "OBJSUFX		= " "$(OBJSUFX)"
	echo "EXESUFX		= " "$(EXESUFX)"
	echo "SHLPRFX		= " "$(SHLPRFX)"
	echo "SHLSUFX		= " "$(SHLSUFX)"
	echo "STLPRFX		= " "$(STLPRFX)"
	echo "STLSUFX		= " "$(STLSUFX)"
	echo 
	echo "Set in opensslver.mk"
	echo "OPENSSL_LIBVER    = " "$(OPENSSL_LIBVER)"
	echo "OPENSSL_BIN       = " "$(OPENSSL_BIN)"
	echo "OSSL_FLAGS        = " "$(OSSL_FLAGS)"
	echo 
	echo "Set in icc_defs.mk"
	echo "EXPORT_FLAG	= " "$(EXPORT_FLAG)"
	echo "ICCLIB_EXPFILE	= " "$(ICCLIB_EXPFILE)"
	echo "OSSLLIB_NAME	= " "$(OSSLLIB_NAME)"
	echo "OSSLINC_DIR	= " "$(OSSLINC_DIR)"
	echo "OSSLOBJ_DIR	= " "$(OSSLOBJ_DIR)"
	echo "OPENSSL		= " "$(OPENSSL)"
	echo "BUILD_OSSL	= " "$(BUILD_OSSL)"
	echo "CLEAN_OSSL	= " "$(CLEAN_OSSL)"
	echo "TARCMD		= " "$(TARCMD)"
	echo "TEST_CMD		= " "$(TEST_CMD)"
	echo "ASM_TWEAKS	= " "$(ASM_TWEAKS)"
	echo "ASMMAK		= " "$(ASMMAK)"
	echo "ASMOBJS		= " "$(ASMOBJS)"
	echo "ICCLIB_FLAGS	= " "$(ICCLIB_FLAGS)"
	echo "OSOBJS		= " "$(OSOBJS)"
	echo "MAKE_ZLIB         = " "$(MAKE_ZLIB)"
	echo "EXTRAS            = " "$(EXTRAS)"
	echo "TARGETS           = " "$(TARGETS)"	
	echo "MANIFESTS         = " "$(MANIFESTS)"
	echo "CAVSON        	= " "$(CAVSON)"
	echo "CAVSBVT        	= " "$(CAVSBVT)"
	echo

show_ossl:
	@echo "E_OBJ       	= " "$(E_OBJ)"
	@echo "ASM_OBJS    	= " "$(ASM_OBJS)"
	@echo "SLIBCRYPTO  	= " "$(SLIBCRYPTO)"
	@echo "SLIBSSL     	= " "$(SLIBSSL)"
	@echo REALOPENSSL = "$(REALOPENSSL)"
	@echo MYOPENSSL = "$(MYOPENSSL)"
	@echo OPENSSL_PATH_SETUP = "$(OPENSSL_PATH_SETUP)"
	
