/*************************************************************************
// Copyright IBM Corp. 2023
//
// Licensed under the Apache License 2.0 (the "License").  You may not use
// this file except in compliance with the License.  You can obtain a copy
// in the file LICENSE in the source distribution.
*************************************************************************/

/*************************************************************************
// Description: SP800-90 HMAC modes
//
*************************************************************************/


#include "icclib.h"
#include "SP800-90.h"
#include "SP800-90i.h"
#include "ds.h"
#include "utils.h"

static const unsigned char C00[1] = {0x00};
static const unsigned char C01[1] = {0x01};


/*! 
   HHAC based PRNG's 
*/

/*!
  @brief Core SP800-90 HMAC routine, takes the old K,V,entropy
  creates the new K,V
  @param pctx pointer to an internal SP800-90 structure
  @param ds pointer to a data chain structure
*/
void SP_HMAC_Update(SP800_90PRNG_Data_t *pctx,DS *ds)
{
  unsigned int len = 0;
  unsigned char *ptr = NULL;
  
  /* K = HMAC(K,V || 0x00 || provided data); */
  HMAC_Init_ex(pctx->ctx.hmac_ctx,pctx->K,pctx->prng->OBL,pctx->alg.md,NULL);
  /* V */
  HMAC_Update(pctx->ctx.hmac_ctx,pctx->V,pctx->prng->OBL);
  /* 0x00 */
  HMAC_Update(pctx->ctx.hmac_ctx,C00,1);
  /* provided data */
  while(ds->total) {
    DS_Extract(ds,&len,&ptr);
    HMAC_Update(pctx->ctx.hmac_ctx,ptr,len);
  }
  HMAC_Final(pctx->ctx.hmac_ctx,pctx->K,&len);
  HMAC_CTX_cleanup(pctx->ctx.hmac_ctx);
  /* V = HMAC(K,V) */
  HMAC_Init_ex(pctx->ctx.hmac_ctx,pctx->K,pctx->prng->OBL,pctx->alg.md,NULL); 
  HMAC_Update(pctx->ctx.hmac_ctx,pctx->V,pctx->prng->OBL);
  HMAC_Final(pctx->ctx.hmac_ctx,pctx->V,&len);
  HMAC_CTX_cleanup(pctx->ctx.hmac_ctx);

  DS_Reset(ds);
  /* if (provided_data != NULL) { */
  if(ds->total) {
    /* K = HMAC(K,V || 0x01 || provided data); */
    HMAC_Init_ex(pctx->ctx.hmac_ctx,pctx->K,pctx->prng->OBL,pctx->alg.md,NULL);
    /* V */
    HMAC_Update(pctx->ctx.hmac_ctx,pctx->V,pctx->prng->OBL);
    /* 0x01 */
    HMAC_Update(pctx->ctx.hmac_ctx,C01,1);
    /* provided data */
    while(ds->total) {
      DS_Extract(ds,&len,&ptr);      
      HMAC_Update(pctx->ctx.hmac_ctx,ptr,len);
    }
    HMAC_Final(pctx->ctx.hmac_ctx,pctx->K,&len);
    HMAC_CTX_cleanup(pctx->ctx.hmac_ctx);
    /* V = HMAC(K,V) */
    HMAC_Init_ex(pctx->ctx.hmac_ctx,pctx->K,pctx->prng->OBL,pctx->alg.md,NULL);
    HMAC_Update(pctx->ctx.hmac_ctx,pctx->V,pctx->prng->OBL); 
    HMAC_Final(pctx->ctx.hmac_ctx,pctx->V,&len);
    HMAC_CTX_cleanup(pctx->ctx.hmac_ctx);
  }
}
/*!
  @brief Instantiate function for HMAC based PRNG's
  @param ctx a partially initialized PRNG context
  @param ein a pointer to the entropy input buffer. (May be NULL)
  @param einl a pointer to the length of the provided entropy
  @param nonce additional entropy
  @param nonl a pointer to the length of the provided entropy
  @param person a pointer to the personalization data
  @param perl a pointer to the length of the personalization data
 */
static SP800_90STATE SP_HMAC_Instantiate(PRNG_CTX *ctx,
			      unsigned char *ein, unsigned int einl,
			      unsigned char *nonce, unsigned int nonl,
			      unsigned char *person,unsigned int perl)
{
  DS seedDS;
  SP800_90PRNG_Data_t *pctx = (SP800_90PRNG_Data_t *)ctx;
  unsigned int l = 0;

  /* As noted elsewhere, this is thread safe, the value set is
     always the same
  */
  if(NULL == pctx->alg.md ) {
    pctx->alg.md = EVP_get_digestbyname(pctx->prng->specific);
    if(NULL == pctx->alg.md ) {
      pctx->error_reason = ERRAT("Could not obtain digest for HMAC");
      pctx->state = SP800_90ERROR;
      return pctx->state;
    }
  }
  if(NULL == pctx->ctx.hmac_ctx) {
    pctx->ctx.hmac_ctx = HMAC_CTX_new();
  }
  DS_Init(&seedDS);

  /* Key = 0x00 00 ... 00 */
  memset(pctx->K,0x00,pctx->prng->OBL);
  /* V = 0x01 01 .. 01 */
  memset(pctx->V,0x01,pctx->prng->OBL);
  DS_Append(&seedDS,einl,ein);
  DS_Append(&seedDS,nonl,nonce);
  DS_Append(&seedDS,perl,person);
  /* HMAC_init() will allow reuse of the md if it's passed as NULL in later calls
     But: we still have to set the md somewhere...
     Note that ICC's HMAC_Init() calls HMAC_Init_ex() under the covers.
  */
  HMAC_Init_ex(pctx->ctx.hmac_ctx,pctx->K,pctx->prng->OBL,pctx->alg.md,NULL);
  /* Now get it back into the correct state ... */
  HMAC_Final(pctx->ctx.hmac_ctx,pctx->T,&l);
  HMAC_CTX_cleanup(pctx->ctx.hmac_ctx);
  /* And erase any leaked data in this case, 
     not necessary but easier than explaining why we shouldn't need to
  */
  memset(pctx->T,0,pctx->prng->OBL);
  SP_HMAC_Update(pctx,&seedDS);
  return pctx->state;
}
/*!
  @brief ReSeed function for HMAC based PRNG's
  @param ctx an initialized PRNG context
  @param ein a pointer to the entropy input buffer. (May be NULL)
  @param einl a pointer to the length of the provided entropy
  @param adata additional user provided data
  @param adatal a pointer to the length of the provided data

*/
static SP800_90STATE SP_HMAC_ReSeed(PRNG_CTX *ctx,
			 unsigned char *ein, unsigned int einl,
			 unsigned char *adata,unsigned int adatal)
{
  DS seedDS;
  SP800_90PRNG_Data_t *pctx = (SP800_90PRNG_Data_t *)ctx;

  DS_Init(&seedDS);
  DS_Append(&seedDS,einl,ein);
  DS_Append(&seedDS,adatal,adata);
  SP_HMAC_Update(pctx,&seedDS);
  return pctx->state;
}

/*!
  @brief Generate function for HMAC based PRNG's
  @param ctx an initialized PRNG context
  @param buffer a pointer to the PRNG data destination
  @param blen Number of bytes of PRNG data to supply
  @param adata additional user provided data
  @param adatal a pointer to the length of the provided data

*/

static SP800_90STATE SP_HMAC_Generate(PRNG_CTX *ctx,
			   unsigned char *buffer,unsigned blen,
			   unsigned char *adata,unsigned adatal)
{
  DS seedDS;

  SP800_90PRNG_Data_t *pctx = (SP800_90PRNG_Data_t *)ctx;
  unsigned int l = 0;
  int j = 0;
  DS_Init(&seedDS);

  if(adatal && (NULL != adata)) {
    DS_Append(&seedDS,adatal,adata);
    SP_HMAC_Update(pctx,&seedDS);
  }
 
  /* Works fine with no prediction resistance */
  while(blen > 0 ) {
    HMAC_Init_ex(pctx->ctx.hmac_ctx,pctx->K,pctx->prng->OBL,pctx->alg.md,NULL);
    HMAC_Update(pctx->ctx.hmac_ctx,pctx->V,pctx->prng->OBL);
    HMAC_Final(pctx->ctx.hmac_ctx,pctx->V,&l);
    HMAC_CTX_cleanup(pctx->ctx.hmac_ctx);
    j = (blen > pctx->prng->OBL) ? pctx->prng->OBL: blen;
    memcpy(buffer,pctx->V,j);
    buffer += j;
    blen -= j;
  }
  DS_Reset(&seedDS);
  SP_HMAC_Update(pctx,&seedDS);

  return pctx->state;
}
/*!
  @brief Cleanup function for HMAC based PRNG's
  @param ctx The PRNG_CTX to cleanup
  All allocated data is released. (Only the EVP_MD_CTX).
*/
static SP800_90STATE SP_HMAC_Cleanup(PRNG_CTX *ctx)
{
  SP800_90PRNG_Data_t *pctx = (SP800_90PRNG_Data_t *)ctx;

  if(NULL != pctx->ctx.hmac_ctx) {
    HMAC_CTX_free(pctx->ctx.hmac_ctx);
    pctx->ctx.hmac_ctx = NULL;
  }
  return pctx->state; 
}

/*!
  Representation of no input data for PRNG self tests
*/
static const StringBuf NONE =
  {0,0,
   {
     0x00
   }
  };
/*!
  \known NIST data INSTANTIATE HMAC_DRBG SHA-512 with NO PREDICTION RESISTANCE
  Generated on Wed Feb 06 13:38:13 2008
*/
static const StringBuf HMAC_SHA512_112IntEin = 
  {0,32,
    {
      0xa9,0xe5,0x47,0x8f,0x08,0x31,0x58,0xe6,
      0xe1,0xe5,0x88,0x00,0xc3,0x60,0xdd,0xec,
      0xf9,0x1b,0xfe,0x2c,0xa7,0xee,0x73,0xa3,
      0x28,0xa1,0x1f,0xbf,0xa5,0xb5,0xfd,0xe9
    }
};
static const StringBuf HMAC_SHA512_112IntNon =
  {0,16, 
   {
     0x40,0x1e,0xab,0x68,0x15,0x79,0xc1,0x48,
     0x93,0x05,0x88,0x74,0xca,0x63,0x03,0x65
   }
  };
static const StringBuf HMAC_SHA512_112IntPer =
  {0,16, 
   {
     0x66,0x4b,0xf9,0xed,0x32,0x40,0xff,0xe3,
     0x4d,0xd2,0x05,0xe4,0xb6,0xbe,0xc7,0xec,
     0x3f,0x22,0x8a,0xca,0xc7,0x6e,0x7a,0xa9,
     0xbc,0x8f,0x42,0xe0,0xcf,0x59,0xeb,0xfc
   }
  };


static const StringBuf HMAC_SHA512_112Result =
  {0,64, /* Truncated from 7168 bits of NIST data */ 
   {
     0x81,0x57,0xE5,0x94,0xB9,0x8F,0x45,0xB2,
     0xB7,0xA8,0x9A,0xEC,0xF7,0xC7,0x30,0x76,
     0x50,0x0E,0x60,0xD9,0x0A,0xA9,0xFA,0xC8,
     0x95,0x9A,0x13,0x49,0x9E,0x10,0x7D,0x05,
     0xAF,0x58,0x57,0x85,0xD8,0x5A,0xAF,0x8E,
     0x36,0xC4,0x40,0x66,0x12,0x94,0x5B,0xED,
     0x3D,0xF6,0xCD,0xC7,0xD2,0xE2,0x82,0xE5,
     0x56,0x2F,0x16,0xC7,0x4B,0xCF,0xBB,0xA6
   }
  };

/*! \known HMAC_SHA-512 PRNG, 128 bit strength 
      NIST data set from test vectors. Note
      NIST didn't provide a 256 bit vector set 
      here.
     */
static const StringBuf HMAC_SHA512_128IntEin =
  {0,32,
   {
     0x7a,0xd0,0x8c,0x07,0xe2,0x6f,0xf3,0xff,
     0xd5,0x00,0x1b,0x94,0x82,0xad,0x71,0x5d,
     0xb3,0xc5,0xff,0x11,0x24,0x42,0xed,0xb2,
     0x25,0x9a,0x3a,0xfd,0x72,0xc9,0xb5,0x10
   }
  };
static const StringBuf HMAC_SHA512_128IntNon =
  {0,16,
   {
     0x04,0xb1,0x90,0x55,0x10,0x69,0xf0,0x4e,
     0xe6,0x63,0x2b,0x76,0xda,0x26,0xa3,0xd0 
   }
  };
static const StringBuf HMAC_SHA512_128GenEin =
  {0,32,
   {
     0x3b,0xe4,0xbf,0xaa,0x70,0xa9,0x2f,0x0a,
     0xab,0x37,0xc2,0xe6,0xab,0x89,0xf6,0x25,
     0xc9,0xbc,0xe6,0xcd,0x54,0x9b,0xc9,0x32,
     0x29,0x6c,0xad,0x60,0x95,0xfc,0x73,0xc5
   }
  };
static const StringBuf HMAC_SHA512_128Result =
  {0,64,
   {
     0x4D,0xFA,0x30,0x06,0x5A,0xB2,0xC8,0x5C,
     0x1D,0x1E,0x62,0xE0,0x51,0x50,0x5A,0x52,
     0x59,0x9D,0xEF,0x92,0xB0,0x4D,0x97,0xB3,
     0xE4,0xE7,0x09,0x14,0x79,0xAB,0x78,0x7F,
     0xF2,0xD6,0x98,0xD8,0x4C,0x72,0x88,0xAE,
     0x70,0x9E,0xC0,0x5D,0xC3,0x8C,0xC5,0x25,
     0x85,0x4C,0x02,0x97,0x2C,0xAF,0x20,0xC3,
     0x5D,0xAB,0xE3,0x0D,0x4D,0x78,0xC4,0x9A
   }
  };

/*! \known HMAC SHA512 sec 192 NIST data
  INSTANTIATE HMAC_DRBG SHA-512 with NO PREDICTION RESISTANCE
*/
static const StringBuf HMAC_SHA512_192IntEin = 
  {0,32,
   {
     0xa9,0xe5,0x47,0x8f,0x08,0x31,0x58,0xe6,
     0xe1,0xe5,0x88,0x00,0xc3,0x60,0xdd,0xec,
     0xf9,0x1b,0xfe,0x2c,0xa7,0xee,0x73,0xa3,
     0x28,0xa1,0x1f,0xbf,0xa5,0xb5,0xfd,0xe9
   }
  };
static const StringBuf HMAC_SHA512_192IntNon = 
  {0,16,
     {
       0x40,0x1e,0xab,0x68,0x15,0x79,0xc1,0x48,
       0x93,0x05,0x88,0x74,0xca,0x63,0x03,0x65
     }
    };
static const StringBuf HMAC_SHA512_192IntPer =
  {0,32,
     {
       0x66,0x4b,0xf9,0xed,0x32,0x40,0xff,0xe3,
       0x4d,0xd2,0x05,0xe4,0xb6,0xbe,0xc7,0xec,
       0x3f,0x22,0x8a,0xca,0xc7,0x6e,0x7a,0xa9,
       0xbc,0x8f,0x42,0xe0,0xcf,0x59,0xeb,0xfc
     }
    };
static const StringBuf HMAC_SHA512_192Result =
    {0,64,
     { 
       0xa9,0xb6,0x7f,0x7d,0xf6,0xb9,0x2e,0xc5,
       0x41,0x91,0xe8,0xb2,0xba,0x22,0xb7,0x4b,
       0xf9,0xa2,0x27,0x6e,0xd6,0xc6,0x6c,0xca,
       0x3b,0x23,0x09,0xba,0xbb,0x7c,0xbb,0x66,
       0x4e,0x3a,0xf7,0x71,0xce,0xa5,0x14,0xaf,
       0x88,0x63,0xbf,0x33,0x17,0xbe,0x8f,0x5e,
       0x52,0xe9,0xc4,0xb4,0x83,0x58,0x68,0xaa,
       0x88,0xf7,0xc9,0xf2,0x71,0x51,0x40,0x52
     }
    };

/*! \known HMAC SHA512 NIST data
  INSTANTIATE HMAC_DRBG SHA-512 with PREDICTION RESISTANCE ENABLED
*/
static const StringBuf HMAC_SHA512_256IntEin = 
  {0,32,
     {
       0x63,0x3c,0xa3,0x2c,0x40,0x50,0x3e,0x66,
       0x8f,0xb8,0x3d,0xe2,0xa7,0x93,0x69,0xc2,
       0xcd,0x04,0xd9,0x0e,0x4e,0x83,0x36,0x9e,
       0xdc,0x62,0x35,0x46,0x2c,0xa1,0x51,0x42
     }
    };
StringBuf HMAC_SHA512_256IntNon = 
  {0,16,
     {
       0x17,0x1a,0xd9,0x62,0xc9,0xe2,0xc8,0xdf,
       0xe2,0xd8,0xc4,0x31,0x50,0x7f,0x5e,0xcd
     }
    };

static const StringBuf HMAC_SHA512_256GenEin =
  {0,32,
     {
       0x6c,0xdc,0x78,0x93,0x95,0xda,0xa6,0x18,
       0x30,0x07,0x37,0xe4,0x02,0xb2,0xdf,0x77,
       0x32,0xb4,0x7c,0x95,0x22,0x7c,0x0e,0xfa,
       0x8e,0x5a,0xf5,0x40,0xe9,0x0e,0x6c,0x0f
     }
    };
static const StringBuf HMAC_SHA512_256Result =

    {0,64,
     { 
       0xe1,0x2a,0xb2,0x66,0xa7,0x14,0xec,0xa8,
       0xa4,0x01,0x6d,0x45,0xa1,0xbe,0x71,0x52,
       0x7c,0xb5,0x6f,0x2f,0x01,0x54,0x4d,0xf0,
       0x74,0x7e,0x82,0x4d,0xab,0x34,0x91,0xd1,
       0x13,0x2c,0xaa,0x9b,0x4d,0x14,0x29,0xb6,
       0x33,0xa2,0x52,0x66,0x28,0xc9,0x9d,0x0a,
       0x20,0xa8,0x90,0x31,0x5d,0xe8,0x18,0xe0,
       0x20,0x17,0x53,0x16,0xe5,0xbc,0x95,0x48
     }
    };


/*!
  Control structures for each PRNG type.
  Note that NIST specifies that there has to be a self test 
  at "some specified interval", so now and then i.e. at each 
  (SELF_TEST_AT) you may be slow getting a new PRNG context.
  When we self test, we'll do so for each strength, the overhead
  isn't great compared with the complexity of tracking the
  individual PRNG allowed strengths/instantiations
*/

/*!
  \FIPS Data structure defining the capabilities and limits
  of the HMAC_SHA512 PRNG
*/

SP800_90PRNG_t HMACsha512PRNG = {
  SP800_HMAC_SHA512, /*!< type */
  888/8,        /*!< Retained seedlen */ 
  (1<<27),      /*!< Max nonce */
  (1<<27),      /*!< Max personalization data */ 
  (1<<27),      /*!< Max AAD */
  (1<<11),      /*!< Max bytes/request */
  0x00FFFFFFL,  /*!< Max calls between reseeds (< standard specifies) */
  512/8,        /*!< Block size */
  (1<<27),      /*!< Max allowed entropy input */   
  {112,
   128,
   192,
   256
  },            /*!< Supported security strengths */
  "SHA512",
  "HMAC-SHA512",     /*!< Algorithm "name" */
  1,              /*!< Has a derivation function */
  Inst,
  Res,
  Gen,
  Cln,
  SP_HMAC_Instantiate, /*!< Instantiate method */
  SP_HMAC_ReSeed,      /*!< ReSeed method */
  SP_HMAC_Generate,    /*!< Generate method */
  SP_HMAC_Cleanup,     /*!< Cleanup method */
  SP800_IS_FIPS,  /*!< Are we a FIPS approved mode (do we pass the NIST tests) */
  SELF_TEST_AT,    /*!< health check interval */
  0,               /*!< Health check counter  */
  { 
    {
      &HMAC_SHA512_112IntEin,
      &HMAC_SHA512_112IntNon,
      &HMAC_SHA512_112IntPer,
      &NONE,
      &NONE,
      &HMAC_SHA512_112Result
    },
    {
      &HMAC_SHA512_128IntEin,
      &HMAC_SHA512_128IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA512_128GenEin,
      &HMAC_SHA512_128Result
    },
    {
      &HMAC_SHA512_192IntEin,
      &HMAC_SHA512_192IntNon,
      &HMAC_SHA512_192IntPer,
      &NONE,
      &NONE,
      &HMAC_SHA512_192Result
    },
    {
      &HMAC_SHA512_256IntEin,
      &HMAC_SHA512_256IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA512_256GenEin,
      &HMAC_SHA512_256Result
    },
  },
};

/*! \known HMAC_SHA-384 PRNG known answer test data at 112 bit strength

*/
static const StringBuf HMAC_SHA384_112IntEin = 
  {0,24,
   {0xd9,0x56,0xca,0xa2,0x40,0x39,0xe7,0x6f,
    0x58,0x61,0x6e,0x09,0x69,0xaf,0xa2,0xd7,
    0xb7,0x08,0x74,0x01,0xee,0x2d,0x87,0x77
   }
  };
static const StringBuf HMAC_SHA384_112IntNon = 
  {0,16,
   {0x32,0xa2,0xef,0x15,0x98,0x3e,0x3c,0x1f,
    0x66,0xe6,0x03,0x2a,0x00,0x01,0x02,0x03
   }
  };
static const StringBuf HMAC_SHA384_112GenEin =
  {0,24,
   {
     0x7b,0xa5,0xa5,0x22,0x58,0x0b,0x41,0xe1,
     0xa4,0xf5,0x40,0xf9,0xfe,0x3d,0xaa,0xf9,
     0x5d,0xf7,0x72,0x74,0x0a,0x19,0x96,0x51
   }
  };
static const StringBuf HMAC_SHA384_112Result =
  {0,48,
   {
     0x8B,0x24,0xE8,0xDF,0x48,0xF2,0x07,0x24,
     0xE7,0xBA,0xF1,0x92,0xE8,0x98,0x5C,0x2F,
     0x7D,0x67,0x63,0x08,0xF4,0x7F,0x52,0x59,
     0xCA,0xB6,0xC5,0xBE,0x93,0xCF,0xA2,0xA6,
     0xD4,0x5E,0x8F,0xAB,0xE3,0xE0,0x8F,0xCA,
     0x4B,0x69,0x3E,0xE0,0xAC,0x38,0xBE,0x91
   }
  };
/*! \known HMAC_SHA-384 PRNG, 128 bit strength 

*/
static const StringBuf HMAC_SHA384_128IntEin =
  {0,32,
   {
     0x5d,0xae,0xbf,0x2d,0x31,0x79,0x35,0xa3,
     0x5c,0xba,0xfe,0xba,0x69,0xfd,0xe5,0x67,
     0x2a,0xb8,0x14,0xd7,0xb7,0xf1,0x2c,0xb9,
     0xa4,0x32,0xa6,0xcb,0x84,0xb1,0x6b,0xa4
    }
  };
static const StringBuf HMAC_SHA384_128IntNon =
  {0,16,
   {
     0x85,0x84,0xde,0x95,0x9a,0x4b,0xc1,0xfd,
     0x6d,0x56,0x0d,0x6d,0x30,0xa5,0xbc,0x21
   }
  };
static const StringBuf HMAC_SHA384_128GenEin =
  {0,32,
   {
     0x7b,0xc1,0x29,0x2c,0x59,0x60,0xd8,0x10,
     0x8a,0x03,0xd1,0xc3,0x29,0x9a,0xa9,0xe3,
     0x67,0x11,0xf6,0x0c,0x74,0xa7,0xdf,0x5a,
     0xae,0x8d,0xe3,0x1a,0x0a,0xc2,0xe7,0xd1
   }
  };
static const StringBuf HMAC_SHA384_128Result =
  {0,48,
   {
     0x2A,0xF7,0xEA,0xAF,0xEF,0x2F,0xBC,0xCF,
     0xBE,0x33,0x0F,0xEC,0x89,0x87,0x90,0xCD,
     0xD0,0x07,0x9A,0xFD,0xE7,0xBB,0xFF,0xF1,
     0xB1,0x84,0xD6,0x50,0x49,0xDD,0x40,0xCE,
     0xD0,0xE5,0xF6,0xF4,0x71,0x3F,0xE6,0x27,
     0x66,0x5C,0x15,0xC9,0x32,0x1E,0x70,0x45,
   }
  };

/* \known HMAC_SHA-384 PRNG test vector, 192 bit security strength 
   INSTANTIATE HMAC_DRBG SHA-384 with PREDICTION RESISTANCE ENABLED
*/

static const StringBuf HMAC_SHA384_192IntEin =
  {0,32,
   {
     0xce,0x04,0x5b,0x40,0x1f,0xfa,0xe0,0xe2,
     0xba,0x24,0x56,0xdd,0xe2,0x91,0x73,0x99,
     0x5a,0x7b,0x8a,0xa2,0x2f,0x02,0xf5,0x7d,
     0xc2,0x2a,0xc3,0xcc,0x1a,0x19,0xa1,0xa5
   }
  };
static const StringBuf HMAC_SHA384_192IntNon = 
  {0,16,
   {
     0x45,0x25,0xa9,0xec,0x4f,0xc7,0x19,0x33,
     0x0c,0xe5,0x77,0x95,0x2b,0x13,0x4d,0x88
   }
  };
static const StringBuf HMAC_SHA384_192GenEin =
  {0,32,
     {
       0xc6,0x46,0x6e,0xb9,0x52,0x49,0x8e,0x63,
       0x64,0x3f,0xc4,0x8e,0x90,0x88,0xc1,0x65,
       0xc1,0x65,0x93,0xf2,0x9a,0x85,0x25,0x4d,
       0x0d,0xd1,0xfb,0x04,0x3b,0x7b,0x28,0xcc
     }
    };


static const StringBuf HMAC_SHA384_192Result =
    {0,48,
     { 
       0xd0,0xac,0x8b,0xa5,0x3a,0x48,0xbd,0x24,
       0x78,0xc8,0x4a,0x25,0x96,0x07,0x87,0x6c,
       0x83,0x3a,0x16,0xac,0xe9,0x91,0x04,0xad,
       0xf2,0x17,0x10,0x59,0x81,0xc7,0x0f,0xbb,
       0x4d,0x41,0xbd,0x80,0x1a,0xd2,0xdd,0x3d,
       0x37,0x6e,0xbd,0x03,0x44,0xe0,0x04,0x2f,
     }
    };


/* \known HMAC SHA-384 256 bits 
   INSTANTIATE HMAC_DRBG SHA-384 with NO PREDICTION RESISTANCE
*/
static const StringBuf HMAC_SHA384_256IntEin = 
  {0,32,
     {
       0x45,0x14,0x98,0x32,0x77,0x16,0xdf,0x34,
       0x2e,0xce,0xd8,0x8f,0xb2,0xf3,0x54,0x4e,
       0x3b,0x98,0xb3,0x4a,0xba,0xe7,0x4d,0x0d,
       0xe7,0x1e,0x1c,0xe7,0x8c,0xca,0xad,0x50
     }
    };
static const StringBuf HMAC_SHA384_256IntNon = 
  {0,16,
     {
       0xaf,0xfb,0x81,0xef,0xfc,0x70,0x78,0xfd,
       0x7b,0x4c,0xd1,0x6a,0x05,0x6b,0xa6,0x7c
     }
    };

static const StringBuf HMAC_SHA384_256IntPer =
  {0,32,
     {
       0xd7,0xe3,0x27,0xc1,0x23,0x19,0x9e,0x0f,
       0x13,0x14,0x80,0x1d,0xcd,0x56,0x70,0xc3,
       0x04,0x8a,0x08,0xe0,0x12,0xcc,0x0c,0x40,
       0x58,0x36,0xef,0xcf,0xd9,0xad,0x8b,0xfe
     }
    };

static const StringBuf HMAC_SHA384_256Result =
    {0,64,
     { 
       0x51,0xf3,0xdc,0x61,0xb0,0xa2,0xf3,0x37,
       0xc3,0xe2,0x80,0x00,0x16,0xe7,0xba,0x48,
       0xd0,0xfb,0x7e,0xc7,0x1f,0x28,0xfc,0xc4,
       0x99,0x95,0xef,0x4c,0xe7,0x0e,0xb9,0x0d,
       0x98,0x59,0x41,0x84,0x25,0xc3,0xa0,0xf2,
       0x0a,0x55,0x22,0x76,0xf7,0xe0,0x1a,0xa4,
       0x9b,0x87,0x2f,0x35,0xf2,0xd5,0x65,0xd9,
       0xdb,0x72,0x4e,0xd4,0xf4,0x79,0x8e,0xbb,
     }
    };

/*!
  \FIPS Data structure defining the capabilities and limits
  of the HMAC_SHA384 PRNG
*/


SP800_90PRNG_t HMACsha384PRNG = {
  SP800_HMAC_SHA384,
  888/8,
  (1<<27),      /* Max nonce */
  (1<<27),      /* max personalization data */ 
  (1<<27),      /* max AAD */
  (1<<11),      /* max bytes/request */
  0x00FFFFFFL,  /* Max calls between reseeds (< standard specifies) */
  384/8,        /* Block size */
  (1<<27),      /* Max allowed entropy input */ 
  {112,
   128,
   192,
   256
  },
  "SHA384",
  "HMAC-SHA384",
  1,              /*!< Has a derivation function */
  Inst,
  Res,
  Gen,
  Cln,
  SP_HMAC_Instantiate,
  SP_HMAC_ReSeed,
  SP_HMAC_Generate,
  SP_HMAC_Cleanup,
  SP800_IS_FIPS,
  SELF_TEST_AT,
  0,
  {
    {
      &HMAC_SHA384_112IntEin,
      &HMAC_SHA384_112IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA384_112GenEin,
      &HMAC_SHA384_112Result
    },
    {
      &HMAC_SHA384_128IntEin,
      &HMAC_SHA384_128IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA384_128GenEin,
      &HMAC_SHA384_128Result
    },
    {
      &HMAC_SHA384_192IntEin,
      &HMAC_SHA384_192IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA384_192GenEin,
      &HMAC_SHA384_192Result
    },
    {
      &HMAC_SHA384_256IntEin,
      &HMAC_SHA384_256IntNon,
      &HMAC_SHA384_256IntPer,
      &NONE,
      &NONE,
      &HMAC_SHA384_256Result
 
    },
  }
};
 /*! \known HMAC_SHA256 PRNG known answer test data 
   #  Generated on Wed Feb 06 13:38:13 2008
   INSTANTIATE Hash_DRBG SHA-256 with PREDICTION RESISTANCE ENABLED
*/

static const StringBuf HMAC_SHA256_112IntEin =
  {0,24,
   {0xd9,0x56,0xca,0xa2,0x40,0x39,0xe7,0x6f,
    0x58,0x61,0x6e,0x09,0x69,0xaf,0xa2,0xd7,
    0xb7,0x08,0x74,0x01,0xee,0x2d,0x87,0x77
   }
  };
static const StringBuf HMAC_SHA256_112IntNon =
  {0,12, 
   {0x32,0xa2,0xef,0x15,0x98,0x3e,0x3c,0x1f,
    0x66,0xe6,0x03,0x2a
   }
  };
static const StringBuf HMAC_SHA256_112GenEin = 
  {0,24,
   {
     0x7b,0xa5,0xa5,0x22,0x58,0x0b,0x41,0xe1,
     0xa4,0xf5,0x40,0xf9,0xfe,0x3d,0xaa,0xf9,
     0x5d,0xf7,0x72,0x74,0x0a,0x19,0x96,0x51
   }
  };
static const StringBuf HMAC_SHA256_112Result = 
  {0,32,
   {
     0xC1,0x3C,0x2B,0x4E,0x0B,0xF4,0xFE,0x6A,
     0xCD,0xDA,0xAA,0x50,0xF5,0x50,0x3C,0x60,
     0x61,0x64,0xB0,0xCC,0x13,0xE3,0x0B,0xFF,
     0x51,0xB1,0x8C,0xA0,0x44,0x6E,0xB6,0x70
   }
  };
static const StringBuf HMAC_SHA256_128IntEin =
  {0,32,
   {
     0x50,0x21,0xb7,0x21,0xef,0x6a,0xa7,0xab,
     0xaa,0xba,0x55,0x43,0xd5,0x31,0xde,0x46,
     0xa1,0xa1,0x20,0x23,0x38,0xe4,0xf8,0x4b,
     0x1a,0x5e,0xbf,0x5c,0xb9,0xcf,0x06,0x8b
   }
  };
static const StringBuf HMAC_SHA256_128IntNon =
  {0,16,
   {
     0xfc,0x6e,0xea,0xe2,0x1b,0x3f,0x8d,0x8f,
     0xe3,0x82,0x26,0xfe,0x65,0xc3,0x57,0x08
   }
  };
static const StringBuf HMAC_SHA256_128GenEin =
  {0,32,
   {
     0x6a,0xe6,0x5a,0xc1,0xe3,0x74,0x03,0x8e,
     0x40,0x35,0x1c,0xd3,0x5d,0x2f,0xdd,0xf7,
     0xd4,0x2a,0xe8,0xe9,0x63,0x8c,0x57,0x1b,
     0xa0,0x73,0x04,0xc0,0xdf,0x13,0x19,0x43
   }
  };
static const StringBuf HMAC_SHA256_128Result = 
  {0,32,
     {
       0xD7,0x34,0xCD,0xF1,0x7F,0x95,0x8A,0x62,
       0x4D,0x65,0x4C,0x55,0x5F,0xF2,0x43,0xD0,
       0xCE,0xEA,0xD8,0x31,0xBF,0xA1,0x21,0x5D,
       0xA9,0xA8,0x5C,0x7F,0x97,0xBD,0x2E,0x32,
     }
    };
/*! \known HMAC SHA-256 192 bit strength
  INSTANTIATE HMAC_DRBG SHA-256 with NO PREDICTION RESISTANCE
*/
static const StringBuf HMAC_SHA256_192IntEin =
  {0,32,
   {
     0x03,0x46,0xd4,0xe8,0x30,0x32,0x2a,0x8d,
     0x79,0x21,0x98,0x94,0x0b,0x29,0x26,0xf5,
     0x26,0x5b,0x89,0x18,0xe0,0x7e,0x8e,0xb4,
     0x37,0x0f,0xc8,0xe8,0x5c,0x78,0x77,0x9a,
   }
  };
static const StringBuf HMAC_SHA256_192IntNon = 
  {0,16,
   {
     0xc0,0x46,0xe7,0x36,0x87,0x3c,0x27,0x94,
     0x3a,0xb3,0x67,0xaa,0xe4,0x8d,0x82,0x40,
   }
  };
static const StringBuf HMAC_SHA256_192IntPer =
  {0,32,
     {
       0xba,0x31,0xcf,0xbe,0xcf,0xab,0x74,0xc9,
       0x91,0x92,0xda,0x0f,0x6d,0x80,0x71,0xfb,
       0x63,0x82,0xdc,0x3a,0x09,0xcc,0x03,0x11,
       0xc3,0xa2,0x74,0xdf,0x42,0x85,0x01,0xf0
     }
    };
/* Truncated from the 3584 bits of NIST request */
static const StringBuf HMAC_SHA256_192Result =
  {0,64,
     { 
       0xe2,0xff,0xdc,0xc8,0x12,0xea,0xe4,0xf6,
       0x31,0xae,0x5a,0x07,0x61,0xcc,0xa2,0x3f,
       0xcb,0xcd,0x55,0xab,0xea,0x1f,0x24,0x63,
       0x1e,0xbb,0xb8,0x6c,0x42,0x3f,0x45,0x18,
       0x7f,0x9d,0x97,0x6e,0x77,0xff,0x31,0xca,
       0xa3,0x75,0x2c,0xfa,0xf3,0xd8,0x7a,0x6a,
       0xba,0x1c,0xf2,0xd8,0x5c,0x5c,0xdd,0x22,
       0xf7,0xf9,0xc3,0x29,0x86,0x54,0xf6,0x64,

     }
    };
/*! \known 
  INSTANTIATE HMAC_DRBG SHA-256 with PREDICTION RESISTANCE ENABLED
*/
static const StringBuf HMAC_SHA256_256IntEin = 
  {0,32,
     {
       0x56,0xe0,0xf7,0x13,0x40,0xa1,0x56,0xf0,
       0xd3,0xc9,0x79,0xea,0x22,0x8e,0x1e,0xd0,
       0x36,0x27,0x04,0x74,0x6f,0x5a,0x63,0xd3,
       0x1f,0x45,0xac,0x81,0x62,0x6f,0x81,0x59,
     }
    };
static const StringBuf HMAC_SHA256_256IntNon = 
  {0,16,
     {
       0xbc,0xba,0xa2,0x7b,0x84,0xe8,0x66,0x08,
       0x42,0x19,0x45,0xa0,0xf6,0x8a,0x51,0x4c,
     }
    };

static const StringBuf HMAC_SHA256_256GenEin =
  {0,32,
     {
       0xa3,0x89,0xab,0xa0,0xd0,0x56,0xa4,0xf8,
       0x1d,0x4b,0x63,0xc8,0xe7,0x17,0xbd,0x19,
       0x67,0x24,0x9f,0x41,0xbb,0x8b,0xbc,0xff,
       0x32,0x58,0x74,0xd8,0xdb,0x01,0x06,0xb2,
     }
    };
/* NIST Known answer */
static const StringBuf HMAC_SHA256_256Result =
  {0,32,
     { 
       0xb2,0xf4,0x29,0x99,0x3c,0x61,0x48,0xb8,
       0x74,0xfc,0xb0,0x1b,0x2a,0x31,0x58,0x9b,
       0x0b,0xae,0x5a,0xc5,0x16,0x02,0xb5,0x94,
       0x64,0xab,0xc9,0xb3,0x35,0x13,0xac,0x20,
     }
    };

/*!
  \FIPS Data structure defining the capabilities and limits
  of the HMAC_SHA256 PRNG
*/

SP800_90PRNG_t HMACsha256PRNG = {
  SP800_HMAC_SHA256,
  440/8,
  (1<<27),      /* Max nonce */
  (1<<27),      /* max personalization data */ 
  (1<<27),      /* max AAD */
  (1<<11),      /* max bytes/request */
  0x00FFFFFFL,  /* Max calls between reseeds (< standard specifies) */
  256/8,        /* Block size */
  (1<<27),      /* Max allowed entropy input */ 
  {112,
   128,
   192,
   256
  },
  "SHA256",
  "HMAC-SHA256",
  1,              /*!< Has a derivation function */
  Inst,
  Res,
  Gen,
  Cln,
  SP_HMAC_Instantiate,
  SP_HMAC_ReSeed,
  SP_HMAC_Generate,
  SP_HMAC_Cleanup,
  SP800_IS_FIPS,
  SELF_TEST_AT,
  0,
  {
    {
      &HMAC_SHA256_112IntEin,
      &HMAC_SHA256_112IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA256_112GenEin,
      &HMAC_SHA256_112Result
    },
    {
      &HMAC_SHA256_128IntEin,
      &HMAC_SHA256_128IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA256_128GenEin,
      &HMAC_SHA256_128Result
    },
    {
      &HMAC_SHA256_192IntEin,
      &HMAC_SHA256_192IntNon,
      &HMAC_SHA256_192IntPer,
      &NONE,
      &NONE,
      &HMAC_SHA256_192Result
    },
    {
      &HMAC_SHA256_256IntEin,
      &HMAC_SHA256_256IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA256_256GenEin,
      &HMAC_SHA256_256Result
    },

  }
};

/*! \known HMAC_SHA224 PRNG known answer test data,
  INSTANTIATE Hash_DRBG SHA-224 with PREDICTION RESISTANCE ENABLED
#  Generated on Wed Feb 06 13:38:13 2008
*/
static const StringBuf HMAC_SHA224_112IntEin =
  {0,24,
   {
     0xdc,0x41,0x8d,0xca,0x8c,0xa9,0xbb,0xd1,
     0xed,0xd3,0x1c,0x4c,0xc2,0xf7,0x57,0xa8,
     0x22,0xdf,0xe3,0xb8,0x01,0x5e,0x36,0x4f,
   }
  };
static const StringBuf HMAC_SHA224_112IntNon =
  {0,12,
   {
     0x6f,0xe5,0x3a,0xc4,0xa7,0xfb,0x01,0xc4,
     0xc3,0x8c,0xb3,0x1a,
   }
  };
static const StringBuf HMAC_SHA224_112GenEin =
  {0,24,
   {
     0xe1,0x09,0xf3,0x9c,0x9a,0xc3,0x78,0x44,
     0xf8,0x4f,0x26,0x64,0xe5,0x18,0xd4,0xef,
     0x8a,0xcc,0xed,0xa7,0xcd,0x84,0x0e,0xe7,
   }
  };
/* NIST result */
static const StringBuf HMAC_SHA224_112Result =
  {0,28,
   {
     0x06,0x7b,0xcb,0xc7,0x13,0x95,0x2e,0x98,
     0x95,0x25,0x68,0x32,0xf6,0x46,0xd4,0x00,
     0x5e,0xe6,0xea,0x28,0x4f,0xc2,0xe8,0xb4,
     0xAD,0x44,0xD0,0x4C
   }
  };



static const StringBuf HMAC_SHA224_128IntEin =
  {0,32,
   {
     0x50,0x21,0xb7,0x21,0xef,0x6a,0xa7,0xab,
     0xaa,0xba,0x55,0x43,0xd5,0x31,0xde,0x46,
     0xa1,0xa1,0x20,0x23,0x38,0xe4,0xf8,0x4b,
     0x1a,0x5e,0xbf,0x5c,0xb9,0xcf,0x06,0x8b
   }
  };
static const StringBuf HMAC_SHA224_128IntNon =
  {0,16,
   {
     0xfc,0x6e,0xea,0xe2,0x1b,0x3f,0x8d,0x8f,
     0xe3,0x82,0x26,0xfe,0x65,0xc3,0x57,0x08
   }
  };
static const StringBuf HMAC_SHA224_128GenEin =
  {0,32,
   {
     0x6a,0xe6,0x5a,0xc1,0xe3,0x74,0x03,0x8e,
     0x40,0x35,0x1c,0xd3,0x5d,0x2f,0xdd,0xf7,
     0xd4,0x2a,0xe8,0xe9,0x63,0x8c,0x57,0x1b,
     0xa0,0x73,0x04,0xc0,0xdf,0x13,0x19,0x43
   }
  };
static const StringBuf HMAC_SHA224_128Result = 
  {0,32,
     {
       0x03,0x03,0x6E,0x6B,0x77,0x8C,0x6D,0x7C,
       0x9E,0x24,0x91,0x64,0xCD,0x73,0xE2,0x40,
       0x55,0xB4,0xC2,0x63,0x1A,0x7E,0x87,0x0C,
       0x93,0x3C,0xCD,0xE6,0x4F,0x45,0xFF,0x90,
     }
    };
/*! \known HMAC SHA224 strngth 192
  INSTANTIATE HMAC_DRBG SHA-224 with NO PREDICTION RESISTANCE
*/
static const StringBuf HMAC_SHA224_192IntEin =
  {0,24,
   {
    0x80,0x9e,0x19,0x94,0x28,0x5d,0xd6,0xdd,
    0xdb,0xba,0x0b,0xa9,0xb8,0xd0,0x6b,0x0a,
    0x9e,0x24,0x83,0x77,0xf6,0x65,0x2b,0xa3 
   }
  };
static const StringBuf HMAC_SHA224_192IntNon = 
  {0,12,
   {
     0x0f,0xb9,0x09,0xbc,0x76,0xd2,0x3b,0x1f,
     0x61,0x79,0x8e,0xce
   }
  };
static const StringBuf HMAC_SHA224_192IntPer =
  {0,24,
     {
       0x38,0x9e,0xea,0x83,0x81,0x3a,0x1d,0xf3,
       0x46,0x6b,0x6e,0xea,0x75,0x45,0x7b,0x17,
       0xa4,0xa8,0x9e,0x43,0x0a,0xe6,0x0d,0x95,
     }
    };
/* NIST result, truncated from 3136 bits */
static const StringBuf HMAC_SHA224_192Result =
  {0,64,
     { 
       0xb4,0x47,0x9b,0x7c,0xed,0x09,0xe5,0x49,
       0x65,0x7c,0x1b,0xc0,0xfc,0x5a,0x65,0x3a,
       0x4c,0x08,0xbb,0xd8,0xf8,0x10,0xa9,0x3e,
       0xe1,0x9d,0x6d,0x32,0x11,0x9a,0x2a,0x5c,
       0x08,0xab,0x12,0xe4,0x0d,0x2a,0x8a,0xe7,
       0x7b,0x03,0x03,0xf1,0xe0,0xf4,0xcf,0x6d,
       0x1b,0x99,0x61,0x42,0xa1,0x4a,0x5a,0xe0,
       0x50,0xc9,0x8b,0x03,0x68,0xbd,0xd3,0x54,
     }
    };


/*!
  \FIPS Data structure defining the capabilities and limits
  of the HMAC_SHA224 PRNG
*/

SP800_90PRNG_t HMACsha224PRNG = {
  SP800_HMAC_SHA224,
  440/8,
  (1<<27),      /* Max nonce */
  (1<<27),      /* max personalization data */ 
  (1<<27),      /* max AAD */
  (1<<11),      /* max bytes/request */
  0x00FFFFFFL,  /* Max calls between reseeds (< standard specifies) */
  224/8,        /* Block size */
  (1<<27),      /* Max allowed entropy input */
  {112,
   128,
   192,
   0
  },
  "SHA224",
  "HMAC-SHA224",
  1,              /*!< Has a derivation function */
  Inst,
  Res,
  Gen,
  Cln,
  SP_HMAC_Instantiate,
  SP_HMAC_ReSeed,
  SP_HMAC_Generate,
  SP_HMAC_Cleanup,
  SP800_IS_FIPS,
  SELF_TEST_AT,
  0,
  {
    {
      &HMAC_SHA224_112IntEin,
      &HMAC_SHA224_112IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA224_112GenEin,
      &HMAC_SHA224_112Result
    },
   {
      &HMAC_SHA224_128IntEin,
      &HMAC_SHA224_128IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA224_128GenEin,
      &HMAC_SHA224_128Result
    },
   {
      &HMAC_SHA224_192IntEin,
      &HMAC_SHA224_192IntNon,
      &HMAC_SHA224_192IntPer,
      &NONE,
      &NONE,
      &HMAC_SHA224_192Result
    },
   {
     &NONE,
     &NONE,
     &NONE,
     &NONE,
     &NONE,
     &NONE
    }
  }
 };


/*! \known HMAC_SHA1 PRNG known answer test data
  INSTANTIATE HMAC_DRBG SHA-1 with PREDICTION RESISTANCE ENABLED
  Generated on Wed Feb 06 13:38:13 2008
*/
static const StringBuf HMAC_SHA1_112IntEin =
  {0,16,
   {
     0x4c,0x80,0xc7,0xe9,0x28,0x7c,0x8d,0x25,
     0xe3,0xb9,0x65,0xf9,0x1a,0x3c,0x72,0xbe
   }
  };
static const StringBuf HMAC_SHA1_112IntNon =
  {0,8,
   {
     0xcd,0x87,0x80,0x87,0xda,0xe4,0x1d,0xd4,
   }
  };
static const StringBuf HMAC_SHA1_112GenEin =
  {0,16,
   {
     0xc2,0x3b,0x19,0x24,0x9b,0x5b,0xc8,0x33,
     0xcc,0x4e,0xa8,0xb5,0x56,0x4e,0x75,0x25
   }
  };
static const StringBuf HMAC_SHA1_112Result =
  {0,20,
   {
     0x8f,0x0a,0xd4,0x64,0x6e,0x47,0xac,0xf1,
     0xfc,0x1d,0x74,0x07,0x0e,0x82,0x2a,0xf4,
     0x85,0xdf,0x33,0xc0
   }
  };

/* \known HMAC SHA1 128 bit strength   
   INSTANTIATE HMAC_DRBG SHA-1 with NO PREDICTION RESISTANCE
*/

static const StringBuf HMAC_SHA1_128IntEin =
  {0,16,
   {
     0x4d,0xb5,0x71,0xea,0xe3,0xce,0x2d,0xf2,
     0xa6,0x28,0x29,0x1c,0x66,0x62,0x57,0x7d
   }
  };
static const StringBuf HMAC_SHA1_128IntNon =
  {0,8,
   {
     0x05,0x9b,0x09,0xc6,0xaf,0x08,0xc3,0xfe
   }
  };

static const StringBuf HMAC_SHA1_128IntPer =
  {0,16,
   {
     0x98,0xaa,0x2b,0x15,0x25,0x6d,0x21,0x1b,
     0xa9,0x7f,0xa9,0x9b,0xb0,0xd7,0x83,0xa3
   }
  };
/* Truncated from the 2240 bits of NIST data */
static const StringBuf HMAC_SHA1_128Result = 
  {0,64,
     {
       0xe6,0x73,0xc4,0xc1,0xf7,0x70,0x1a,0x77,
       0x5b,0x84,0x56,0x4a,0x45,0x1c,0xb4,0x86,
       0xfa,0x07,0xc3,0xa1,0xc6,0x06,0x29,0x7c,
       0x82,0xb8,0xdb,0xeb,0x3b,0x2d,0x8a,0xa1,
       0x30,0x94,0xc0,0x12,0x2b,0xae,0x71,0x29,
       0xfe,0xe7,0x74,0x21,0x5c,0xcc,0xd6,0xcc,
       0x02,0x03,0x58,0xcd,0x93,0x7a,0x12,0x53,
       0x13,0x54,0x00,0xd3,0xaf,0xa2,0x01,0xbc,

     }
    };


/*!
  \FIPS Data structure defining the capabilities and limits
  of the HMAC_SHA1 PRNG
*/
SP800_90PRNG_t HMACsha1PRNG = {
  SP800_HMAC_SHA1,
  440/8,
  (1<<27),      /* Max nonce */
  (1<<27),      /* max personalization data */ 
  (1<<27),      /* max AAD */
  (1<<11),      /* max bytes/request */
  0x00FFFFFFL,  /* Max calls between reseeds (< standard specifies) */
  160/8,        /* Block size */
  (1<<27),      /* Max allowed entropy input */
  {112,
   128,
   0,
   0
  },
  "SHA1",
  "HMAC-SHA1",
  1,              /*!< Has a derivation function */
  Inst,
  Res,
  Gen,
  Cln,
  SP_HMAC_Instantiate,
  SP_HMAC_ReSeed,
  SP_HMAC_Generate,
  SP_HMAC_Cleanup,
  SP800_NON_FIPS,
  SELF_TEST_AT,  
  0,
  {
    {
      &HMAC_SHA1_112IntEin,
      &HMAC_SHA1_112IntNon,
      &NONE,
      &NONE,
      &HMAC_SHA1_112GenEin,
      &HMAC_SHA1_112Result
    },
    {
      &HMAC_SHA1_128IntEin,
      &HMAC_SHA1_128IntNon,
      &HMAC_SHA1_128IntPer,
      &NONE,
      &NONE,
      &HMAC_SHA1_128Result
    },
    {
      &NONE,
      &NONE,
      &NONE,
      &NONE,
      &NONE,
      &NONE,
    },
    {
      &NONE,
      &NONE,
      &NONE,
      &NONE,
      &NONE,
      &NONE,
    },
  }
};


