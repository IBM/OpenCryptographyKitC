/*************************************************************************/
// Copyright IBM Corp. 2023
//
// Licensed under the Apache License 2.0 (the "License"). You may not use
// this file except in compliance with the License. You can obtain a copy
// in the file LICENSE in the source distribution.
/*************************************************************************/

/*************************************************************************/
// Description: Source for the icclib shared library                         
/*************************************************************************/

#if defined(__MVS__)
/* Exported symbol definitions for z/OS - generated by ICCencapsulator.java
   z/OS handles exported symbol visibility - differently -
*/
#include "exports/icclib_zos.h"
#endif
/* Needs to be here to pick up macros to enable Dl_info etc */
#include "loaded.h" 

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>


#include "iccversion.h"
#include "platform.h"
#include "iccglobals.h"
#include "fips.h"
#include "fips-prng/fips-prng-RAND.h"
#include "platfsl.h"
#include "iccerr.h"
#include "TRNG/entropy_estimator.h"
#include "TRNG/ICC_NRBG.h"
#include "openssl/opensslv.h"
#include "crypto/evp.h"
#include "crypto/asn1.h"
#include "openssl/evp.h"

#if(OPENSSL_VERSION_NUMBER < 0x1010105fL)
#   include "crypto/rsa/rsa_locl.h"
# include "crypto/dsa/dsa_locl.h"
#else
#   include "crypto/rsa/rsa_local.h"
# include  "crypto/dsa/dsa_local.h"
#endif

#define ICCLIB 1
/* note - not icc.h ! */
#include "icc_a.h"
#undef ICCLIB
#include "icc_common.h"

#if defined(STANDALONE_ICCLIB)
#include "DELTA/delta_t.h"
#include "DELTA/delta.c"

static unsigned long global_d[10];
#endif

/* If this is set, the support code for tracing is inserted here 
   IFF tracing is enabled.
*/
#define TRACE_CODE 1

#include "tracer.h"

#if defined(_WIN32)
#pragma warning (disable : 4100)
#   define strdup(x) _strdup(x)
#   define stricmp(x,y) _stricmp(x,y)
#endif

extern int ex_loops,ex_shift;

extern int Shift();
extern unsigned int Loops();
extern int isFipsTrng(TRNG_TYPE t);

static int my_RAND_bytes(unsigned char* buf, int n);

/* Prototype for the FIPS compliant keygen function */

int fips_rsa_builtin_keygen(RSA *rsa, int bits,BIGNUM *e_value,BN_GENCB *cb);
/* Forward declarations for redirected functions 
  Note that in all these interfaces pcb is non-NULL just to get here
*/

unsigned char *HKDF_Extract(ICClib *pcb,const EVP_MD *evp_md,const unsigned char *salt, size_t salt_len,const unsigned char *key, size_t key_len,unsigned char *prk, size_t *prk_len);
unsigned char *HKDF_Expand(ICClib *pcb,const EVP_MD *evp_md,const unsigned char *prk, size_t prk_len,const unsigned char *info, size_t info_len,unsigned char *okm, size_t okm_len);
unsigned char *HKDF(ICClib *pcb,const EVP_MD *evp_md,const unsigned char *salt, size_t salt_len,const unsigned char *key, size_t key_len,const unsigned char *info, size_t info_len,unsigned char *okm, size_t okm_len);
int dsa_paramgen_check_g(DSA *dsa);

/* From extsig.c */
int CheckSig(FILE *fin,FILE *targ,EVP_PKEY *rsaPKey,int SigFileOnly);
int ReadConfigItems(FILE *fin, char *tweaks[], int n);
/* from fips.c */
EVP_PKEY *get_pubkey(ICC_STATUS *stat);
extern int iccRSAKeyPair(ICClib *pcb, RSA *temp);

const BIGNUM *DH_get_PrivateKey (const DH * dh);
extern int TwoKeyDes3(int);
/* API to tell OpenSSL it's in FIPS mode
   Use to conditionally disable some (expensive) tests
   when in FIPS mode
*/
extern int FIPS_mode_set(int);
/* Macrod to other functions, which doesn't work 
   well if they are entries in a call table.
   Provide these as wrappers instead
*/

#undef EVP_MD_CTX_init
#undef EVP_MD_CTX_cleanup
#undef EVP_CIPHER_CTX_init
#undef EVP_CIPHER_CTX_cleanup
#undef EVP_CIPHER_CTX_flags

int EVP_MD_CTX_init(EVP_MD_CTX *ctx);
int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
int EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx);

int RSA_FixEncodingZeros(RSA* pri, const RSA* pub, int allowDisableBlinding);
int InternalIntegrityCheck(ICClib *pcb,ICC_STATUS *status,int partial);
int IntegrityCheck(ICClib *pcb,ICC_STATUS *status);

void ALT_Final(); /* Clean up the fd used for /dev/random */

static
void pqc_evp_init();

/*
 *-----------------------------------------------------------------------------
 * INCLUDED source. 
 *-----------------------------------------------------------------------------
 */
/* Drop in code for digsetbyname,cipherbyname */
#include "nid_cache.c"

/* If not NULL we'll attempt to print the first fatal error to this destination
 */
FILE *errorfile = NULL;

/* The call table between ICC_Init() and ICC_Attach(), no crypto function */
static FUNC ICCGlobal_Partial[NUM_ICCLIBFUNCTIONS];
/* The call table if an error is hit, actually copied over the normal 
   running table if it's a critical error. No new objects can be created
*/
static FUNC ICCGlobal_Error[NUM_ICCLIBFUNCTIONS];


static int fips_lie = 0; /*!< If set ICC will lie about it's FIPS state if requested */
#if (NON_FIPS_ICC == 1)
static int config_run_post = 0; /*!< Only an option in non-FIPS ICC's */
#else
static int config_run_post = 1;
#endif
static char *exclude_list = NULL; /*!< List of excluded RNG modes */
static int trng_set = 0; /*!< Some clever for TRNG handling in testing */
const char ICC_SCCSInfo[] =
{
    "@(#)CompanyName:      IBM Corporation\n"
    "@(#)LegalTrademarks:  IBM\n"
    "@(#)FileDescription:  " ICC_DESCRIPTION1 ICC_DESCRIPTION2 "\n"
    "@(#)FileVersion:      " ICC_PRODUCT_VERSION "\n"
    "@(#)LegalCopyright:   Licensed Materials - Property of IBM\n"
    "@(#)                  ICC\n"
    "@(#)                  (C) Copyright IBM Corp. 2002,2015\n"
    "@(#)                  All Rights Reserved. US Government Users\n"
    "@(#)                  Restricted Rights - Use, duplication or disclosure\n"
    "@(#)                  restricted by GSA ADP Schedule Contract with IBM Corp.\n"
    "@(#)ProductName:      " ICC_PRODUCT_NAME "\n"
    "@(#)ProductVersion:   " ICC_PRODUCT_VERSION "\n"
    "@(#)ProductInfo:      " ICC_PRODUCT_INFO "\n"
    "@(#)GIT_BRANCH:       " ICC_GIT_BRANCH "\n"
    "@(#)GIT_HASH :        " ICC_GIT_HASH "\n"
    "@(#)OCKC_BRANCH:      " OCKC_GIT_BRANCH "\n"
    "@(#)OCKC_HASH :       " OCKC_GIT_HASH "\n"
};


const char* G_tmp; /* Used solely to force the linker to include SCCSInfo */ 



/*
 *-----------------------------------------------------------------------------
 * typedefs
 *-----------------------------------------------------------------------------
 */


/*! @brief prototype for a pointer to an OpenSSL locking function */
typedef void (*LockFunc) (int, int, const char *, int);

/*! @brief prototype for a pointer to a function to return a unqiue thread ID */
typedef unsigned long (*ThreadIdFunc) (void);

void *ICC_Malloc(size_t sz, const char *file, int line);
void *ICC_Calloc(size_t n, size_t sz,const char *file, int line);
void *ICC_Realloc(void *ptr,size_t sz,const char *file, int line);
void ICC_Free(void *ptr);
void CleanupSP800_90(void);


#if (NON_FIPS_ICC == 0)
/* FIPS build ! */
static char *no_excluded_rngs = "";
#endif

/*
 *-----------------------------------------------------------------------------
 * globals
 *-----------------------------------------------------------------------------
 */


static int FIPS_init_flag = 0;		


extern char * FIPS_ERROR;



static RSA_METHOD * FIPS_RSA_meth = NULL; /*!< The FIPS RSA method, uses X9.31 key gen */

/*! @brief Triggers induced failure tests if !0, 
  set programatically via 
  ICC_Set_Value(ctx,status,ICC_INDUCED_FAILURE,(void *)somevalue) 
  Being called before ICC_Init()
*/
unsigned int icc_failure = 0;

/*! @brief disallows 'late' setting of ICC_INDUCED_FAILURE */
static unsigned int icc_failure_mask = 0;

/*! @brief - simply a dummy so that ICC_GetValue() works
  This is acted on in the ICC static stub.
*/
unsigned int clean_at_exit = 0;


static void OpenSSL_Init(ICClib *pcb,ICC_STATUS * status);
static void OpenSSL_Cleanup();


/*
  Load/unload  additional error strings into OpenSSL
  (errors caused by OpenSSL calling down into ICC
*/
static void iccLoadErr(ICC_STATUS* status);

void OPENSSL_cpuid_setup(void);


/* Legacy, from when these could be set at startup */

void *ICC_Malloc(size_t sz, const char *file, int line)
{
  void *ptr = NULL;
  ptr = CRYPTO_malloc(sz,file,line);
  return ptr;
}


void *ICC_Calloc(size_t n, size_t sz,const char *file, int line)
{
  void *ptr = NULL;

  ptr = CRYPTO_calloc((int)n,(int)sz,file,line);


  return ptr;
}

void *ICC_Realloc(void *ptr,size_t sz,const char *file, int line)
{
  void *iptr = NULL;

  iptr = CRYPTO_realloc(ptr,sz,file,line);
  return iptr;
}

void ICC_Free(void *ptr)
{
    CRYPTO_free(ptr,__FILE__,__LINE__);       
}
static unsigned char x2bin(unsigned char b)
{
  unsigned char c = 0;
  if( b >= '0' && b <= '9') {
    c = (b - '0');
  } else if (b >= 'a' && b <= 'f') {
    c = (b - 'a') + 10;
  }  else if (b >= 'A' && b <= 'F') {
    c = (b - 'F') + 10;
  }    
  return c;

}

/* The actual FIPS and ERROR flags are stored inside the opaque PCB object,
   and the ICC_STATUS is user provided.
   So we need to set these on exit to ensure the copy in the user supplied status
   is accurate. Note that pcb may be NULL on some of these paths.
*/
ICCSTATIC void SetFlags(ICClib *pcb, ICC_STATUS *status) {
  if (NULL != pcb) {
    status->mode = pcb->flags;
  }
}
static int set_cap(const char *cptr, unsigned long long *cap)
{
  int i = 0;
  unsigned long long v = 0;
  unsigned char c = '\0';
  int temp = ICC_OK;

  for(i = 0; i < 16; i+= 2) {
    v = v * 256;
    if('\0' == cptr[i]) {
      break;
    }
    if(!isxdigit(cptr[i]) || !isxdigit(cptr[i+1]) ) {
        temp = ICC_WARNING;
      break;
    }
    c = x2bin((unsigned char)cptr[i]);
    v |= (c << 4) | x2bin((unsigned char)cptr[i+1]);
    
  }
  if('\0' == cptr[i]) {
    *cap = v;
  } else {
    temp = ICC_WARNING;
  }
  return temp;
}
static void EnvVars()
{
  unsigned long long cap = (unsigned long long)(-1LL);
  const char *tmp = NULL;
  int i = 0;
  char *lie_about_FIPS = NULL;

  IN();

  /*! \EnvVar ICC_IGNORE_FIPS 
    - Force development versions of ICC to accept FIPS mode
    ICC variants that were never certification candidates.
    - Usage: export ICC_INGORE_FIPS=yes
    - Platforms: All
    - Uses: The certification status of ICC can be determined from 
    version number, platform and the ICC Security policy but it may 
    be hard to determine  which version of ICC is  in use if 
    multiple instances exist on one machine.
    - The logic is:
    If ICC_IGNORE_FIPS is set, and not obviously No or False, we assume it means "yes"
    - 
    - FIPS: The module is not in FIPS mode if this enviroment variable 
    is set. This mode is for test purposes.
  */
  /* In a known FIPS release, we insist on a manual override 
     before we'll allow the module to exit FIPS mode.
  */
  fips_lie = 0;
  lie_about_FIPS = getenv ("ICC_IGNORE_FIPS");
  if ((lie_about_FIPS != NULL) &&
      (lie_about_FIPS[0] != 'N') &&
      (lie_about_FIPS[0] != 'n') &&
      (lie_about_FIPS[0] != 'F') && 
      (lie_about_FIPS[0] != 'f') &&
      (lie_about_FIPS[0] != '0')
      ) {
     MARK("ICC_IGNORE_FIPS", lie_about_FIPS);
     fips_lie = 1;
  }
  /*! \EnvVar ICC_INDUCED_FAILURE
    - Allows error paths to be tested programatically
    - FIPS mode: No
   */
  tmp = getenv("ICC_INDUCED_FAILURE");
  if(NULL != tmp) {
     MARK("ICC_INDUCED_FAILURE", tmp);
     icc_failure = atoi(tmp);
  }
  /*! \EnvVar ICC_ALLOW_INDUCED
    - Allows error paths to be tested programatically after startup
    - FIPS mode: No
   */
  
  tmp = getenv("ICC_ALLOW_INDUCED");
  if(NULL != tmp) {
     MARK("ICC_ALLOW_INDUCED", tmp);
     icc_failure_mask = atoi(tmp);
  }
#if (NON_FIPS_ICC == 1)  
  /*! \EnvVar ICC_RUN_POST
    - Turns full POST on in non-FIPS mode
    - FIPS mode: No
   */
  tmp = getenv("ICC_RUN_POST");
  if(NULL != tmp) {
     MARK("ICC_RUN_POST", tmp);
     config_run_post = atoi(tmp);
  }
#endif
  /*! \EnvVar ICC_RNG_TUNER
    - Allows error paths to be tested programatically after startup
    - FIPS mode: No
   */


  tmp = getenv("ICC_RNG_TUNER");
  if(NULL != tmp) {
    MARK("ICC_RNG_TUNER", tmp);
    i = atoi(tmp);
    Set_default_tuner(i);
  }
  /*! \EnvVar ICC_RNG_INSTANCES
    - Sets the number of RNG's in the thread pool. Used to improve scaling
      on really large systems.
    - FIPS mode: Yes
   */

  tmp = getenv("ICC_RNG_INSTANCES");
  if(NULL != tmp) {
    MARK("ICC_RNG_INSTANCES", tmp);
    i = atoi(tmp);
    SetRNGInstances(i);
  }
  /*! \EnvVar ICC_TRNG
    - Sets the type of the TRNG used by default.
   */

  
  tmp = getenv("ICC_TRNG");
  if(NULL != tmp) {
    MARK("ICC_TRNG", tmp);
    SetTRNGName((char *)tmp);
    trng_set = 1;
  }
  /*! \EnvVar ICC_RANDOM_GENERATOR
    - Sets the type of the PRNG used by default.
    - TRNG, the default timer based entropy source on most platforms.
    - Must be FIPS approved and 256 bit effective strength
    - FIPS mode: Yes
   */
  
  tmp = getenv("ICC_RANDOM_GENERATOR");
  if(NULL != tmp) {
     MARK("ICC_RANDOM_GENERATOR", tmp);
     SetPRNGName((char *)tmp);
  }
  /*! \EnvVar ICC_CAP_MASK
    - Disables hardware features used for acceleration
    - FIPS mode: Default or 0000000000000000 (all acceleration off) are allowed
   */
  
  tmp = getenv("ICC_CAP_MASK");
  if(NULL != tmp && (16 == strlen(tmp))) {
    if(ICC_OK == set_cap(tmp,&cap)) {
      MARK("OPENSSL_cpuid_override()","");
      OPENSSL_cpuid_override(cap);
    }
  }
  /*! \EnvVar ICC_RNG_SETUP
    - Forces full RNG setup in all TRNG modes
    - FIPS mode: Yes
  */
  tmp = getenv("ICC_RNG_SETUP");
  if(NULL != tmp) {
    MARK("ICC_RNG_SETUP", tmp);
    i = atoi(tmp);
    Set_rng_setup(i);
  }
  /*! \EnvVar ICC_SHIFT
    - Manual setting of RNG modes
    - May be required to bypass problems on virtualized systems/new hardware
    - FIPS mode: Yes
    - Use only under direction from GSkit L3
  */

  tmp = getenv("ICC_SHIFT");
  if(NULL != tmp) {
    MARK("ICC_SHIFT", tmp);
    i = atoi(tmp);
    ex_shift = i;
  }
  /*! \EnvVar ICC_LOOPS
    - Manual setting of RNG modes
    - May be required to bypass problems on virtualized systems/new hardware
    - FIPS mode: Yes
    - Use only under direction from GSkit L3
  */

  tmp = getenv("ICC_LOOPS");
  if(NULL != tmp) {
    MARK("ICC_LOOPS", tmp);
    i = atoi(tmp);
    ex_loops = i;
  }
  /*! \EnvVar ICC_ALLOW_2KEY3DES
    - Allows 3 DES with 2 keys the same
    - FIPS mode: No
    - Required to pass NIST 3DES tests
  */

  TwoKeyDes3(1);
  tmp = getenv("ICC_ALLOW_2KEY3DES");
  if(NULL != tmp) {
    MARK("ICC_ALLOW_2KEY3DES", tmp);
    i = atoi(tmp);
    TwoKeyDes3(i);
  }

  /*! \EnvVar ICC_RNG_EXCLUDED
    - Sets a black list of RNG modes
    - Disables modes known to have flaws
    - FIPS mode: Yes
  */
  
  tmp = getenv("ICC_RNG_EXCLUDED");
  if(NULL != tmp) {
    MARK("ICC_RNG_EXCLUDED", tmp);
    if(NULL != exclude_list) {
      free(exclude_list);
    }
    exclude_list = strdup(tmp);
    Set_rng_exclude(exclude_list); /* Requires a persistant string */
  }
  /*! \EnvVar ICC_FATAL
       Log fatal errors to stdout/stderr 
       Note that if trace is enabled these will always go to trace
     - FIPS mode: Yes
   */

  tmp = getenv("ICC_FATAL");
  if (NULL != tmp) {
    MARK("ICC_FATAL", tmp);
    if(0 == strcmp(tmp,"stdout")) {
        errorfile = stdout;
    } else if(0 == strcmp(tmp,"stderr")) {
      errorfile = stderr;
    }
  }

  OUT();
}

void SetParams(char *params[],int n)
{
  int i ;
  unsigned long long cap = (unsigned long long)(-1LL);
  char *ptr = NULL;
  IN();
  for (i = 0; i < n; i++) {
    if (NULL == params[i]) {
      break;
    } else {
      ptr = strchr(params[i], '=');
      if (NULL != ptr) {
        ptr++;
        if (0 == strncmp(params[i], "ICC_INDUCED_FAILURE",
                         strlen("ICC_INDUCED_FAILURE"))) {
          MARK("ICC_INDUCED_FAILURE", ptr);
          icc_failure = atoi(ptr);
        }

        if (0 == strncmp(params[i], "ICC_ALLOW_INDUCED",
                         strlen("ICC_ALLOW_INDUCED"))) {
          MARK("ICC_ALLOW_INDUCED", ptr);
          icc_failure_mask = atoi(ptr);
        }

        if (0 == strncmp(params[i], "ICC_RNG_TUNER", strlen("ICC_RNG_TUNER"))) {
          MARK("ICC_RNG_TUNER", ptr);
          Set_default_tuner(atoi(ptr));
        }
        if (0 == strncmp(params[i], "ICC_SHIFT", strlen("ICC_SHIFT"))) {
          MARK("ICC_SHIFT", ptr);
          ex_shift = atoi(ptr);
        }

        if (0 == strncmp(params[i], "ICC_LOOPS", strlen("ICC_LOOPS"))) {
          MARK("ICC_LOOPS", ptr);
          ex_loops = atoi(ptr);
        }
#if (NON_FIPS_ICC == 1)
        if (0 == strncmp(params[i], "ICC_RUN_POST", strlen("ICC_RUN_POST"))) {
          MARK("ICC_RUN_POST", ptr);
          config_run_post = atoi(ptr);
        }
#endif

        if (0 == strncmp(params[i], "ICC_ALLOW_2KEY3DES",
                         strlen("ICC_ALLOW_2KEY3DES"))) {
          MARK("ICC_ALLOW_2KEY3DES", ptr);
          TwoKeyDes3(atoi(ptr));
        }

        if (0 == strncmp(params[i], "ICC_RNG_INSTANCES",
                         strlen("ICC_RNG_INSTANCES"))) {
          MARK("ICC_RNG_INSTANCES", ptr);
          SetRNGInstances(atoi(ptr));
        }

        if (0 == strncmp(params[i], "ICC_TRNG", strlen("ICC_TRNG"))) {
          MARK("ICC_TRNG", ptr);
          SetTRNGName(ptr);
          trng_set = 1;
        }

        if (0 == strncmp(params[i], "ICC_RANDOM_GENERATOR",
                         strlen("ICC_RANDOM_GENERATOR"))) {
           MARK("ICC_RANDOM_GENERATOR", ptr);
           SetPRNGName(ptr);
        }

        if (0 == strncmp(params[i], "ICC_CAP_MASK", strlen("ICC_CAP_MASK"))) {
          if (16 == strlen(ptr)) {
            if (ICC_OK == set_cap(ptr, &cap)) {
              MARK("OPENSSL_cpuid_override()", "");
              OPENSSL_cpuid_override(cap);
            }
          }
        }
        if (0 == strncmp(params[i], "ICC_RNG_SETUP", strlen("ICC_RNG_SETUP"))) {
           MARK("ICC_RNG_SETUP", ptr);
           Set_rng_setup(atoi(ptr));
        }

        if (0 == strncmp(params[i], "ICC_RNG_EXCLUDED", strlen("ICC_RNG_EXCLUDED"))) {
          MARK("ICC_RNG_EXCLUDED", ptr);
          if (NULL != exclude_list) {
            free(exclude_list);
          }
          exclude_list = strdup(ptr);
          Set_rng_exclude(exclude_list);
        }
        if(0 == strncmp(params[i],"ICC_FATAL",strlen("ICC_FATAL"))) {
          MARK("ICC_FATAL", ptr);
          if (0 == strcmp(ptr, "stdout")) {
            errorfile = stdout;
          } else if(0 == strcmp(ptr,"stderr")) {
            errorfile = stderr;
          }
        }
      }
      free(params[i]);
      params[i] = NULL;
    }
  }
  OUT();
}

extern struct ICClibGlobal_t Global;
static void LoadTables(ICC_STATUS* status);

/*! @brief Open the ICC signature file and the ICC shared library
  @param sigfile pointer to the file descriptor pointer for ICCSIG.txt or equivalent
  @param self pointer to the file descriptor pointer for ourself (shared library)
  @param self may be NULL , sigfile must always be non-NULL
*/
void OpenCheckFiles(FILE **sigfile,FILE **self) 
{
  static char tmppath[MAX_PATH+1];
  char *ptr = NULL;
#if defined(_WIN32)
  static wchar_t tmppathW[MAX_PATH+1];
  wchar_t *wptr = NULL;
#endif
  IN();

  FUNCTION_NAME(MYNAME,_path)(tmppath,MAX_PATH-20);
  strncat(tmppath,"/",MAX_PATH);
  ptr = tmppath + strlen(tmppath);
#if defined(STANDALONE_ICCLIB)
  strncat(tmppath,"ICCLIB_SA.txt",MAX_PATH); 
#else
  strncat(tmppath,"ICCSIG.txt",MAX_PATH);
#endif
  *sigfile = fopen(tmppath,"rb");
  MARK(tmppath,(*sigfile) != NULL ? "Opened ICCSIG.txt": "Failed Open ICCSIG.txt");
  /** \induced 150. Signature test, fopen() failed on external file
      in ASCCI mode. (Differs from 151 only on Windows platforms)
   */    
  if(150 == icc_failure) {
    fclose(*sigfile);
    *sigfile = NULL;
  }

#if defined(_WIN32)
  if(NULL == *sigfile) {
    ptr = NULL;
    FUNCTION_NAME(MYNAME,_pathW)(tmppathW,MAX_PATH-20); 
    wcsncat(tmppathW,L"/",MAX_PATH);
    wptr = tmppathW + wcslen(tmppathW);
#   if defined(STANDALONE_ICCLIB)
    wcsncat(tmppathW,L"ICCLIB_SA.txt",MAX_PATH); 
#   else
    wcsncat(tmppathW,L"ICCSIG.txt",MAX_PATH);
#   endif    
    *sigfile = _wfopen(tmppathW,L"rb");
    MARK("wchar_t path",(*sigfile) != NULL ? "Opened ICCSIG.txt": "Failed Open ICCSIG.txt");
    if(NULL != *sigfile) {
      Global.unicode = 1;
    }
  }

#endif

  /** \induced 151. Signature test, fopen() failed on external file.
   */    
  if(151 == icc_failure) {
    fclose(*sigfile);
    *sigfile = NULL;
  }

  if (ICC_OK == Global.status.majRC)
  {
    if (NULL != self)
    { /* Don't always open self */
      if (NULL != ptr)
      {
        *ptr = '\0';
        strncat(tmppath, ICCDLL_NAME, MAX_PATH);
        *self = fopen(tmppath, "rb");
      }
#if defined(_WIN32)
      else if (NULL != wptr)
      {
        *wptr = L'\0';
        MultiByteToWideChar(CP_ACP, 0, ICCDLL_NAME, -1, wptr, MAX_PATH - 1);
        *self = _wfopen(tmppathW, L"rb");
      }
#endif
      /** \induced 152. Signature test, Signature test, fopen() failed on self.
     */
      if (152 == icc_failure)
      {
        fclose(*self);
        *self = NULL;
      }
    }
  }
  if(NULL == *sigfile) {
    SetStatusLn2(NULL,&(Global.status),ICC_ERROR | ICC_FATAL,ICC_LIBRARY_VERIFICATION_FAILED,"External signature file could not be opened",tmppath,__FILE__,__LINE__);
  }
  
  if((NULL != self) && (NULL == *self)) {
    SetStatusLn2(NULL,&(Global.status),ICC_ERROR | ICC_FATAL,ICC_LIBRARY_VERIFICATION_FAILED,"Could not open file for verification",tmppath,__FILE__,__LINE__);
  }

  OUT();
}

#ifdef LIBOQS
int randombytes(uint8_t* x, unsigned long xlen);

static void icc_randombytes(uint8_t* random_array, size_t bytes_to_read)
{
   randombytes(random_array, (unsigned long) bytes_to_read);
}
#endif

/*!
  @brief
  Set up so that it's called by shared library loading
  See platfsl.c
  @return 0 on sucess, !0 otherwise
*/
int ICCLoad ()
{
  int rc = 0;
  int runpost = 1;
  FILE *sigfile = NULL;
  int trc = ICC_OSSL_SUCCESS;
  char *params[20];
  long long cap = 0LL;
  char cpuid[30];

  TRACE_START_EX("icclib",NULL);
  IN();
#if defined(STANDALONE_ICCLIB)
  Delta_T(1,&global_d[0]);
#endif
  MARK("OPENSSL_cpuid_setup()","Crypto capability probe");
  /* CPUID must be determined before we set TRNG's */
  OPENSSL_cpuid_setup();

  memset(params,0,sizeof(params));

#if (NON_FIPS_ICC == 0)
/* FIPS ICC, switch to FIPS TRNG by default */
  SetDefaultTrng(TRNG_FIPS);
#endif

  /* Load anything from the environment */
  EnvVars();
  
  OpenCheckFiles(&sigfile,NULL);


#if defined(STANDALONE_ICCLIB)
  global_d[1] = Delta_T(0,&global_d[0]);
#endif

  if(NULL != sigfile) {
    /* read config from the config file , this isn't signature checked !
       but all allowed values are equally valid in FIPS mode
       Note this caters for a NULL sigfile, ignores it, which is all we need
       Note 2: Yes, config file overrides environment settings.
       Delete from the config file if necessary.

    */
    MARK("ReadConfigItems","Read configuration from ICCSIG.txt");
    ReadConfigItems(sigfile,params,20);
    /* Note SetParams() cleans up the params list as it goes */
    if(NULL != sigfile) {
      fclose(sigfile);
    }   
    SetParams(params,20);    
  }
#if (NON_FIPS_ICC == 1) /* Built as non-FIPS */
  /* If we aren't the FIPS instance we won't run POST by default. 
     But run POST even if we are pretending we have FIPS as we need
     this for internal testing
   */
  if(!fips_lie) { /* Not pretending to be a FIPS module, POST off */
    runpost = 0;
  } else {
    if(!trng_set) {
      SetDefaultTrng(TRNG_FIPS);
      FIPS_mode_set(1);
    } else {
      fips_lie = 0;
    }
  }
  if(config_run_post) { /* Or if forced in the config file, on */
    runpost = 1;
  }
#else /* Built as FIPS */
  /* Default TRNG could have been changed by EnvVars() or ReadConfigItems() 
    so confirm we are still using a FIPS compliant TRNG at this point
  */
  TRNG_TYPE trng = GetDefaultTrng();
  if(!isFipsTrng(trng)) {
    fips_lie = 1; /* Drop us out of FIPS mode */
  } else {
     FIPS_mode_set(1);
  }
#endif



#if defined(STANDALONE_ICCLIB)
  global_d[2] = Delta_T(0,&global_d[0]);
#endif

  OpenSSL_Init(NULL,&(Global.status));

  init_name_caches();

#if defined(STANDALONE_ICCLIB)
  global_d[3] = Delta_T(0,&global_d[0]);
#endif
  if(runpost) {
    if(ICC_OK == Global.status.majRC ) {
      trc = SelfTest(NULL,&(Global.status)); 
    } else {
      SetFatalError("Self Test failed",__FILE__,__LINE__); /* Should be tripped earlier */
    }
  }
#if defined(STANDALONE_ICCLIB)
  global_d[4] = Delta_T(0,&global_d[0]);
#endif

  if(trc != ICC_OSSL_FAILURE) {
    Global.initialized = 1;
  } else {
    OpenSSL_Cleanup();
    SetFatalError("Could not initialize OpenSSL",__FILE__,__LINE__);
  }

  if(ICC_OK == Global.status.majRC ) {
    /* And check the binary only if we run full POST */
    rc =  InternalIntegrityCheck(NULL,&(Global.status),(runpost == 0));
    if((ICC_WARNING == rc) || (ICC_ERROR == rc)) {
       SetFatalError("Integrity check failed",__FILE__,__LINE__);
    }
  
  }
#if defined(STANDALONE_ICCLIB)
  global_d[5] = Delta_T(0,&global_d[0]);
#endif
  if(Global.status.majRC != ICC_ERROR) {
    LoadTables(&(Global.status));
    OPENSSL_cpuid(&cap);
    /* Should be snprinf but that can't be found on Windows */
    sprintf(cpuid,"%016llx",cap);
    MARK("CPUID",cpuid);
  }  

  pqc_evp_init();

  OUTRC(rc);
  return rc;
}

/*!
  @brief
  Clean up the ICC global Mutex.
  This should be tripped by the ICC shared library unloading, 
  We do try to do this on platforms that support it, but
  unlike ICCLoad() it's not critical if it's not called
  @return 0 on sucess, !0 otherwise
*/
int ICCUnload ()
{
  int rc = 0;

  IN();
  ALT_Final(); /* Clean up fd used by TRNG_ALT */
  OpenSSL_Cleanup();
  if(NULL != exclude_list) {
    free(exclude_list);
    exclude_list = NULL;
  }

  OUTRC(rc);
  TRACE_END_EX();
  return rc;
}

/*!
  @brief Integrity check ICC. This is the check run during POST
  @param pcb ICC library context
  @param status status return
  @param partcheck Only check the signature file
  @return ICC_OK, ICC_ERROR,ICC_WARNING
  @note ICC_WARNING will be returned if the necessary files could not be opened
        preventing us from performing the checks
        close some files and retry.
        - This is considered a fatal error if it occurs during POST, at the application 
        level there is the possibility of closing files/sockets and retrying
  @note partcheck is used internally with non-FIPS ICC's, we read configuration
        from the signature file and checking that still matters
*/

int InternalIntegrityCheck(ICClib *pcb, ICC_STATUS *status, int partcheck)
{
  ICC_MAJOR_RC_ENUM rc = ICC_OK;
  int rv = 0;
  FILE *sigfile = NULL; /* File handle for the signature file */
  FILE *self = NULL;    /* File handle for ourself (shared lib) */
  EVP_PKEY *rsakey = NULL;
  IN();

  if (NULL == status)
  {
    rc = ICC_ERROR;
  }
  else
  {
    SetStatusOK(pcb, status);
  }
  if (ICC_OK == rc)
  {
    OpenCheckFiles(&sigfile, &self);
    if ((NULL == sigfile) || (NULL == self))
    {
      rc = SetStatusLn(pcb, status, ICC_WARNING, ICC_LIBRARY_VERIFICATION_FAILED, "Could not open files to perform integrity check", __FILE__, __LINE__);
    }
  }
  if (ICC_OK == rc)
  {
    rsakey = get_pubkey(status);
    if (NULL == rsakey)
    {
      rc = SetStatusLn(pcb, status, ICC_ERROR, ICC_LIBRARY_VERIFICATION_FAILED, "Could not create verification key", __FILE__, __LINE__);
    }
  }
  if (ICC_OK == rc)
  {
    rv = CheckSig(sigfile, self, rsakey, partcheck);
    /** \induced 154. Signature test, Signature test fails "unknown error"
	       basically a crypto. failure somewhere
    */
    if (154 == icc_failure)
    {
      rv = 3;
    }
    /** \induced 155. Signature test, Signature test fails, signature of self doesn't match
     */
    if (155 == icc_failure)
    {
      rv = 2;
    }
    /** \induced 156. Signature test, Signature test fails, signature of external signature file doesn't match
     */
    if (156 == icc_failure)
    {
      rv = 1;
    }
    switch (rv)
    {
    case 0:
      break;
    case 1:
      rc = SetStatusLn(pcb, status, ICC_ERROR | ICC_FATAL, ICC_LIBRARY_VERIFICATION_FAILED, "External signature file corrupt or incompatible", __FILE__, __LINE__);
      break;
    case 2:
      rc = SetStatusLn(pcb, status, ICC_ERROR | ICC_FATAL, ICC_LIBRARY_VERIFICATION_FAILED, "ICC crypto library file corrupt", __FILE__, __LINE__);
      break;
    case 3:
      rc = SetStatusLn(pcb, status, ICC_ERROR | ICC_FATAL, ICC_LIBRARY_VERIFICATION_FAILED, "Unknown error when verifying library", __FILE__, __LINE__);
      break;
    case 4: /* Shouldn't hit 4, NULL files */
      rc = SetStatusLn(pcb, status, ICC_WARNING, ICC_LIBRARY_VERIFICATION_FAILED, "Unable to open files to perform verification", __FILE__, __LINE__);
      break;
    default:
      break;
    }
  }
  if (NULL != sigfile)
  {
    fclose(sigfile);
  }
  if (NULL != self)
  {
    fclose(self);
  }
  if(NULL != rsakey) {
    EVP_PKEY_free(rsakey);
  }
  OUTRC(rc);
  return rc;
}
/*!
  @brief Integrity check ICC. 
  @param pcb ICC library context
  @param status status return
  @return ICC_OK, ICC_ERROR,ICC_WARNING
  @note Anything other than ICC_OK will result in the API shutting down. 
  This includes not enough files to perform the test (ICC_WARNING)
*/
int IntegrityCheck(ICClib *pcb, ICC_STATUS *status)
{
   int rc = ICC_OK;
   rc = InternalIntegrityCheck(pcb, status, 0);
    if((ICC_ERROR == rc) || (ICC_WARNING == rc)) {
       SetFatalError("Integrity check failed",__FILE__,__LINE__);
    }
    return rc;
}

/*!
  @brief
  Get status from OpenSSL access layer
  @param pcb ICC library context
  @param status status return
  @return ICC_OSSL_SUCCESS
*/
int GetStatus (ICClib * pcb, ICC_STATUS * status)
{

  if (status == NULL || pcb == NULL) {
    return ICC_FAILURE;
  }
  /* Yes, this is correct, if there's a terminal error
     SetStatus() called by SetStatusOK() handles that
  */
  SetStatusOK(pcb,status); 
  return ICC_OSSL_SUCCESS;
}


/*!
  @brief
  Initialize an ICClib structure
  @param pcb ICC internal context to be initialized
  @param status status return
  @param iccpath root path to icc libs. Actualy libraries are (hardwired) relative to this
  @param icclibhash FORMERLY ICC shared library signature
  - no longer used - either starts with 0 or 'W' to indicate iccpath is wchar_t
  @param cryptolibhash FORMERLY OpenSSL shared library signature, now unused
  @return the initialized ICClib structure or NULL on failure
*/

void *lib_init (ICClib * pcb, ICC_STATUS * status, const char *iccpath,
		const char *icclibhash, const char *cryptolibhash)
{
    /*
   * This is here only to keep agressive linkers from optimizing out our
   *    copyright/SCCS info.
   */
  const char *bogusVariable = ICC_SCCSInfo;
  struct ICClib_t *pcbt = NULL;

#ifdef OS400
  /* Not an ideal fix */
  struct iccsigs_t {
    const char *icclib;
    const char *icc400;
  } *iccsigs = (struct iccsigs_t*)icclibhash;

  const char *icc400hash = iccsigs->icc400;
  icclibhash = iccsigs->icclib;
#endif

  IN();
  /* Prevent compilers complaining about unused variables */
  G_tmp = bogusVariable;

  MARK("Version Info:", G_tmp);

  if (status == NULL) {
    return NULL;
  }
  SetStatusOK(NULL, status);

  if(getErrorState()) {
    ICC_GetLastError(status);
    return NULL;
  }

  pcbt = (ICClib *) ICC_Calloc (1,sizeof (ICClib),__FILE__,__LINE__);

  if (pcbt == NULL) {
    SetStatusMem (NULL,status,__FILE__,__LINE__);
    return NULL;
  }
  if (NULL != iccpath) {
    if ('\0' == Global.iccpath[0]) {
#if defined(_WIN32)
      if ((NULL != icclibhash) &&
          (*icclibhash == 'W')) { /* Wide char path handling */
        wcsncpy((wchar_t *)Global.iccpath, (wchar_t *)iccpath,
                sizeof(Global.iccpath) - sizeof(wchar_t));
        Global.unicode = 1;
      } else
#endif /* _WIN32 */
        strncpy(Global.iccpath, iccpath, sizeof(Global.iccpath) - 1);
    }
  }
  if( '\0' == Global.version[0]) {
    strncpy (Global.version,ICC_PRODUCT_VERSION,sizeof(Global.version));   
  }
  
  pcbt->length = sizeof (ICClib);
  /*now set the time, process and thread IDs */
  *(DWORD *) (pcbt->toi) = (DWORD) time (NULL);
  *(DWORD *) (pcbt->pIDinit) = ICC_GetProcessId ();
  *(DWORD *) (pcbt->tIDinit) = ICC_GetThreadId ();
  pcbt->funcs = ICCGlobal_Partial; /* Can only use a subset of functions before Attach */
#if (NON_FIPS_ICC == 1)
  /* The FIPS module is always initialized in FIPS mode 
    UNLESS the TRNG was changed
  */

    if(GetDefaultTrng() == TRNG_FIPS) {
      pcbt->flags |=  ICC_FIPS_FLAG;
    } else {
      MARK("Non-FIPS compliant TRNG configured, cannot enter FIPS mode","");
    }
#endif

  SetFlags(pcbt,status);
  OUTRC((NULL != pcbt));
  return (void *) pcbt;
}


/*!
  @brief set the callback for the mandatory FIPS indicator
         This is provided to allow the application to determine whether
         the function being called is a FIPS certified operation.
  @param pcb ICC internal context
  @param callback pointer to the callback function void (*callback)(const char *function,int nid,int status)
  @return 1 on success, 0 on failure (callback already set)
  @note - The callback is tied to the ICC_CTX
        - called before return from successful algorithm initialization
          or keygen. (Function failure has it's own indicators.)
        - function is the function that the callback came from
        - nid is the internal object ID of object.
          This may be somewhat abstracted in some cases, i.e. for an RNG
          it'll be the nid corresponding to the underlying algorithm
        - status is 1 if the object usage was valid for FIPS
          i.e. FIPS certified algorithm, key size acceptable etc.
        - First to set this per ICC_CTX wins
        - If you want to avoid the pain of sorting out threading issues
          use one ICC_CTX/thread
        - The callback is only removed by calling ICC_Cleanup()
          If occasional access only is required, use multiple ICC_CTX's  
*/
static
int SetFIPSCallback(ICClib *pcb, const CALLBACK_T* callback)
{
    int rv = 0;
    if((NULL != pcb) && (NULL == pcb->callback) && (pcb->flags & ICC_FIPS_FLAG)) {
        pcb->callback = callback?*callback:NULL;
        rv = 1;
    }
    return rv;
}

static
int SetTRACECallback(ICClib* pcb, const TRACE_CALLBACK_T* callback)
{
    int rv = 0;
    if (pcb) {
        pcb->trace_callback = callback?*callback:NULL;
      rv = 1;
    }
    return rv;
}

/*!
  @brief Set one of the internal ICC control values
  @param pcb ICC internal context
  @param status status return
  @param value pointer to value data
  @param valueID ID of value to set
  @return ICC_OSSL_SUCCESS or ICC_FAILURE
*/
int SetValue (ICClib * pcb, ICC_STATUS * status,ICC_VALUE_IDS_ENUM valueID,
		   const void *value)
{
  int rv = ICC_OK;

  IN();
  if (status == NULL) {
    return ICC_FAILURE;
  }
  SetStatusOK (NULL,status);	/* Default */
  /* We'll allow the memory callbacks and PRNG to be set before we've initialized anything
     as that's the only place we can do it and get consistent malloc()/free() pairing
     This isn't offically documented anywhere !.
  */
  if(NULL == pcb) {
    rv = ICC_FAILURE;
    switch(valueID) {
    case ICC_INDUCED_FAILURE:	
      icc_failure = *(unsigned int *)value;
      rv =  ICC_OK;
      break;
    default:
      break;
    }
    return rv;
  }
  if (pcb->lock != 0) {
    /* Allow only a few options once initialised */
    switch(valueID) {
      case ICC_INDUCED_FAILURE:
      case ICC_FIPS_CALLBACK:
      case ICC_TRACE_CALLBACK:
      break;
      default:
      SetStatusLn (pcb,status, ICC_ERROR, ICC_INVALID_STATE,
		   (char *)"Attempted to set value while in locked state",
		   __FILE__,__LINE__);
      return ICC_FAILURE;
      break;
    }
  }
  if (value == NULL && (valueID == ICC_FIPS_APPROVED_MODE)) {
      SetStatusLn (pcb,status, ICC_ERROR, ICC_NULL_PARAMETER,
		   (char *)"Null parameters are not allowed for this ID",
		   __FILE__,__LINE__);
      return ICC_FAILURE;
    }
  switch (valueID) {
  case ICC_FIPS_APPROVED_MODE:
    MARK("ICC_FIPS_APPROVED_MODE",(char *)value);

 #if (NON_FIPS_ICC == 0)
    /* The FIPS version defaults to being in FIPS mode
      AND is reluctant to go into non-FIPS mode
      i.e. requires an override to do so
    */
    if (strcmp((char *)value, "off") == 0) {
      if (1 == fips_lie) {
        pcb->flags &= (~ICC_FIPS_FLAG);
        /* This is done so we can access the entropy taps
               in the FIPS ICC
              */
        if (NULL == exclude_list) {
          Set_rng_exclude(no_excluded_rngs);
        }
        break;
      }
    }
    if (strcmp((char *)value, "on") == 0) {
      pcb->flags |= ICC_FIPS_FLAG;
      break;
    }    
#else
    /* In a known non-FIPS release, we insist on a manual override
       before we'll allow the module to ENTER FIPS mode.
    */
    if (strcmp((char *)value, "on") == 0) {
      if (1 == fips_lie) {
        pcb->flags |= ICC_FIPS_FLAG;
        break;
      }
    }
    if (strcmp((char *)value, "off") == 0) {
      pcb->flags &= (~ICC_FIPS_FLAG);
      break;
    }
#endif
    SetStatusLn(pcb, status, ICC_ERROR, ICC_UNSUPPORTED_VALUE,
                (char *)"Invalid data value", __FILE__, __LINE__);
    break;
  case ICC_INSTALL_PATH:
    SetStatusLn(pcb, status, ICC_ERROR, ICC_UNSUPPORTED_VALUE_ID,
                (char *)"Attempted to set an unsettable value ID", __FILE__,
                __LINE__);
    break;
  case ICC_VERSION:
    SetStatusLn(pcb, status, ICC_ERROR, ICC_UNSUPPORTED_VALUE_ID,
                (char *)"Attempted to set an unsettable value ID", __FILE__,
                __LINE__);
    break;
  case ICC_MEMORY_ALLOC:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Memory callbacks are unsafe (function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_MEMORY_REALLOC:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Memory callbacks are unsafe(function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_MEMORY_FREE:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Memory callbacks are unsafe(function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_LOCKING_FUNCTION:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Locking callbacks are unsafe(function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_ID_FUNCTION:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Locking callbacks are unsafe(function deprecated, "
                        "value ignored)",
                __FILE__, __LINE__);
    break;
  case ICC_RANDOM_GENERATOR:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"The PRNG must be set before POST", __FILE__, __LINE__);
    break;

  case ICC_SEED_GENERATOR:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"The TRNG must be set before POST", __FILE__, __LINE__);
    break;

  case ICC_RNG_INSTANCES:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"RNG instances must be set before POST", __FILE__,
                __LINE__);
    break;
  case ICC_RNG_TUNER:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"RNG tuner must be set before POST", __FILE__,
                __LINE__);
    break;
  case ICC_INDUCED_FAILURE:
    /* Note that this is gated by ICC_ALLOW_INDUCED being set during
       startup, not an issue for SUID processes as this is strictly
       for testing and the expectation is that the process will
       terminate.
     */
    if (NULL != value) {
      if (0 != icc_failure_mask) {
        icc_failure = *(unsigned int *)value;
        rv = ICC_OK;
      } else {
        SetStatusLn(
            pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
            (char *)"Attempted to set ICC_INDUCED_FAILURE when ICC was running",
            __FILE__, __LINE__);
      }
    } else {
      SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                  (char *)"The pointer to the induced failure was NULL",
                  __FILE__, __LINE__);
    }
    break;
  case ICC_CLEAN_AT_EXIT:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"The atexit() handler state before POST", __FILE__,
                __LINE__);
    break;
  case ICC_CPU_CAPABILITY_MASK:
    SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"The CPU capability mask must be set before POST",
                __FILE__, __LINE__);
    break;
    case ICC_FIPS_CALLBACK:
    if (value == NULL) {
      SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
              (char *)"Callback cannot be NULL",
              __FILE__, __LINE__);
      break;
    }
    
    if( 0 == SetFIPSCallback(pcb, (const CALLBACK_T *)value) ) {
        SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
                (char *)"Callbacks are only valid in FIPS mode and the callback can only be set once/ICC_CTX",
                __FILE__, __LINE__);
      break;
      }

      MARK("ICC_FIPS_CALLBACK set","");
    break;

  case ICC_TRACE_CALLBACK:
    if (0 == SetTRACECallback(pcb, (const TRACE_CALLBACK_T *)value)) {
          SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_NOT_SET,
              (char*)"Callbacks are valid in FIPS mode and Non FIPS mode the callback can only be set once/ICC_CTX",
              __FILE__, __LINE__);
          break;
      }
    MARK2("ICC_TRACE_CALLBACK", pcb->trace_callback?"set":"NULL");
    break;


  default:
    SetStatusLn(pcb, status, ICC_ERROR, ICC_UNSUPPORTED_VALUE_ID,
                (char *)"Attempted to set an invalid value ID", __FILE__,
                __LINE__);
    break;
  }
  if ((ICC_OK == rv) && (ICC_OK != status->majRC)) {
    rv = status->majRC;
  }
  /* Note that the FIPS and ERROR bits are within the opaque ICC context
    we need to remember to copy that out to the ICC_STATUS as we exit */
  SetFlags(pcb,status);
  OUTRC(rv);
  return rv;
}

/*!
  @brief
  Get one of the internal ICC control values
  @param pcb ICC internal context
  @param status status return
  @param valueID ID of value to set
  @param value pointer to value data buffer
  @param valueLength the maximum allowed length of the returned value
  @return ICC_OSSL_SUCCESS or ICC_FAILURE
*/

int GetValue (ICClib * pcb, ICC_STATUS * status,ICC_VALUE_IDS_ENUM valueID,
		   void *value, int valueLength)
{
   size_t tmp = 0;
   int rv = ICC_OK;
   IN();
   if (status == NULL || pcb == NULL) {
      return ICC_FAILURE;
   }
   SetStatusOK (pcb,status);	/* Default */
   if (value == NULL) {
     SetStatusLn (pcb,status, ICC_ERROR, ICC_NULL_PARAMETER,
		(char *)"Null parameters are not allowed",
		  __FILE__,__LINE__);
      return ICC_FAILURE;
   }
   memset(value,0,valueLength);
   switch(valueID) {
   case ICC_ENTROPY_ESTIMATE:
   case ICC_RNG_INSTANCES:
   case ICC_RNG_TUNER:
   case ICC_ALLOW_INDUCED:
   case ICC_INDUCED_FAILURE:
   case ICC_LOOPS:
   case ICC_SHIFT:
     tmp = sizeof(int);
     break;
  case ICC_FIPS_CALLBACK:
    tmp = sizeof(CALLBACK_T);
    break;
  case ICC_TRACE_CALLBACK:
    tmp = sizeof(TRACE_CALLBACK_T);
    break;
   default:
     tmp = sizeof(void *);
     break;
   }

   if (valueLength < tmp) {
     SetStatusLn (pcb,status, ICC_ERROR, ICC_INVALID_PARAMETER,
		  (char *)"Value does not meet the minimum size requirement",
		  __FILE__,__LINE__);
     return ICC_FAILURE;
   }
   switch (valueID) {
   case ICC_FIPS_APPROVED_MODE:
     strncpy((char *)value, "off",valueLength);
     if (pcb->flags & ICC_FIPS_FLAG) {
       strncpy ((char *) value, "on",valueLength);
     }
     MARK("ICC_FIPS_APPROVED_MODE",(char *)value);
     break;
   case ICC_INSTALL_PATH:
     if (Global.iccpath[0] == '\0') {
       SetStatusLn (pcb,status, ICC_WARNING, ICC_VALUE_NOT_SET,
		    (char *)"Value has not been initialized",
		    __FILE__,__LINE__);
     }
#if defined(_WIN32)
     if (Global.unicode) {
       tmp = (wcslen((wchar_t *)Global.iccpath)) * (sizeof(wchar_t));
       if (tmp >= valueLength) {
         SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_TRUNCATED,
                     (char *)"Value has been truncated", __FILE__, __LINE__);
       }
       memset(value, valueLength, 0);
       wcsncpy((wchar_t *)value, (wchar_t *)Global.iccpath,
               (valueLength - 1) / sizeof(wchar_t));
     } else
#endif
     {
       tmp = strlen(Global.iccpath);
       if (tmp >= valueLength) {
         SetStatusLn(pcb, status, ICC_WARNING, ICC_VALUE_TRUNCATED,
                     (char *)"Value has been truncated", __FILE__, __LINE__);
       }
       strncpy((char *)value, Global.iccpath, valueLength - 1);
       ((char *)value)[valueLength - 1] = '\0';
     }
     MARK("ICC_INSTALL_PATH", (NULL != value) ? (char *)value : "");
     break;
   case ICC_VERSION:
     strncpy ((char *) value, Global.version,valueLength-1);
     ((char *)value)[valueLength - 1] = '\0';
     MARK("ICC_VERSION",(char *)value);
     break;
   case ICC_MEMORY_ALLOC:
     *(void **) value = NULL;
     break;
   case ICC_MEMORY_REALLOC:
     *(void **) value = NULL;
     break;
   case ICC_MEMORY_FREE:
     *(void **) value = NULL;
     break;
   case ICC_LOCKING_FUNCTION:
     *(void **) value = NULL;
     break;
   case ICC_ID_FUNCTION:
     *(void **) value = NULL;
     break;
   case ICC_INDUCED_FAILURE:
     *(unsigned int *) value = icc_failure;
     break;
   case ICC_ALLOW_INDUCED:
     *(unsigned int *) value = icc_failure_mask;
     break;
   case ICC_CLEAN_AT_EXIT:
     *(unsigned int *) value = clean_at_exit;
     break;
   case ICC_ENTROPY_ESTIMATE:
     /*! \FIPS  return the current TRNG entropy estimate (FIPS140-3 draft requirement) */
     *(int *) value = RAND_FIPS_Entropy();
     MARK("ICC_ENTROPY_ESTIMATE","");
     break;
   case ICC_RANDOM_GENERATOR:
     strncpy((char *) value,GetPRNGName(),(valueLength < 19) ? valueLength: 19);
     MARK("ICC_RANDOM_GENERATOR",(char *)value);
     break;
   case ICC_SEED_GENERATOR:
     strncpy((char *) value,GetTRNGName(),(valueLength < 19) ? valueLength: 19);
     MARK("ICC_TRNG",(char *)value);
     break;
   case ICC_RNG_INSTANCES:
     *(int *)value = GetRNGInstances();
     MARK("ICC_RNG_INSTANCES","");
     break;
   case ICC_RNG_TUNER:
     *(int *)value = Get_default_tuner();
      MARK("ICC_RNG_TUNER","");
    break;
   case ICC_SHIFT:
     *(int *)value = Shift();
      MARK("ICC_SHIFT","");
    break;
    case ICC_LOOPS:
     *(int *)value = Loops();
      MARK("ICC_LOOPS","");
    break;
  case ICC_CPU_CAPABILITY_MASK:
     if(valueLength > 0) {
       *(char *)value = '\0';
     }
     if(valueLength < 17) {
       SetStatusLn (pcb,status, ICC_WARNING, ICC_INVALID_PARAMETER,
		    (char *)"Return field must be at least 17 bytes",
		    __FILE__,__LINE__);
     } else {
       long long cpuid = 0;
       if( 0 != OPENSSL_cpuid(&cpuid) ) {
	        sprintf((char *)value,"%016llx",cpuid);
       }
     }
     MARK("ICC_CPU_CAPABILITY_MASK",(value != NULL)? (char *)value:"");
     break;
   case ICC_FIPS_CALLBACK:
     *(CALLBACK_T *)value = pcb->callback;
      MARK("ICC_FIPS_CALLBACK","");
    break;
      
   case ICC_TRACE_CALLBACK:
       *(TRACE_CALLBACK_T*)value = pcb->trace_callback;
       MARK2("ICC_TRACE_CALLBACK", pcb->trace_callback?"set":"NULL");
       break;
      
   default:
     SetStatusLn (pcb,status, ICC_ERROR, ICC_UNSUPPORTED_VALUE_ID,
		  (char *)"Attempted to get an invalid value ID",
		  __FILE__,__LINE__);
     rv = ICC_FAILURE;
     break;
   }
   if((ICC_OK == rv) && (ICC_OK != status->majRC)) {
     rv = status->majRC;
   }
   SetFlags(pcb,status);
   OUTRC(rv);
   return rv;
}




/*! @brief hook the OpenSSL RSA default method so we can
    force use of X9.31 keygen
    @param icc_stat  error return 
    @return ICC_OSSL_SUCESS or ICC_FAILURE
*/

typedef int (*PF_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);

static int iccSetUpRSAFIPS(ICC_STATUS *icc_stat)
{
   const RSA_METHOD *def = NULL;
   int ret = ICC_OSSL_SUCCESS;
   IN();
#if 1 
   def = RSA_get_default_method();
   
   if(NULL != def && NULL == FIPS_RSA_meth) {

     FIPS_RSA_meth = RSA_meth_dup(def);
     /** \induced 170. Failure to set RSA keygen to X9.31 method */
     if(170 == icc_failure) {
       /* Yes, do nothing */
     } else {
#if defined(_WIN32)
       RSA_meth_set_keygen(FIPS_RSA_meth,fips_rsa_builtin_keygen);
#else       
       RSA_meth_set_keygen(FIPS_RSA_meth, (PF_keygen)fips_rsa_builtin_keygen);
#endif
       RSA_set_default_method((const RSA_METHOD *)FIPS_RSA_meth);
     }   
   } 
   if( (const RSA_METHOD *)FIPS_RSA_meth != RSA_get_default_method() ) {
     SetStatusLn(NULL,icc_stat,ICC_ERROR | ICC_FATAL,ICC_LIBRARY_VERIFICATION_FAILED,
		                  "Failed to setup the FIPS compliant RSA key generator",__FILE__,__LINE__); 
     ret = ICC_FAILURE;
     MARK("Failed to setup FIPS RSA keygen","");
   }
#endif    
   OUTRC(ret);
   return ret;         
}

/*! @brief Initialize OpenSSL
  Only called in the library load path 
*/
static void OpenSSL_Init(ICClib *pcb, ICC_STATUS * status)
{
  IN();

  /* Make sure this is done before we do any crypto */
  MARK("OPENSSL_cpuid_setup()","");
  OPENSSL_cpuid_setup();

  if(ICC_OK == status->majRC) {

    MARK("OPENSSL_init_crypto(OPENSSL_INIT_NO_LOAD_CONFIG | OPENSSL_INIT_NO_ATEXIT | OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_ADD_ALL_CIPHERS)","");

    OPENSSL_init_crypto(
            OPENSSL_INIT_NO_LOAD_CONFIG | OPENSSL_INIT_NO_ATEXIT |
            OPENSSL_INIT_LOAD_CRYPTO_STRINGS |
            OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_ADD_ALL_CIPHERS,
            NULL);

    iccLoadErr (status);
    /* Set the FIPS RNG methods */
    if(ICC_OK == status->majRC) {
      /* Note, the RNG's now auto-seed/reseed */
      iccSetRNG(pcb, status,NULL,0);
    }
    /* Set the RSA FIPS method */
    if(ICC_OK == status->majRC) {
      iccSetUpRSAFIPS (status);
    }
    FIPS_init_flag = 1;

  } 
  OUT();
}

   
/*! @brief Cleanup OpenSSL 
     Only called in the library unload path
*/
static void OpenSSL_Cleanup()
{ 
  IN();

  if(NULL != FIPS_RSA_meth) {
    RSA_meth_free(FIPS_RSA_meth);
    FIPS_RSA_meth = NULL;
  }
  OPENSSL_cleanup();
  
  /* Remove our RNG hooks */
  iccCleanupRNG();
  /* Cleanup mutexes on the PRNG TYPES 
     These protect the instantiation counter only
   */
  CleanupSP800_90(); 


  OUT();
}
/*! 
  @brief Load ICC specific error strings into OpenSSL's error tables
  @param status the error status
*/
  
static void iccLoadErr(ICC_STATUS* status)
{
    ERR_STRING_DATA (*temp)[]=NULL;
    ERR_load_crypto_strings();
    get_ICC_str_libraries(&temp);
    ERR_load_strings(ICC_ERR_L_ICC, *temp);
    get_ICC_str_functions(&temp);
    ERR_load_strings(ICC_ERR_L_ICC, *temp);
    get_ICC_str_reasons(&temp);
    ERR_load_strings(ICC_ERR_L_ICC, *temp);
    getPrngErrFuncts(&temp);
    ERR_load_strings(ERR_LIB_RAND, *temp);
    getPrngErrReasons(&temp);
    ERR_load_strings(ERR_LIB_RAND, *temp);
}

/*! 
  @brief
  Cleanup an ICC context.
  @param pcb ICC internal context
  @param status status return
  @return ICC_OSSL_SUCCESS or ICC_FAILURE
  @note As of ICC8.x this does very little the call table
  is now global and we defer all the heavy duty lifting until
  we are being unloaded.
*/
int lib_cleanup (ICClib *pcb,ICC_STATUS * status)
{
  int rv = ICC_OSSL_SUCCESS;
  IN();
  if (status == NULL || pcb == NULL) {
     rv = ICC_FAILURE;
  }
  /* Note NO SetStatusOK() here as that will return the last 
     error on a hard error, and we want a clean escape 
     on an ICC_Cleanup() call. 
     It's set correctly by the higher level code, but called here 
     will return the persistant error
  */
  if(ICC_OSSL_SUCCESS == rv) {
    ICC_Free(pcb);
    if (status->majRC != ICC_OK) {
      rv = ICC_FAILURE;
    }
  }  
  OUTRC(rv);
  return rv;
}

/*!
  @brief
  Self test code
  - run NIST mandated self tests
  @param pcb ICC internal context
  @param status status return
  @return ICC_OSSL_SUCCESS or ICC_FAILURE
*/
int SelfTest (ICClib *pcb,ICC_STATUS * status)
{
  int iccRC = ICC_OSSL_SUCCESS;

	
  MARK("SelfTest","iccDoKnownAnser");
  /*! \FIPS call the known answer tests during POST */
  iccDoKnownAnswer (pcb, status);
  if (status->majRC != ICC_OK) {
    iccRC = ICC_OSSL_FAILURE;
    /* And if it's a FIPS context or POST, make sure this
       is remembered for all future FIPS contexts
    */
    MARK("SelfTest","failed");
    SetStatusLn(pcb,status,ICC_ERROR | ICC_FATAL,ICC_LIBRARY_VERIFICATION_FAILED,"Self Test failed",__FILE__,__LINE__);
  }
  OUTRC(iccRC);
  return iccRC;
}


/*!
  @brief
  OpenSSL calloc function
  @param n the number of blocks to allocate
  @param sz the size of each block
  @param file __FILE__, file where the allocation was requested
  @param line __LINE__, line where the allocation was requested
  @return NULL or the newly allocated block
  @note OpenSSL doesn't provide a calloc, so we call it's malloc and then
  memset() the area to 0
*/
void *CRYPTO_calloc(int n,int sz,const char *file, int line)
{
  void *tmp = NULL;
  tmp = CRYPTO_malloc(n*sz,file,line);
  if(NULL != tmp) {
    memset(tmp,0,n*sz);
  }
  return tmp;
}

/*! 
  @brief
  Free an MD context
  @param x pointer to an existing MD context
  @return ICC_OSSL_SUCCESS or ICC_OSSL_FAILURE
*/
/* included via icclib_a.c */
static
int my_EVP_MD_CTX_free (EVP_MD_CTX * x)
  {
   if (x != NULL) {
     EVP_MD_CTX_cleanup(x);     
     ICC_Free (x);
     return ICC_OSSL_SUCCESS;
   }
   return ICC_OSSL_FAILURE;
}

/*! 
  @brief
  Free an ENCODE context
  @param x pointer to an existing ENCODE context
  @return ICC_OSSL_SUCCESS or ICC_OSSL_FAILURE
*/

/* included via icclib_a.c */
static
int my_EVP_ENCODE_CTX_free (EVP_ENCODE_CTX * x)
{
   if (x != NULL) {
     ICC_Free(x);
     return ICC_OSSL_SUCCESS;
   }
   return ICC_OSSL_FAILURE;
}



int EVP_MD_CTX_init(EVP_MD_CTX *ctx) 
{
  return EVP_MD_CTX_reset(ctx);
}
int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx) 
{
  return EVP_MD_CTX_reset(ctx);
}
int EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx) 
{
  return EVP_CIPHER_CTX_reset(ctx);
}
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *ctx) 
{
  return EVP_CIPHER_CTX_reset(ctx);
}
int EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx) 
{
  return EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx));
}

/*! 
  @brief
  Free an EVP_CIPHER context
  @param x pointer to an existing EVP_CIPHER context
  @return ICC_OSSL_SUCCESS or ICC_OSSL_FAILURE
*/
/* included via icclib_a.c */
static
int my_EVP_CIPHER_CTX_free(EVP_CIPHER_CTX * x)
{
     
  EVP_CIPHER_CTX_free(x);
  return ICC_OSSL_SUCCESS;
}

#undef HMAC_CTX_cleanup
int HMAC_CTX_cleanup(HMAC_CTX *ctx)
{
  return HMAC_CTX_reset(ctx);
}  

/*! @brief initializes or reuses a HMAC_CTX structure to use the;
      function evp_md and key key. Either can be NULL, in which case the;
      existing one will be reused.
 @param ctx a previously created HMAC_CTX;
 @param key the key;
 @param key_len length of the key in bytes;
 @param md A pointer to the EVP_MD structure containing the hash information;
*/

int my_HMAC_Init(HMAC_CTX *ctx, const void *key, int key_len,const EVP_MD *md)
{
  return HMAC_Init_ex(ctx,key,key_len,md,NULL);
}


/*! @brief Update phase of a CMAC operation
    @param cmac_ctx a pointer to a CMAC_CTX
    @param cipher the cipher to use
    @param key the CMAC key
    @param keylen the length of the CMAC key
    @note blocked/aligned data will be more efficient, but this will
          survive incorrectly blocked/misaligned data
*/
int my_CMAC_Init(CMAC_CTX *cmac_ctx,const EVP_CIPHER *cipher,unsigned char *key,unsigned int keylen)
{
  return CMAC_Init(cmac_ctx,key,keylen,cipher,NULL);

}
/* @brief Finish a CMAC operation and return the CMAC value;
    @param cmac_ctx a pointer to a CMAC_CTX;
    @param md a pointer to a buffer in which to store the CMAC;
    @param maclen the desired CMAC length (0 <= md_len <= Cipher block size);
    @return 1 on success, 0 on failure;
    @note a request for an overly long mac will result in an error;
*/
int my_CMAC_Final(CMAC_CTX *cmac_ctx,unsigned char *md,unsigned int maclen)
{
  size_t outlen = maclen;
  return CMAC_Final(cmac_ctx,md,&outlen);
}


/*!
  @brief
  Return a pointer to the BIGNUM inside a DH structure which contains the DH public key
  NOTE: This does NOT allocate a new BIGNUM. Do NOT free this value.
  @param dh DH context
  @return a pointer to the internal field of the DH containing the public key
*/
const BIGNUM *DH_get_PublicKey (const DH * dh)
{
   const BIGNUM *pub_key;
   DH_get0_key((DH *)dh,&pub_key,NULL);
   return pub_key;
}

/*!
  @brief
  Return a pointer to the BIGNUM inside a DH structure which contains the DH private key
  - NOTE: This does NOT allocate a new BIGNUM. Do NOT free this value.
  - I suspect this isn't needed / shouldn't be provided  
  @param dh DH context
  @return a pointer to the internal field of the DH containing the private key
*/
const BIGNUM *DH_get_PrivateKey (const DH * dh)
{
   const BIGNUM *priv_key;
   DH_get0_key((DH *)dh,NULL,&priv_key);
   return priv_key;
}

/*!
   @brief sets up digest context ctx to use the specified digest type;
   @param ctx pointer to the EVP_MD_CTX;
   @param type pointer to an EVP_MD;
   @return ICC_OSSL_SUCCESS, ICC_OSSL_FAILURE;
   @note calls EVP_DigestInitEx() which has different behaviour from EVP_DigestInit()
*/
/* included via icclib_a.c */
static
int  my_EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type)
{
  return EVP_DigestInit_ex(ctx,type,NULL);
}

/*! @brief retrieves the digest value and returns it to the requesting application.;
    @param ctx pointer to the EVP_MD_CTX;
   @param md pointer to buffer which will contain the hash;
   @param s pointer to an integer to hold the size of the hash
*/
/* included via icclib_a.c */
static
int my_EVP_DigestFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s)
{
  return EVP_DigestFinal_ex(ctx,md,s);
}

/*!
 @brief sets up cipher context ctx for encryption 
 @param ctx the cipher context to use
 @param type the cipher to use
 @param key the key to use
 @param iv the iv to use.
 @note this vectors to EVP_EncryptInit_ex() rather than EVP_EncryptInit() as this the _ex() entry point 
 is more flexible and allows us to set rc2 key length etc.
 @return ICC_OSSL_SUCCCESS, ICC_OSSL_FAILURE

*/
/* included via icclib_a.c */
static
int my_EVP_EncryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,unsigned char *key, unsigned char *iv) 
{
  return EVP_EncryptInit_ex(ctx,type,NULL,key,iv);
}

/*!
 @brief sets up cipher context ctx for encryption 
 @param ctx the cipher context to use
 @param type the cipher to use
 @param key the key to use
 @param iv the iv to use.
 @note this vectors to EVP_DecryptInit_ex() rather than EVP_DecryptInit() as this the _ex() entry point 
 is more flexible and allows us to set rc2 key length etc.
 @return ICC_OSSL_SUCCCESS, ICC_OSSL_FAILURE
*/
/* included via icclib_a.c */
static
int my_EVP_DecryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,unsigned char *key, unsigned char *iv) 
{
  return EVP_DecryptInit_ex(ctx,type,NULL,key,iv);
}


/*!
  @brief Create a new RSA context
  @param pcb the ICC library context
  @return A new RSA context or NULL on failure
*/
/* included via icclib_a.c */
static
RSA * my_RSA_new(ICClib *pcb) 
{
  RSA *rsa = NULL;

  rsa = RSA_new();

  return rsa;
} 
  
/* included via icclib_a.c */
static
int my_EVP_PKEY_decrypt(unsigned char *dec_key,unsigned char *enc_key,int enc_key_len,EVP_PKEY *private_key) {
  return EVP_PKEY_decrypt_old(dec_key,enc_key,enc_key_len,private_key);
  
}

/* included via icclib_a.c */
static
int my_EVP_PKEY_encrypt(unsigned char *enc_key,unsigned char *key,int key_len,EVP_PKEY *pub_key) {
  return EVP_PKEY_encrypt_old(enc_key,key,key_len,pub_key);
} 
/* Tolerate NUMM status here because it was ignored for a long long time */
void GenerateRandomSeed(ICClib *pcb, ICC_STATUS *status,int num, unsigned char *buff) {
  if(NULL != status) {
    SetStatusOK(pcb,status);
  }  
  if(0 == my_GenerateRandomSeed(num,buff) )
  {
    if(NULL != status) {
      SetStatusLn(pcb,status,ICC_ERROR,ICC_DISABLED,(char *)"RNG seed source failed",__FILE__,__LINE__);
    }   
  }	  
}

static
int my_RSA_generate_key_ex(ICClib* pcb, RSA* rsa, int bits, BIGNUM* e, void* callback);

/* included via icclib_a.c */
static
RSA *  my_RSA_generate_key(ICClib *pcb,int bits, unsigned long e,void (*callback)(int,int,void *),void *cb_arg)
{
  RSA *rsa = NULL;
  BIGNUM *ebn = NULL;
  int i = 0;

  rsa = RSA_new();
  ebn = BN_new();
  if ((NULL != rsa) && (NULL != ebn))
  {
    for (i = 0; i < (int)sizeof(e) * 8; i++)
    {
      if (e & (1UL << i))
      {
        BN_set_bit(ebn, i);
      }
    }

    if (1 != my_RSA_generate_key_ex(pcb, rsa, bits, ebn, NULL))
    {
      RSA_free(rsa);
      rsa = NULL;
    }
    BN_clear_free(ebn);
  }
  return rsa;
}
/*
  Note: We use this code in both FIPS and non-FIPS modes so the policy checks that were 
  in OpenSSL are lifted and done at this level instead
  i.e. valid FIPS key size range and minimum exponent size

*/

/* included via icclib_a.c */
static
int my_RSA_generate_key_ex(ICClib *pcb, RSA *rsa, int bits, BIGNUM *e, void *callback)
{
  int rv = 1;
  int nid = 0;
  int fips = 0;
  BIGNUM *elim = NULL;
  /* Overall sanity check, the KeyPair check has a fixed length buffer but this is sane even in non-FIPS mode  */
  if (bits < 512 || bits > 16384)
  {
    rv = 0;
  }
  /* Unlike OpenSSL, we make the policy decisions, key size, exponent at this level 
    and are more permissive if not in FIPS mode.
  */
  if ((1 == rv) && (pcb->flags & ICC_FIPS_FLAG))
  {
    elim = BN_new();
    BN_set_word(elim, 0x10001);
    if ((bits < 2048) || (bits > 8192) || (BN_cmp(e, elim) < 0) || !BN_is_odd(e) || (BN_num_bits(e) > 256))
    {
      rv = 0;
    }
    BN_free(elim);
  }
  if (1 == rv)
  {
    RAND_seed(NULL,0); /* Reseed the RNG before keygen */
    rv = RSA_generate_key_ex(rsa, bits, e, callback);
  }

  if ((1 == rv) && (pcb->flags & ICC_FIPS_FLAG))
  {
    /* The RSA size check here is to cater for the NIST test case where the key is preloaded with P&Q 
      keygen isn't actually done so rsa->n is 0 length. 
      The key isn't usable but this borked key has to pass to get through FIPS
    */
    if (ICC_OK != iccRSAKeyPair(pcb, rsa))
    {
      rv = 0;
    }
    else
    {
      fips = 1;
    }
  }
  if (1 == rv)
  {
    if (NULL != pcb->callback)
    {
      nid = 19;
      (*pcb->callback)("ICC_RSA_generate_key_ex", nid, fips);
    }
  }
  return rv;
}

/* included via icclib_a.c */
static
DH * my_DH_generate_parameters(ICClib *pcb,int bits, int generator,void (*callback)(int,int,void *),void *cb_arg)
{
  DH *temp = NULL;
  temp = DH_generate_parameters(bits, generator,callback,cb_arg);
  if((NULL != pcb->callback) && (NULL != temp)) {
    (*pcb->callback)("ICC_DH_generate_parameters",946,0); /* Never FIPS compliant */
  }
  return temp;
}
/* included via icclib_a.c */
static
DSA * my_DSA_generate_parameters(ICClib *pcb,int bits,unsigned char *seed,int seed_len,int *counter_ret, unsigned long *h_ret,void (*callback)(int, int, void *),void *cb_arg)
{
  DSA *temp = NULL;
  RAND_seed(NULL,0); /* Reseed the RNG before keygen */
  temp = DSA_generate_parameters(bits,seed,seed_len,counter_ret,h_ret,callback,cb_arg);
  if((NULL != pcb->callback) && (NULL != temp)) {
    (*pcb->callback)("ICC_DSA_generate_parameters",116,0); /* Never FIPS compliant */
  }
  return temp; 

}
/* included via icclib_a.c */
static
int my_DSA_generate_key(ICClib *pcb, DSA *a) {
  int temp = ICC_FAILURE;

  int i = 0;
  if ((NULL != pcb) && !((pcb->flags & ICC_FIPS_FLAG) && getErrorState())) {
    RAND_seed(NULL,0); /* Reseed the RNG before keygen */
    temp = DSA_generate_key(a);
    if (pcb->flags & ICC_FIPS_FLAG) {
      if (NULL != a) {
        for (i = 0; i < 5; i++) {
          if ((NULL == a->pub_key) ||
              (((BN_num_bits(a->pub_key) + 7) / 8) < (1024 / 8)) ||
              (ICC_OK != iccDSAPairTest(pcb, a))) {
            temp = DSA_generate_key(a);
          } else {
            break;
          }
        }
        if (5 == i) {
          if (a->pub_key != NULL) {
            BN_clear_free(a->pub_key);
            a->pub_key = NULL;
          }
          if (a->priv_key != NULL) {
            BN_clear_free(a->priv_key);
            a->priv_key = NULL;
          }
          temp = ICC_FAILURE;
        }
      }
    }
    if((NULL != pcb->callback) && (0 != temp)) {
      (*pcb->callback)("ICC_DSA_generate_key",116,0); /* Never FIPS compliant */
    }
  }
  return temp;
}
/* included via icclib_a.c */
static
EC_KEY *my_EC_KEY_new_by_curve_name(ICClib *pcb,int nid)
{
  EC_KEY *temp = NULL;
  int fips = 0;
  temp = EC_KEY_new_by_curve_name(nid);
  if(NULL != temp) {
    switch (nid)
    {
    case 713: /* secp224r1  P-224 */
    case 415: /* prime256v1 P-256 */
    case 715: /* secp384r1  P-384 */
    case 716: /* secp521r1  P-521 */
    case 726: /* sect233k1  K-233 */
    case 727: /* sect233r1  B-233 */
    case 729: /* sect283k1  K-283 */
    case 730: /* sect283r1  B-283 */
    case 731: /* sect409k1  K-409 */
    case 732: /* sect409r1  B-409 */
    case 733: /* sect571k1  K-571 */
    case 734: /* sect571r1  B-571 */
      fips = 1;
      break;
    default:
      break;
    }
    if(NULL != pcb->callback) {
      (*pcb->callback)("ICC_EC_KEY_new_by_curve_name",nid,fips);
    } 
  }
  return temp;
}
/* included via icclib_a.c */
static
int my_EC_KEY_generate_key(ICClib *pcb, EC_KEY *eckey) {
  int temp = ICC_FAILURE;
  if ((NULL != pcb) && !((pcb->flags & ICC_FIPS_FLAG) && getErrorState())) {
    RAND_seed(NULL,0); /* Reseed the RNG before keygen */
    temp = EC_KEY_generate_key(eckey);
    if (pcb->flags & ICC_FIPS_FLAG) {
      if ((((ECDSA_size(eckey) - 8) / 2) < 20) ||
          (ICC_OK != iccECKEYPairTest(pcb, eckey))) {
        temp = (int)ICC_FAILURE;
      }
    }
  }
  return temp;
}


/* included via icclib_a.c */
static
int my_RAND_bytes(unsigned char *buf,int n)
{
  int rv = 0;
  rv = RAND_pseudo_bytes(buf,n);
  return rv;
}
/* included via icclib_a.c */
static
int my_EVP_PKEY_decrypt_new(EVP_PKEY_CTX *ctx, 
			    unsigned char *out, size_t *outlen,
			    const unsigned char *in, size_t inlen) {
  return EVP_PKEY_decrypt(ctx,out,outlen,in,inlen);  
}

/* included via icclib_a.c */
static
int my_EVP_PKEY_encrypt_new(EVP_PKEY_CTX *ctx, 
			    unsigned char *out, size_t *outlen,
			    const unsigned char *in, size_t inlen) {
  return EVP_PKEY_encrypt(ctx,out,outlen,in,inlen);  
}


/* Kyber, dilitium and sphincs call this. liboqs call OQS_randombytes which also ends up here */
/* redirect to our ICC TRNG or whatever is configured */
/* Note: ICC_RAND_bytes uses my_RAND_bytes */
int
randombytes(uint8_t* x, unsigned long xlen)
{
#if 1
   /* this is pseudo rand */
   int rv = my_RAND_bytes(x, (int)xlen);
#else
   /* TRNG */
   static PRNG_CTX* pctx = NULL;
   if (!pctx) {
      pctx = RNG_CTX_new();
/*  ??    RNG_CTX_Init(pctx, ...);*/
   }
   int rv = RNG_Generate(pctx, x, xlen, NULL, 0);
#endif
   return rv;
}


#ifdef LIBOQS

#include "oqs/common.h"
#include "oqs/kem.h"

/* The code was originally written for LIBOQS so the least mapping is required in that case */

typedef OQS_KEM ICC_KEM;
typedef OQS_SIG ICC_SIG;

#define ICC_KEM_new OQS_KEM_new
#define ICC_SIG_new OQS_SIG_new
#define ICC_KEM_free OQS_KEM_free
#define ICC_SIG_free OQS_SIG_free
#define ICC_KEM_keypair OQS_KEM_keypair
#define ICC_SIG_keypair OQS_SIG_keypair
#define ICC_KEM_encaps OQS_KEM_encaps
#define ICC_KEM_decaps OQS_KEM_decaps
#define ICC_SIG_sign OQS_SIG_sign
#define ICC_SIG_verify OQS_SIG_verify


#else

/* scraped from LIBOQS */

typedef enum {
   /** Used to indicate that some undefined error occurred. */
   OQS_ERROR = -1,
   /** Used to indicate successful return from function. */
   OQS_SUCCESS = 0,
   /** Used to indicate failures in external libraries (e.g., OpenSSL). */
   OQS_EXTERNAL_LIB_ERROR_OPENSSL = 50,
} OQS_STATUS;

struct _ICC_KEM {
   const char* method_name;

   size_t length_public_key;
   size_t length_secret_key;
   size_t length_ciphertext;
   size_t length_shared_secret;

   OQS_STATUS(*keypair)(uint8_t* public_key, uint8_t* secret_key);
   OQS_STATUS(*encaps)(uint8_t* ciphertext, uint8_t* shared_secret, const uint8_t* public_key);
   OQS_STATUS(*decaps)(uint8_t* shared_secret, const uint8_t* ciphertext, const uint8_t* secret_key);
};
typedef struct _ICC_KEM ICC_KEM;

typedef struct _ICC_SIG {
   const char* method_name;

   size_t length_public_key;
   size_t length_secret_key;
   size_t length_signature;

   OQS_STATUS(*keypair)(uint8_t* public_key, uint8_t* secret_key);
   OQS_STATUS(*sign)(uint8_t* signature, size_t* signature_len, const uint8_t* message, size_t message_len, const uint8_t* secret_key);
   OQS_STATUS(*verify)(const uint8_t* message, size_t message_len, const uint8_t* signature, size_t signature_len, const uint8_t* public_key);
} ICC_SIG;

static int ICC_KEM_encaps(ICC_KEM* kc, void* wrappedkey, void* genkey, void* pkc);
static int ICC_KEM_decaps(ICC_KEM* kc, void* unwrapped, const void* wrapped, const void* skc);
static int ICC_SIG_sign(ICC_SIG* sc, void* sig, size_t* len, const void* tbs, size_t tbslen, void* skc);
static int ICC_SIG_verify(ICC_SIG* sc, const void* tbs, size_t tbslen, const void* sig, size_t siglen, void* pkc);
static ICC_KEM* ICC_KEM_new(const char* a);
static ICC_SIG* ICC_SIG_new(const char* a);

#endif

/*
* Kyber or Dilithium key pair.
*/
struct PQC_EVP_PKEY_s {
   unsigned char* pkc; /* public */
   size_t pkcLen;
   unsigned char* skc; /* private */
   size_t skcLen;
   ICC_KEM* kc;
   ICC_SIG* sc;
   void* pq_ctx;
   void* (* newctx)(const char* a);
   void (*freectx)(void* x);
};
typedef struct PQC_EVP_PKEY_s PQC_EVP_PKEY;


#ifdef LIBDKS

#include "kyber/ref/api.h"
/* both define the same guard */
#undef API_H
#include "dilithium/ref/api.h"

/* sphincs is not so well namespaced */
/* so we have to undo definitions each time before redefining for a new algorith variant* /
/* we are including the same header file with different namespacing so undef some clashing names */
/* api.h includes params/params-...h so both header protections must be reset */

#define PARAMS sphincs-shake-128s
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-shake-128f
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-shake-192s
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-shake-192f
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-shake-256s
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-shake-256f
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-sha2-128s
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-sha2-128f
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-sha2-192s
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-sha2-192f
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-sha2-256s
#include "sphincs/ref/api.h"

#undef SPX_API_H
#undef SPX_PARAMS_H
#undef SPX_NAMESPACE

#undef SPX_FULL_HEIGHT
#undef SPX_D
#undef SPX_N
#undef SPX_FORS_HEIGHT
#undef SPX_FORS_TREES

#undef PARAMS
#define PARAMS sphincs-sha2-256f
#include "sphincs/ref/api.h"


/* remove this to avoid namespace problems */
#define PQC_SHPINCS_SHA2


/* convert all the Kyber length definitions into OQS matching variants */
#define defpk(n) static const int OQS_KEM_kyber_ ## n ## _length_public_key = pqcrystals_kyber ## n ## _PUBLICKEYBYTES;
#define defsk(n) static const int OQS_KEM_kyber_ ## n ## _length_secret_key = pqcrystals_kyber ## n ## _ref_SECRETKEYBYTES;
#define defck(n) static const int OQS_KEM_kyber_ ## n ## _length_ciphertext = pqcrystals_kyber ## n ## _CIPHERTEXTBYTES;
#define defss(n) static const int OQS_KEM_kyber_ ## n ## _length_shared_secret = pqcrystals_kyber ## n ## _BYTES;
defpk(512)
defsk(512)
defck(512)
defss(512)
defpk(768)
defsk(768)
defck(768)
defss(768)
defpk(1024)
defsk(1024)
defck(1024)
defss(1024)

/* KEM Kyber API functions */
#define defkf(n) \
static OQS_STATUS OQS_KEM_kyber_ ## n ## _keypair(uint8_t* public_key, uint8_t* secret_key) \
{ if (pqcrystals_kyber ## n ## _ref_keypair(public_key, secret_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; } \
static OQS_STATUS OQS_KEM_kyber_ ## n ## _encaps(uint8_t* ciphertext, uint8_t* shared_secret, const uint8_t* public_key) \
{ if (pqcrystals_kyber ## n ## _ref_enc(ciphertext, shared_secret, public_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; } \
OQS_STATUS OQS_KEM_kyber_ ## n ## _decaps(uint8_t* shared_secret, const uint8_t* ciphertext, const uint8_t* secret_key) \
{ if (pqcrystals_kyber ## n ## _ref_dec(shared_secret, ciphertext, secret_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; }
defkf(512)
defkf(768)
defkf(1024)

/* Dilithium length definitions */

#define OQS_SIG_dilithium_2_length_public_key pqcrystals_dilithium2_PUBLICKEYBYTES
#define OQS_SIG_dilithium_2_length_secret_key pqcrystals_dilithium2_SECRETKEYBYTES
#define OQS_SIG_dilithium_2_length_signature pqcrystals_dilithium2_BYTES
#define OQS_SIG_dilithium_3_length_public_key pqcrystals_dilithium3_PUBLICKEYBYTES
#define OQS_SIG_dilithium_3_length_secret_key pqcrystals_dilithium3_SECRETKEYBYTES
#define OQS_SIG_dilithium_3_length_signature pqcrystals_dilithium3_BYTES
#define OQS_SIG_dilithium_5_length_public_key pqcrystals_dilithium5_PUBLICKEYBYTES
#define OQS_SIG_dilithium_5_length_secret_key pqcrystals_dilithium5_SECRETKEYBYTES
#define OQS_SIG_dilithium_5_length_signature pqcrystals_dilithium5_BYTES

/* SIG API Dilithium functions */

#define defdf(n) \
OQS_STATUS OQS_SIG_dilithium_ ## n ## _keypair(uint8_t* public_key, uint8_t* secret_key) \
{ if (pqcrystals_dilithium ## n ## _ref_keypair(public_key, secret_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; } \
OQS_STATUS OQS_SIG_dilithium_ ## n ## _sign(uint8_t* signature, size_t* signature_len, const uint8_t* message, size_t message_len, const uint8_t* secret_key) \
{ \
   const uint8_t* ctx = NULL; \
   size_t ctxlen = 0; \
   if (pqcrystals_dilithium ## n ## _ref_signature(signature, signature_len, message, message_len, ctx, ctxlen, secret_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; \
} \
OQS_STATUS OQS_SIG_dilithium_ ## n ## _verify(const uint8_t* message, size_t message_len, const uint8_t* signature, size_t signature_len, const uint8_t* public_key) \
{ \
      const uint8_t* ctx = NULL; \
      size_t ctxlen = 0; \
      if (pqcrystals_dilithium ## n ## _ref_verify(signature, signature_len, message, message_len, ctx, ctxlen, public_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; \
}
defdf(2)
defdf(3)
defdf(5)

/* Sphincs */

/* this is what is inside the sphincs headers so we match it here in our wrapper functions */
/* #define SPX_NAMESPACE(s) SPX_SHAKE_128s_##s */

/* SIG API Shpincs functions */

#define defsf(n, d) \
OQS_STATUS OQS_SIG_sphincs_ ## d ## _ ## n ## _keypair(uint8_t* public_key, uint8_t* secret_key) \
{ if (SPX_ ## d ## _ ## n ## _crypto_sign_keypair(public_key, secret_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; } \
OQS_STATUS OQS_SIG_sphincs_ ## d ## _ ## n ## _sign(uint8_t* signature, size_t* signature_len, const uint8_t* message, size_t message_len, const uint8_t* secret_key) \
{ if (SPX_ ## d ## _ ## n ## _crypto_sign_signature(signature, signature_len, message, message_len, secret_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; } \
OQS_STATUS OQS_SIG_sphincs_ ## d ## _ ## n ## _verify(const uint8_t* message, size_t message_len, const uint8_t* signature, size_t signature_len, const uint8_t* public_key) \
{ if (SPX_ ## d ## _ ## n ## _crypto_sign_verify(signature, signature_len, message, message_len, public_key) == 0) return OQS_SUCCESS; else return OQS_ERROR; }
defsf(128s, SHAKE)
defsf(128f, SHAKE)
defsf(192s, SHAKE)
defsf(192f, SHAKE)
defsf(256s, SHAKE)
defsf(256f, SHAKE)
#ifdef PQC_SHPINCS_SHA2
defsf(128s, SHA2)
defsf(128f, SHA2)
defsf(192s, SHA2)
defsf(192f, SHA2)
defsf(256s, SHA2)
defsf(256f, SHA2)
#endif

#endif


#if defined(LIBOQS) || defined(LIBDKS)

static void pqc_pkey_free(EVP_PKEY* pkey);
static int i2d_PQCPublicKey(const EVP_PKEY* pk, unsigned char** pp);
static int i2d_PQCPrivateKey(const EVP_PKEY* pk, unsigned char** pp);
static int pqc_pub_encode(X509_PUBKEY* pk, const EVP_PKEY* pkey);
static int pqc_pri_encode(PKCS8_PRIV_KEY_INFO* p8, const EVP_PKEY* pkey);
static int d2i_PQCPublicKey(EVP_PKEY* pkey, const unsigned char** pp, long length);
static int d2i_PQCPrivateKey(EVP_PKEY* pkey, const unsigned char** pp, long length);
static int pqc_pub_decode(EVP_PKEY* pkey, X509_PUBKEY* pubkey);
static int pqc_pri_decode(EVP_PKEY* pkey, const PKCS8_PRIV_KEY_INFO* p8inf);
static int pqc_pub_cmp(const EVP_PKEY* a, const EVP_PKEY* b);
static int pqc_pub_size(const EVP_PKEY* a);
static int pqc_pub_bits(const EVP_PKEY* a);
static int pqc_old_priv_decode (EVP_PKEY* pkey, const unsigned char** pder, int derlen);
static int pqc_old_priv_encode (const EVP_PKEY* pkey, unsigned char** pder);
static const char* id2meth(int k);
static PQC_EVP_PKEY* new_pqc_key(int type);
static int isEVPKyber(int id);

static
EVP_PKEY_ASN1_METHOD kyber512_pkey_asn1_meth =
{
     0, /* pkey_id */
     0, /* pkey_base_id */
     ASN1_PKEY_SIGPARAM_NULL,

     "Kyber",
#ifdef LIBOQS
     "ICCEVP/LIBOQS Kyber method",
#else
     "ICCEVP Kyber method",
#endif

     pqc_pub_decode,
     pqc_pub_encode,
     pqc_pub_cmp,
     0, /* rsa_pub_print, */

     pqc_pri_decode, /* rsa_priv_decode, */
     pqc_pri_encode, /* rsa_priv_encode, */
     0, /* rsa_priv_print, */

     pqc_pub_size,
     pqc_pub_bits,
     0, /* sa_security_bits, */

     0, 0, /* param_decode, param_encode */
     0, 0, /* param_missing, param_copy */
     0, 0, /* param_cmp, param_print */

     0, /* rsa_sig_print, */
     pqc_pkey_free,
     0, /* rsa_pkey_ctrl, */
     pqc_old_priv_decode, pqc_old_priv_encode,
     0, /* rsa_item_verify, */
     0, /* rsa_item_sign, */
     0,
     0 /* rsa_pkey_check */
/*
    int (*set_priv_key) (EVP_PKEY *pk, const unsigned char *priv, size_t len);
    int (*set_pub_key) (EVP_PKEY *pk, const unsigned char *pub, size_t len);
    int (*get_priv_key) (const EVP_PKEY *pk, unsigned char *priv, size_t *len);
    int (*get_pub_key) (const EVP_PKEY *pk, unsigned char *pub, size_t *len);
*/
};

static
EVP_PKEY_ASN1_METHOD kyber768_pkey_asn1_meth;
static
EVP_PKEY_ASN1_METHOD kyber1024_pkey_asn1_meth;

static
EVP_PKEY_ASN1_METHOD dilithium_pkey_asn1_meth =
{
     0, /* pkey_id */
     0, /* pkey_base_id */
     ASN1_PKEY_SIGPARAM_NULL,

     "DILITHIUM_512",
#ifdef LIBOQS
     "ICCEVP/LIBOQS Dilithium method",
#else
     "ICCEVP Dilithium method",
#endif

     pqc_pub_decode,
     pqc_pub_encode,
     pqc_pub_cmp,
     0, /* rsa_pub_print, */

     pqc_pri_decode, /* rsa_priv_decode, */
     pqc_pri_encode, /* rsa_priv_encode, */
     0, /* rsa_priv_print, */

     pqc_pub_size,
     pqc_pub_bits,
     0, /* rsa_security_bits, */

     0, 0, /* param_decode, param_encode */
     0, 0, /* param_missing, param_copy */
     0, 0, /* param_cmp, param_print */

     0, /* rsa_sig_print, */
     pqc_pkey_free,
     0, /* rsa_pkey_ctrl, */
     pqc_old_priv_decode, pqc_old_priv_encode,
     0, /* rsa_item_verify, */
     0, /* rsa_item_sign, */
     0,
     0 /* rsa_pkey_check */
};

static
EVP_PKEY_ASN1_METHOD dilithium768_pkey_asn1_meth;
static
EVP_PKEY_ASN1_METHOD dilithium1024_pkey_asn1_meth;

static
EVP_PKEY_ASN1_METHOD sphincs128s_shake_pkey_asn1_meth =
{
     0, /* pkey_id */
     0, /* pkey_base_id */
     ASN1_PKEY_SIGPARAM_NULL,

     "Sphincs",
#ifdef LIBOQS
     "ICCEVP/LIBOQS Sphincs method",
#else
     "ICCEVP Sphincs method",
#endif

     pqc_pub_decode,
     pqc_pub_encode,
     pqc_pub_cmp,
     0, /* rsa_pub_print, */

     pqc_pri_decode, /* rsa_priv_decode, */
     pqc_pri_encode, /* rsa_priv_encode, */
     0, /* rsa_priv_print, */

     pqc_pub_size,
     pqc_pub_bits,
     0, /* rsa_security_bits, */

     0, 0, 0, 0, 0, 0,

     0, /* rsa_sig_print, */
     pqc_pkey_free,
     0, /* rsa_pkey_ctrl, */
     0, 0,
     0, /* rsa_item_verify, */
     0, /* rsa_item_sign, */
     0,
     0 /* rsa_pkey_check */
};

static EVP_PKEY_ASN1_METHOD sphincs128f_shake_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs192s_shake_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs192f_shake_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs256s_shake_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs256f_shake_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs128s_sha2_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs128f_sha2_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs192s_sha2_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs192f_sha2_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs256s_sha2_pkey_asn1_meth;
static EVP_PKEY_ASN1_METHOD sphincs256f_sha2_pkey_asn1_meth;

/* Note: Returns match libcrypto conventions */

static
int pqc_pub_encode(X509_PUBKEY* pubk, const EVP_PKEY* pkey)
{
   unsigned char* penc = NULL;
   unsigned char* pp = NULL;
   int penclen;
   ASN1_STRING* str = NULL;
   int strtype = V_ASN1_NULL;

   /* no parameters */
/*
   if (!pqc_param_encode(pkey, &str, &strtype))
      return 0;
*/
   penclen = i2d_PQCPublicKey(pkey, NULL);
   if (penclen <= 0) {
      ASN1_STRING_free(str);
      return 0;
   }
   pp = penc = OPENSSL_malloc(penclen);
   penclen = i2d_PQCPublicKey(pkey, &pp);
   if (X509_PUBKEY_set0_param(pubk, OBJ_nid2obj(pkey->ameth->pkey_id),
      strtype, str, penc, penclen))
      return 1;

   OPENSSL_free(penc);
   ASN1_STRING_free(str);
   return 0;
}

static
int pqc_pub_decode(EVP_PKEY* pkey, X509_PUBKEY* pubkey)
{
   const unsigned char* p = NULL;
   int pklen = 0;
   ASN1_OBJECT* ppkalg = NULL;
   X509_ALGOR* alg = NULL;

   if (!X509_PUBKEY_get0_param(&ppkalg, &p, &pklen, &alg, pubkey))
      return 0;
   {
      if (!d2i_PQCPublicKey(pkey, &p, pklen)) {
         /*      RSAerr(RSA_F_RSA_PUB_DECODE, ERR_R_RSA_LIB); */
         return 0;
      }
   }
   return 1;
}

static int pqc_pri_encode(PKCS8_PRIV_KEY_INFO* p8, const EVP_PKEY* pkey)
{
   unsigned char* penc = NULL;
   unsigned char* pp = NULL;
   int penclen;
   ASN1_STRING* str = NULL;
   int strtype = V_ASN1_NULL;
   int version = 0;

   /* no parameters */
   penclen = i2d_PQCPrivateKey(pkey, NULL);
   if (penclen <= 0) {
      ASN1_STRING_free(str);
      return 0;
   }
   pp = penc = OPENSSL_malloc(penclen);
   penclen = i2d_PQCPrivateKey(pkey, &pp);
   if (PKCS8_pkey_set0(p8, OBJ_nid2obj(pkey->ameth->pkey_id), version, strtype, str, penc, penclen))
   {
      return 1;
   }

   OPENSSL_free(penc);
   ASN1_STRING_free(str);
   return 0;
}

static int pqc_pri_decode(EVP_PKEY* pkey, const PKCS8_PRIV_KEY_INFO* p8inf)
{
   const unsigned char* p = NULL;
   int pklen = 0;
   const ASN1_OBJECT* ppkalg = NULL;
   const X509_ALGOR* alg = NULL;

   if (!PKCS8_pkey_get0(&ppkalg, &p, &pklen, &alg, p8inf))
      return 0;
   if (!d2i_PQCPrivateKey(pkey, &p, pklen)) {
      /*      RSAerr(RSA_F_RSA_PUB_DECODE, ERR_R_RSA_LIB); */
      return 0;
   }
   return 1;
}

static
int pqc_pub_cmp(const EVP_PKEY* a, const EVP_PKEY* b)
{
   const PQC_EVP_PKEY* ak = (const PQC_EVP_PKEY*)a->pkey.ptr;
   const PQC_EVP_PKEY* bk = (const PQC_EVP_PKEY*)b->pkey.ptr;
   if (!ak || !bk)
      return 0;

   /* only compare public keys if both are present */
   if (ak->pkcLen && bk->pkcLen && (ak->pkcLen != bk->pkcLen || memcmp(ak->pkc, bk->pkc, ak->pkcLen) != 0))
      return 0;
   /* only compare private keys if both are present */
   if ((ak->skcLen && bk->skcLen) && (ak->skcLen != bk->skcLen || memcmp(ak->skc, bk->skc, ak->skcLen) != 0))
      return 0;

   if ((ak->pkcLen && bk->pkcLen) || (ak->skcLen && bk->skcLen) || (!ak->pkcLen && !bk->pkcLen && !ak->skcLen && !bk->skcLen)) {
      /* we checked at least one pair or everything is 0 */
      return 1;
   }

   /* neither were checked */
   return 0;
}

static int pqc_pub_size(const EVP_PKEY* a)
{
   const PQC_EVP_PKEY* pk = (const PQC_EVP_PKEY*)a->pkey.ptr;

   if (!pk)
      return 0;

   return (int)(pk->kc ? pk->kc->length_public_key : pk->sc->length_public_key);
}

static int pqc_pub_bits(const EVP_PKEY* a)
{
   return (int)(pqc_pub_size(a) * 8);
}

static int pqc_old_priv_decode(EVP_PKEY* pkey, const unsigned char** pder, int derlen)
{
   return d2i_PQCPrivateKey(pkey, pder, derlen);
}
static int pqc_old_priv_encode(const EVP_PKEY* pkey, unsigned char** pder)
{
   return i2d_PQCPrivateKey(pkey, pder);
}

static
int d2i_PQCPublicKey(EVP_PKEY* pkey, const unsigned char** pp, long length)
{
   if (!pkey) {
      return 0;
   }
   {
      PQC_EVP_PKEY* pk = pkey->pkey.ptr;
      if (!pk) {
         pk = new_pqc_key(pkey->type);
         if (!pk) {
            return 0;
         }
         pkey->pkey.ptr = pk;
      }

      if (!pp || !*pp) {
         return 0;
      }
      {
         ASN1_BIT_STRING* os = ASN1_BIT_STRING_new();
         os = d2i_ASN1_BIT_STRING(&os, pp, length);
         if (!os)
            return 0;

         pk->pkcLen = os->length;
         pk->pkc = ICC_Malloc(os->length, __FILE__, __LINE__);
         if (!pk->pkc)
            return 0;
         memcpy(pk->pkc, os->data, os->length);
         ASN1_BIT_STRING_free(os);
      }
   }

   return 1;
}

/* return encoded length or < 0 for error */
/* caller needs to supply buffer */
/* update pp to point to follow the encoding */

static
int i2d_PQCPublicKey(const EVP_PKEY* pkey, unsigned char** pp)
{
   int len = 0;

   if (!pkey)
      return 0;

   {
      const PQC_EVP_PKEY* pk = (const PQC_EVP_PKEY*)pkey->pkey.ptr;
      if (!pk)
         return -1;

      {
         ASN1_BIT_STRING* os = ASN1_BIT_STRING_new();
         if (os == NULL)
            return 0;

         if (!ASN1_BIT_STRING_set(os, pk->pkc, (int)pk->pkcLen)) {
            ASN1_BIT_STRING_free(os);
            return 0;
         }
         len = i2d_ASN1_BIT_STRING(os, pp);
         ASN1_BIT_STRING_free(os);
      }
   }
   return len;
}

static
int i2d_PQCPrivateKey(const EVP_PKEY* pkey, unsigned char** pp)
{
   int len;

   if (!pkey)
      return 0;

   {
      const PQC_EVP_PKEY* pk = (const PQC_EVP_PKEY*)pkey->pkey.ptr;

      if (!pk)
         return 0;

      {
         ASN1_OCTET_STRING* os = ASN1_OCTET_STRING_new();
         if (os == NULL)
            return 0;

         if (!ASN1_OCTET_STRING_set(os, pk->skc, (int)pk->skcLen)) {
            ASN1_OCTET_STRING_free(os);
            return 0;
         }
         len = i2d_ASN1_OCTET_STRING(os, pp);

         ASN1_OCTET_STRING_free(os);
      }
   }
   return len;
}

static
int
d2i_PQCPrivateKey(EVP_PKEY* pkey, const unsigned char** pp, long length)
{
   PQC_EVP_PKEY* pk = pkey->pkey.ptr;
   if (!pk) {
      pk = new_pqc_key(pkey->type);
      if (!pk) {
         return 0;
      }
      pkey->pkey.ptr = pk;
   }
   if (!pp || !*pp) {
      return 0;
   }

   {
      ASN1_OCTET_STRING* os = ASN1_OCTET_STRING_new();
      os = d2i_ASN1_OCTET_STRING(&os, pp, length);
      if (!os)
         return 0;

      pk->skcLen = os->length;
      pk->skc = ICC_Malloc(pk->skcLen, __FILE__, __LINE__);
      if (!pk->skc)
         return 0;
      memcpy(pk->skc, os->data, os->length);
      ASN1_OCTET_STRING_free(os);
   }

   return 1;
}


#ifdef LIBOQS
#define ICC_KEM_alg_kyber_512 OQS_KEM_alg_kyber_512
#define ICC_KEM_alg_kyber_768 OQS_KEM_alg_kyber_768
#define ICC_KEM_alg_kyber_1024 OQS_KEM_alg_kyber_1024
#else
#define ICC_KEM_alg_kyber_512 "kyber_512"
#define ICC_KEM_alg_kyber_768 "kyber_768"
#define ICC_KEM_alg_kyber_1024 "kyber_1024"
#endif

#ifdef LIBOQS
#define ICC_SIG_alg_dilithium_2 OQS_SIG_alg_dilithium_2
#define ICC_SIG_alg_dilithium_3 OQS_SIG_alg_dilithium_3
#define ICC_SIG_alg_dilithium_5 OQS_SIG_alg_dilithium_5
#else
#define ICC_SIG_alg_dilithium_2 "dilithium_2"
#define ICC_SIG_alg_dilithium_3 "dilithium_3"
#define ICC_SIG_alg_dilithium_5 "dilithium_5"
#endif

#ifdef LIBOQS
#define ICC_SIG_alg_sphincs_SHAKE_128s_simple OQS_SIG_alg_sphincs_shake_128s_simple
#define ICC_SIG_alg_sphincs_SHAKE_192s_simple OQS_SIG_alg_sphincs_shake_192s_simple
#define ICC_SIG_alg_sphincs_SHAKE_256s_simple OQS_SIG_alg_sphincs_shake_256s_simple
#define ICC_SIG_alg_sphincs_SHAKE_128f_simple OQS_SIG_alg_sphincs_shake_128f_simple
#define ICC_SIG_alg_sphincs_SHAKE_192f_simple OQS_SIG_alg_sphincs_shake_192f_simple
#define ICC_SIG_alg_sphincs_SHAKE_256f_simple OQS_SIG_alg_sphincs_shake_256f_simple
#define ICC_SIG_alg_sphincs_SHA2_128s_simple OQS_SIG_alg_sphincs_sha2_128s_simple
#define ICC_SIG_alg_sphincs_SHA2_192s_simple OQS_SIG_alg_sphincs_sha2_192s_simple
#define ICC_SIG_alg_sphincs_SHA2_256s_simple OQS_SIG_alg_sphincs_sha2_256s_simple
#define ICC_SIG_alg_sphincs_SHA2_128f_simple OQS_SIG_alg_sphincs_sha2_128f_simple
#define ICC_SIG_alg_sphincs_SHA2_192f_simple OQS_SIG_alg_sphincs_sha2_192f_simple
#define ICC_SIG_alg_sphincs_SHA2_256f_simple OQS_SIG_alg_sphincs_sha2_256f_simple
#else
#define ICC_SIG_alg_sphincs_SHAKE_128s_simple "sphincs_shake_128s_simple"
#define ICC_SIG_alg_sphincs_SHAKE_192s_simple "sphincs_shake_192s_simple"
#define ICC_SIG_alg_sphincs_SHAKE_256s_simple "sphincs_shake_256s_simple"
#define ICC_SIG_alg_sphincs_SHAKE_128f_simple "sphincs_shake_128f_simple"
#define ICC_SIG_alg_sphincs_SHAKE_192f_simple "sphincs_shake_192f_simple"
#define ICC_SIG_alg_sphincs_SHAKE_256f_simple "sphincs_shake_256f_simple"
#define ICC_SIG_alg_sphincs_SHA2_128s_simple "sphincs_sha2_128s_simple"
#define ICC_SIG_alg_sphincs_SHA2_192s_simple "sphincs_sha2_192s_simple"
#define ICC_SIG_alg_sphincs_SHA2_256s_simple "sphincs_sha2_256s_simple"
#define ICC_SIG_alg_sphincs_SHA2_128f_simple "sphincs_sha2_128f_simple"
#define ICC_SIG_alg_sphincs_SHA2_192f_simple "sphincs_sha2_192f_simple"
#define ICC_SIG_alg_sphincs_SHA2_256f_simple "sphincs_sha2_256f_simple"
#endif

static int pkey_kyber_init(EVP_PKEY_CTX* ctx)
{
   int rv = 1;
   return rv;
}
static int pkey_kyber_copy(EVP_PKEY_CTX* dst, EVP_PKEY_CTX* src)
{
   int rv = 0;
   return rv;
}

#ifdef LIBDKS

static
ICC_KEM*
ICC_KEM_new(const char* a)
{
   ICC_KEM* kem = ICC_Malloc(sizeof(ICC_KEM), __FILE__, __LINE__);
   if (kem) {
      if (strcmp(a, ICC_KEM_alg_kyber_512) == 0) {
         kem->method_name = ICC_KEM_alg_kyber_512;
         /*kem->alg_version = "https://github.com/pq-crystals/kyber/tree/standard"; */

         /*kem->claimed_nist_level = 1; */
         /*kem->ind_cca = true; */

         kem->length_public_key = OQS_KEM_kyber_512_length_public_key;
         kem->length_secret_key = OQS_KEM_kyber_512_length_secret_key;
         kem->length_ciphertext = OQS_KEM_kyber_512_length_ciphertext;
         kem->length_shared_secret = OQS_KEM_kyber_512_length_shared_secret;

         kem->keypair = OQS_KEM_kyber_512_keypair;
         kem->encaps = OQS_KEM_kyber_512_encaps;
         kem->decaps = OQS_KEM_kyber_512_decaps;
      }
      else if (strcmp(a, ICC_KEM_alg_kyber_768) == 0) {
         kem->method_name = ICC_KEM_alg_kyber_768;
         /*kem->alg_version = "https://github.com/pq-crystals/kyber/tree/standard"; */

         /*kem->claimed_nist_level = 1; */
         /*kem->ind_cca = true; */

         kem->length_public_key = OQS_KEM_kyber_768_length_public_key;
         kem->length_secret_key = OQS_KEM_kyber_768_length_secret_key;
         kem->length_ciphertext = OQS_KEM_kyber_768_length_ciphertext;
         kem->length_shared_secret = OQS_KEM_kyber_768_length_shared_secret;

         kem->keypair = OQS_KEM_kyber_768_keypair;
         kem->encaps = OQS_KEM_kyber_768_encaps;
         kem->decaps = OQS_KEM_kyber_768_decaps;
      }
      else if (strcmp(a, ICC_KEM_alg_kyber_1024) == 0) {
         kem->method_name = ICC_KEM_alg_kyber_1024;
         /*kem->alg_version = "https://github.com/pq-crystals/kyber/tree/standard"; */

         /*kem->claimed_nist_level = 1; */
         /*kem->ind_cca = true; */

         kem->length_public_key = OQS_KEM_kyber_1024_length_public_key;
         kem->length_secret_key = OQS_KEM_kyber_1024_length_secret_key;
         kem->length_ciphertext = OQS_KEM_kyber_1024_length_ciphertext;
         kem->length_shared_secret = OQS_KEM_kyber_1024_length_shared_secret;

         kem->keypair = OQS_KEM_kyber_1024_keypair;
         kem->encaps = OQS_KEM_kyber_1024_encaps;
         kem->decaps = OQS_KEM_kyber_1024_decaps;
      }
      else {
         ICC_Free(kem);
         return NULL;
      }
   }
   return kem;
}

static
ICC_SIG*
ICC_SIG_new(const char* a)
{
   ICC_SIG* sig = ICC_Malloc(sizeof(ICC_SIG), __FILE__, __LINE__);
   if (sig) {
      /* load up the signature context with algorithm specific details for each algorithm variant */
      if (strcmp(a, ICC_SIG_alg_dilithium_2) == 0) {
         sig->method_name = ICC_SIG_alg_dilithium_2;

         sig->length_public_key = OQS_SIG_dilithium_2_length_public_key;
         sig->length_secret_key = OQS_SIG_dilithium_2_length_secret_key;
         sig->length_signature = OQS_SIG_dilithium_2_length_signature;

         sig->keypair = OQS_SIG_dilithium_2_keypair;
         sig->sign = OQS_SIG_dilithium_2_sign;
         sig->verify = OQS_SIG_dilithium_2_verify;
      }
      else if (strcmp(a, ICC_SIG_alg_dilithium_3) == 0) {
         sig->method_name = ICC_SIG_alg_dilithium_3;

         sig->length_public_key = OQS_SIG_dilithium_3_length_public_key;
         sig->length_secret_key = OQS_SIG_dilithium_3_length_secret_key;
         sig->length_signature = OQS_SIG_dilithium_3_length_signature;

         sig->keypair = OQS_SIG_dilithium_3_keypair;
         sig->sign = OQS_SIG_dilithium_3_sign;
         sig->verify = OQS_SIG_dilithium_3_verify;
      }
      else if (strcmp(a, ICC_SIG_alg_dilithium_5) == 0) {
         sig->method_name = ICC_SIG_alg_dilithium_5;

         sig->length_public_key = OQS_SIG_dilithium_5_length_public_key;
         sig->length_secret_key = OQS_SIG_dilithium_5_length_secret_key;
         sig->length_signature = OQS_SIG_dilithium_5_length_signature;

         sig->keypair = OQS_SIG_dilithium_5_keypair;
         sig->sign = OQS_SIG_dilithium_5_sign;
         sig->verify = OQS_SIG_dilithium_5_verify;
      }
/* This macro encodes the if clause for each of the 12 variants of sphincs */
#define if_sphincs(x) \
      else if (strcmp(a, ICC_SIG_alg_sphincs_ ## x ## _simple) == 0) { \
         sig->method_name = ICC_SIG_alg_sphincs_ ## x ## _simple; \
         sig->length_public_key = SPX_ ## x ## _crypto_sign_publickeybytes(); \
         sig->length_secret_key = SPX_ ## x ## _crypto_sign_secretkeybytes(); \
         sig->length_signature = SPX_ ## x ## _crypto_sign_bytes(); \
         sig->keypair = OQS_SIG_sphincs_ ## x ## _keypair; \
         sig->sign = OQS_SIG_sphincs_ ## x ## _sign; \
         sig->verify = OQS_SIG_sphincs_ ## x ## _verify; \
      }
      if_sphincs(SHAKE_128s)
      if_sphincs(SHAKE_128f)
      if_sphincs(SHAKE_192s)
      if_sphincs(SHAKE_192f)
      if_sphincs(SHAKE_256s)
      if_sphincs(SHAKE_256f)
#ifdef PQC_SHPINCS_SHA2
      if_sphincs(SHA2_128s)
      if_sphincs(SHA2_128f)
      if_sphincs(SHA2_192s)
      if_sphincs(SHA2_192f)
      if_sphincs(SHA2_256s)
      if_sphincs(SHA2_256f)
#endif
      else {
         ICC_Free(sig);
         return NULL;
      }
   }
   return sig;
}

static void ICC_KEM_free(void *x)
{
   ICC_Free(x);
}

static void ICC_SIG_free(void* x)
{
   ICC_Free(x);
}

/* return OQS_SUCCESS for success, OQS_FAILURE failure */

static
int ICC_KEM_keypair(const ICC_KEM* kem, void* pkc, void* skc)
{
   if (!kem || !kem->keypair) {
      return -1;
   }
   else {
      return kem->keypair(pkc, skc);
   }
}

static
int ICC_SIG_keypair(const ICC_SIG* sig, void* pkc, void* skc)
{
   if (!sig || !sig->keypair) {
      return -1;
   }
   else {
      return sig->keypair(pkc, skc);
   }
}

#endif

static
void pqc_pkey_free(EVP_PKEY* pkey)
{
   {
      PQC_EVP_PKEY* pk = pkey->pkey.ptr;
      if (pk) {
         ICC_Free(pk->pkc);
         pk->pkc = NULL;
         ICC_Free(pk->skc);
         pk->skc = NULL;
         if (pk->kc) {
            ICC_KEM_free(pk->kc);
            pk->kc = NULL;
         }
         if (pk->sc) {
            ICC_SIG_free(pk->sc);
            pk->sc = NULL;
         }
         free(pk);
      }
      pkey->pkey.ptr = NULL;
   }
}

static void pkey_kyber_cleanup(EVP_PKEY_CTX* ctx)
{
   if (!ctx)
      return;

   EVP_PKEY_free(ctx->pkey);
   ctx->pkey = NULL;
}

static
PQC_EVP_PKEY*
new_pqc_key(int type)
{
   PQC_EVP_PKEY* pk = OPENSSL_zalloc(sizeof(PQC_EVP_PKEY));
   if (!pk) {
      return NULL;
   }
   {
      const char* method_name = id2meth(type);
      if (isEVPKyber(type)) {
         pk->newctx = (void* (*)(const char* a))ICC_KEM_new;
         pk->freectx = (void (*)(void* x))ICC_KEM_free;
         pk->kc = pk->newctx(method_name);
         if (!pk->kc) {
            return NULL;
         }
         pk->pq_ctx = pk->kc;
      }
      else {
         pk->newctx = (void* (*)(const char* a))ICC_SIG_new;
         pk->freectx = (void (*)(void* x))ICC_SIG_free;
         pk->sc = pk->newctx(method_name);
         if (!pk->sc) {
            return NULL;
         }
         pk->pq_ctx = pk->sc;
      }
   }
   return pk;
}

static int pkey_kyber_keygen_init(EVP_PKEY_CTX* ctx)
{
   int rv = 1;
   return rv;
}

static int pkey_kyber_keygen(EVP_PKEY_CTX* ctx, EVP_PKEY* pkey)
{
   int rv = 1;
   ENGINE* tmpeng = NULL;
   const EVP_PKEY_ASN1_METHOD* ameth;

   pkey->type = ctx->pmeth->pkey_id;
   ameth = EVP_PKEY_asn1_find(&tmpeng, pkey->type);
   if (ameth == NULL) {
      return -1;
   }
   pkey->ameth = ameth;

   {
      PQC_EVP_PKEY* pk = new_pqc_key(pkey->type);
      if (!pk) {
         return -1;
      }
      /* attach to key */
      pkey->pkey.ptr = pk;

      {
         /* get KEM context */
         const ICC_KEM* kem = pk->kc;

         /* allocate key storage */
         /* note - gets cleaned up in ameth->pqc_pkey_free() callback */
         pk->pkcLen = kem->length_public_key;
         pk->pkc = ICC_Malloc(kem->length_public_key, __FILE__, __LINE__);
         pk->skcLen = kem->length_secret_key;
         pk->skc = ICC_Malloc(kem->length_secret_key, __FILE__, __LINE__);

         /* generate keys */
         {
            int rc;
            rc = ICC_KEM_keypair(kem, pk->pkc, pk->skc);
            if (rc != OQS_SUCCESS) {
               rv = -1;
            }
            else {
               rv = 1;
            }
         }
      }
   }

   if (!ctx->pkey) {
      /* normally the case - attach key to this context */
      ctx->pkey = pkey;
      if (pkey != NULL)
         EVP_PKEY_up_ref(pkey);
   }

   return rv;
}

static int pkey_dilithium_keygen_init(EVP_PKEY_CTX* ctx)
{
   int rv = 1;
   return rv;
}
static int pkey_dilithium_keygen(EVP_PKEY_CTX* ctx, EVP_PKEY* pkey)
{
   int rv = 1;
   ENGINE* tmpeng = NULL;
   const EVP_PKEY_ASN1_METHOD* ameth;

   pkey->type = ctx->pmeth->pkey_id;

   ameth = EVP_PKEY_asn1_find(&tmpeng, pkey->type);
   if (ameth == NULL) {
      return -1;
   }
   pkey->ameth = ameth;

   {
      PQC_EVP_PKEY* pk = new_pqc_key(pkey->type);
      if (!pk) {
         return -1;
      }
      /* attach to key */
      pkey->pkey.ptr = pk;

      {
         /* get SIG context */
         const ICC_SIG* sig = NULL;
         sig = pk->sc;

         /* allocate key storage */
         /* note - gets cleaned up in ameth->pqc_pkey_free() callback */
         pk->pkcLen = sig->length_public_key;
         pk->pkc = ICC_Malloc(sig->length_public_key, __FILE__, __LINE__);
         pk->skcLen = sig->length_secret_key;
         pk->skc = ICC_Malloc(sig->length_secret_key, __FILE__, __LINE__);

         /* generate keys */
         {
            int rc;
            rc = ICC_SIG_keypair(sig, pk->pkc, pk->skc);
            if (rc != OQS_SUCCESS) {
               rv = -1;
            }
            else {
               rv = 1;
            }
         }
      }
   }

   if (!ctx->pkey) {
      /* normally the case - attach key to this context */
      ctx->pkey = pkey;
      if (pkey != NULL)
         EVP_PKEY_up_ref(pkey);
   }

   return rv;
}

static int pkey_sphincs_keygen_init(EVP_PKEY_CTX* ctx)
{
   int rv = 1;
   return rv;
}
static int pkey_sphincs_keygen(EVP_PKEY_CTX* ctx, EVP_PKEY* pkey)
{
   int rv = pkey_dilithium_keygen(ctx, pkey);
   return rv;
}

static
int pkey_dilithium_sign_init(EVP_PKEY_CTX* ctx)
{
   return 1;
}

static
int pkey_dilithium_sign(EVP_PKEY_CTX* ctx, unsigned char* sig,
   size_t* siglen, const unsigned char* tbs,
   size_t tbslen)
{
   int rc = ICC_OSSL_SUCCESS;
   if (!ctx)
      return -1;
   if (!siglen)
      return -1;
   {
      EVP_PKEY* pkey = ctx->pkey;
      if (!pkey)
         return -1;
      if (pkey->type != ctx->pmeth->pkey_id) {
         /* wrong key type */
         return 0;
      }
      {
         size_t len = *siglen;
         const PQC_EVP_PKEY* pk = (const PQC_EVP_PKEY*)pkey->pkey.ptr;
         if (!pk)
            return -1;

         if (!sig) {
            /* length prediction */
            len = pk->sc->length_signature;
            rc = OQS_SUCCESS;
         }
         else {
            rc = ICC_SIG_sign(pk->sc, sig, &len, tbs, tbslen, pk->skc);
         }
         *siglen = len;
         if (rc == OQS_SUCCESS) {
            return 1;
         }
      }
   }
   return 0;
}
static int pkey_dilithium_verify(EVP_PKEY_CTX* ctx,
   const unsigned char* sig, size_t siglen,
   const unsigned char* tbs, size_t tbslen)
{
   int rc = ICC_OSSL_SUCCESS;
   if (!ctx)
      return -1;
   {
      const EVP_PKEY* k = ctx->pkey;
      if (!k)
         return -1;
      if (k->type != ctx->pmeth->pkey_id) {
         /* wrong key type */
         return 0;
      }
      {
         const PQC_EVP_PKEY* pk = (const PQC_EVP_PKEY*)k->pkey.ptr;
         if (!pk)
            return -1;

         rc = ICC_SIG_verify(pk->sc, tbs, tbslen, sig, siglen, pk->pkc);
         if (rc != OQS_SUCCESS) {
            return -1;
         }
      }
   }
   return 1;
}
static int pkey_dilithium_verifyrecover(EVP_PKEY_CTX* ctx,
   unsigned char* rout, size_t* routlen,
   const unsigned char* sig, size_t siglen)
{
   return 0;
}

static int pkey_sphincs_sign(EVP_PKEY_CTX* ctx, unsigned char* sig,
   size_t* siglen, const unsigned char* tbs,
   size_t tbslen)
{
   return pkey_dilithium_sign(ctx, sig, siglen, tbs, tbslen);
}
static int pkey_sphincs_verify(EVP_PKEY_CTX* ctx,
   const unsigned char* sig, size_t siglen,
   const unsigned char* tbs, size_t tbslen )
{
   return pkey_dilithium_verify(ctx, sig, siglen, tbs, tbslen);
}
static int pkey_sphincs_verifyrecover(EVP_PKEY_CTX* ctx,
   unsigned char* rout, size_t* routlen,
   const unsigned char* sig, size_t siglen)
{
   return 0;
}

static int pkey_kyber_encrypt(EVP_PKEY_CTX* ctx,
   unsigned char* out, size_t* outlen,
   const unsigned char* in, size_t inlen)
{
   return 0;
}
static int pkey_kyber_decrypt(EVP_PKEY_CTX* ctx,
   unsigned char* out, size_t* outlen,
   const unsigned char* in, size_t inlen)
{
   return 0;
}
static int pkey_kyber_ctrl(EVP_PKEY_CTX* ctx, int type, int p1, void* p2)
{
   return 1;
}
static int pkey_kyber_ctrl_str(EVP_PKEY_CTX* ctx,
   const char* type, const char* value)
{
   return 1;
}

static
EVP_PKEY_METHOD kyber_pkey_meth = {
    0, /* pkey_id */
    0, /* flags */
    pkey_kyber_init,
    pkey_kyber_copy,
    pkey_kyber_cleanup,

    0, 0,

    pkey_kyber_keygen_init,
    pkey_kyber_keygen,

    0,
    0, /*pkey_kyber_sign, */

    0,
    0, /*pkey_kyber_verify, */

    0,
    0, /*pkey_kyber_verifyrecover, */

    0, 0, 0, 0,

    0,
    pkey_kyber_encrypt,

    0,
    pkey_kyber_decrypt,

    0, 0,

    pkey_kyber_ctrl,
    pkey_kyber_ctrl_str
};
static
EVP_PKEY_METHOD kyber768_pkey_meth;
static
EVP_PKEY_METHOD kyber1024_pkey_meth;

static
EVP_PKEY_METHOD dilithium_pkey_meth = {
    0, /* pkey_id */
    0, /* flags */
    pkey_kyber_init,
    pkey_kyber_copy,
    pkey_kyber_cleanup,

    0, 0,

    pkey_dilithium_keygen_init,
    pkey_dilithium_keygen,

    pkey_dilithium_sign_init,
    pkey_dilithium_sign,

    0, /* verify_init */
    pkey_dilithium_verify,

    0, /* verifyrecover_init */
    pkey_dilithium_verifyrecover,

    0, 0, 0, 0,

    0, /* encrypt_init */
    0, /* pkey_dilithium_encrypt, */

    0, /* decrypt_init */
    0, /* pkey_dilithium_decrypt, */

    0, 0,

    pkey_kyber_ctrl,
    pkey_kyber_ctrl_str
};
static
EVP_PKEY_METHOD dilithium768_pkey_meth;
static
EVP_PKEY_METHOD dilithium1024_pkey_meth;

static
EVP_PKEY_METHOD sphincs128s_shake_pkey_meth = {
    0, /* pkey_id */
    0, /* flags */
    pkey_kyber_init,
    pkey_kyber_copy,
    pkey_kyber_cleanup,

    0, 0,

    pkey_sphincs_keygen_init,
    pkey_sphincs_keygen,

    0,
    pkey_sphincs_sign,

    0,
    pkey_sphincs_verify,

    0,
    pkey_sphincs_verifyrecover,

    0, 0, 0, 0,

    0,
    pkey_kyber_encrypt,

    0,
    pkey_kyber_decrypt,

    0, 0,

    pkey_kyber_ctrl,
    pkey_kyber_ctrl_str
};

static EVP_PKEY_METHOD sphincs128f_shake_pkey_meth;
static EVP_PKEY_METHOD sphincs192s_shake_pkey_meth;
static EVP_PKEY_METHOD sphincs192f_shake_pkey_meth;
static EVP_PKEY_METHOD sphincs256s_shake_pkey_meth;
static EVP_PKEY_METHOD sphincs256f_shake_pkey_meth;
static EVP_PKEY_METHOD sphincs128s_sha2_pkey_meth;
static EVP_PKEY_METHOD sphincs128f_sha2_pkey_meth;
static EVP_PKEY_METHOD sphincs192s_sha2_pkey_meth;
static EVP_PKEY_METHOD sphincs192f_sha2_pkey_meth;
static EVP_PKEY_METHOD sphincs256s_sha2_pkey_meth;
static EVP_PKEY_METHOD sphincs256f_sha2_pkey_meth;

#endif

#ifndef LIBOQS

/* return OQS_SUCCESS for success, OQS_FAILURE failure */

static int ICC_KEM_encaps(ICC_KEM* kc, void* wrappedkey, void* genkey, void* pkc)
{
   if (!kc || !kc->encaps) {
      return -1;
   }
   else {
      return kc->encaps(wrappedkey, genkey, pkc);
   }
}

static int ICC_KEM_decaps(ICC_KEM* kc, void* unwrapped, const void* wrapped, const void* skc)
{
   if (!kc || !kc->decaps) {
      return -1;
   }
   else {
      return kc->decaps(unwrapped, wrapped, skc);
   }
}

static
int ICC_SIG_sign(ICC_SIG* sc, void* sig, size_t* len, const void* tbs, size_t tbslen, void* skc)
{
   if (!sc || !sc->sign) {
      return -1;
   }
   else {
      return sc->sign(sig, len, tbs, tbslen, skc);
   }
}

static
int ICC_SIG_verify(ICC_SIG* sc, const void* tbs, size_t tbslen, const void* sig, size_t siglen, void* pkc)
{
   if (!sc || !sc->verify) {
      return -1;
   }
   else {
      return sc->verify(tbs, tbslen, sig, siglen, pkc);
   }
}
#endif

/* algorithm name table entry */
struct s_noid {
   char* o; /* OID */
   char* s; /* short name */
   char* l; /* long name */
   char* alias; /* alternative long name */
   char* libOQSalg; /* lib (oqs) name */
   EVP_PKEY_METHOD* pmeth;
   EVP_PKEY_ASN1_METHOD* ameth;
};

/*
 ML_KEM_512("2.16.840.1.101.3.4.4.1"),
 ML_KEM_768("2.16.840.1.101.3.4.4.2"),
 ML_KEM_1024("2.16.840.1.101.3.4.4.3");

 ML_DSA_44("2.16.840.1.101.3.4.3.17"),
 ML_DSA_65("2.16.840.1.101.3.4.3.18"),
 ML_DSA_87("2.16.840.1.101.3.4.3.19"),

SLH_DSA_SHA2_128s("2.16.840.1.101.3.4.3.20"),
SLH_DSA_SHA2_128f("2.16.840.1.101.3.4.3.21"),
SLH_DSA_SHA2_192s("2.16.840.1.101.3.4.3.22"),
SLH_DSA_SHA2_192f("2.16.840.1.101.3.4.3.23"),
SLH_DSA_SHA2_256s("2.16.840.1.101.3.4.3.24"),
SLH_DSA_SHA2_256f("2.16.840.1.101.3.4.3.25"),

SLH_DSA_SHAKE_128s("2.16.840.1.101.3.4.3.26"),
SLH_DSA_SHAKE_128f("2.16.840.1.101.3.4.3.27"),
SLH_DSA_SHAKE_192s("12.16.840.1.101.3.4.3.28"),
SLH_DSA_SHAKE_192f("2.16.840.1.101.3.4.3.29"),
SLH_DSA_SHAKE_256s("2.16.840.1.101.3.4.3.30"),
SLH_DSA_SHAKE_256f("2.16.840.1.101.3.4.3.31"),
*/

static
struct s_noid noids[] =
{
#if defined(LIBOQS) || defined(LIBDKS)
   {"2.16.840.1.101.3.4.4.1", "ML_KEM_512", "ML_KEM_512-Kyber", "Kyber_512", ICC_KEM_alg_kyber_512, &kyber_pkey_meth, &kyber512_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.4.2", "ML_KEM_768", "ML_KEM_768-Kyber", "Kyber_768", ICC_KEM_alg_kyber_768, &kyber768_pkey_meth, &kyber768_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.4.3", "ML_KEM_1024", "ML_KEM_1024-Kyber", "Kyber_1024", ICC_KEM_alg_kyber_1024, &kyber1024_pkey_meth, &kyber1024_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.17", "ML_DSA_44", "ML_DSA_44-Dilithium", "Dilithium_512", ICC_SIG_alg_dilithium_2, &dilithium_pkey_meth, &dilithium_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.18", "ML_DSA_65", "ML_DSA_65-Dilithium", "Dilithium_768", ICC_SIG_alg_dilithium_3, &dilithium768_pkey_meth, &dilithium768_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.19", "ML_DSA_87", "ML_DSA_87-Dilithium", "Dilithium_1024", ICC_SIG_alg_dilithium_5, &dilithium1024_pkey_meth, &dilithium1024_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.20", "SLH_DSA_SHA2_128s", "SPHINCS_SHA2_128S", "Sphincs_sha2_128s", ICC_SIG_alg_sphincs_SHA2_128s_simple, &sphincs128s_sha2_pkey_meth, &sphincs128s_sha2_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.21", "SLH_DSA_SHA2_128f", "SPHINCS_SHA2_128F", "Sphincs_sha2_128f", ICC_SIG_alg_sphincs_SHA2_128f_simple, &sphincs128f_sha2_pkey_meth, &sphincs128f_sha2_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.22", "SLH_DSA_SHA2_192s", "SPHINCS_SHA2_192S", "Sphincs_sha2_192s", ICC_SIG_alg_sphincs_SHA2_192s_simple, &sphincs192s_sha2_pkey_meth, &sphincs192s_sha2_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.23", "SLH_DSA_SHA2_192f", "SPHINCS_SHA2_192F", "Sphincs_sha2_192f", ICC_SIG_alg_sphincs_SHA2_192f_simple, &sphincs192f_sha2_pkey_meth, &sphincs192f_sha2_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.24", "SLH_DSA_SHA2_256s", "SPHINCS_SHA2_256S", "Sphincs_sha2_256s", ICC_SIG_alg_sphincs_SHA2_256s_simple, &sphincs256s_sha2_pkey_meth, &sphincs256s_sha2_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.25", "SLH_DSA_SHA2_256f", "SPHINCS_SHA2_256F", "Sphincs_sha2_256f", ICC_SIG_alg_sphincs_SHA2_256f_simple, &sphincs256f_sha2_pkey_meth, &sphincs256f_sha2_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.26", "SLH_DSA_SHAKE_128s", "SPHINCS_SHAKE_128S", "Sphincs_shake_128s", ICC_SIG_alg_sphincs_SHAKE_128s_simple, &sphincs128s_shake_pkey_meth, &sphincs128s_shake_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.27", "SLH_DSA_SHAKE_128f", "SPHINCS_SHAKE_128F", "Sphincs_shake_128f", ICC_SIG_alg_sphincs_SHAKE_128f_simple, &sphincs128f_shake_pkey_meth, &sphincs128f_shake_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.28", "SLH_DSA_SHAKE_192s", "SPHINCS_SHAKE_192S", "Sphincs_shake_192s", ICC_SIG_alg_sphincs_SHAKE_192s_simple, &sphincs192s_shake_pkey_meth, &sphincs192s_shake_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.29", "SLH_DSA_SHAKE_192f", "SPHINCS_SHAKE_192F", "Sphincs_shake_192f", ICC_SIG_alg_sphincs_SHAKE_192f_simple, &sphincs192f_shake_pkey_meth, &sphincs192f_shake_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.30", "SLH_DSA_SHAKE_256s", "SPHINCS_SHAKE_256S", "Sphincs_shake_256s", ICC_SIG_alg_sphincs_SHAKE_256s_simple, &sphincs256s_shake_pkey_meth, &sphincs256s_shake_pkey_asn1_meth},
   {"2.16.840.1.101.3.4.3.31", "SLH_DSA_SHAKE_256f", "SPHINCS_SHAKE_256F", "Sphincs_shake_256f", ICC_SIG_alg_sphincs_SHAKE_256f_simple, &sphincs256f_shake_pkey_meth, &sphincs256f_shake_pkey_asn1_meth},
#endif
   {NULL}
};


/* 
   Register all of our PQC handlers
*/
void
pqc_evp_init()
{
#if defined(LIBOQS) || defined(LIBDKS)

#ifdef LIBOQS
   /* redirect liboqs rng to ICC's rng */
   OQS_randombytes_custom_algorithm(&icc_randombytes);
#endif

   kyber768_pkey_meth = kyber_pkey_meth;
   kyber1024_pkey_meth = kyber_pkey_meth;
   kyber768_pkey_asn1_meth = kyber512_pkey_asn1_meth;
   kyber1024_pkey_asn1_meth = kyber512_pkey_asn1_meth;

   dilithium768_pkey_meth = dilithium_pkey_meth;
   dilithium1024_pkey_meth = dilithium_pkey_meth;
   dilithium768_pkey_asn1_meth = dilithium_pkey_asn1_meth;
   dilithium1024_pkey_asn1_meth = dilithium_pkey_asn1_meth;

   sphincs128f_shake_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs192s_shake_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs192f_shake_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs256s_shake_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs256f_shake_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs128f_shake_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs192s_shake_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs192f_shake_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs256s_shake_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs256f_shake_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;

   sphincs128s_sha2_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs128f_sha2_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs192s_sha2_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs192f_sha2_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs256s_sha2_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs256f_sha2_pkey_meth = sphincs128s_shake_pkey_meth;
   sphincs128s_sha2_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs128f_sha2_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs192s_sha2_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs192f_sha2_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs256s_sha2_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
   sphincs256f_sha2_pkey_asn1_meth = sphincs128s_shake_pkey_asn1_meth;
#endif

   {
      struct s_noid* ns;
      for (ns = noids; ns->o; ns++) {
         ns->pmeth->pkey_id = ns->ameth->pkey_id = ns->ameth->pkey_base_id = OBJ_create(ns->o, ns->s, ns->l);
         ns->ameth->info = ns->alias;
         EVP_PKEY_meth_add0(ns->pmeth);
         EVP_PKEY_asn1_add0(ns->ameth);
      }
   }
}

static int isEVPKyber(int id)
{
   struct s_noid* ns;
   for (ns = noids; ns->alias; ns++) {
      if (id == ns->pmeth->pkey_id && memcmp(ns->alias, "Kyber", 5) == 0)
         return 1;
   }
   return 0;
}
static int isEVPDilithium(int id)
{
   struct s_noid* ns;
   for (ns = noids; ns->alias; ns++) {
      if (id == ns->pmeth->pkey_id && memcmp(ns->alias, "Dilithium", 9) == 0)
         return 1;
   }
   return 0;
}
static int isEVPSphincs(int id)
{
   struct s_noid* ns;
   for (ns = noids; ns->alias; ns++) {
      if (id == ns->pmeth->pkey_id && memcmp(ns->alias, "Sphincs", 7) == 0)
         return 1;
   }
   return 0;
}
static int isEVPPQC(int id)
{
   return isEVPKyber(id) || isEVPDilithium(id) || isEVPSphincs(id)
      ;
}
static int isPQC(int id)
{
   return isEVPPQC(id)
      ;
}

static
const char* id2meth(int k)
{
   struct s_noid* ns;
   for (ns = noids; ns->o; ns++) {
      if (k == ns->pmeth->pkey_id)
         return ns->libOQSalg;
   }
   return NULL;
}

static int isdash(char c)
{
   return (c == '_' || c == '-');
}

/* return 0 if strings match with _ - optional */
static
int strcmpdashed(const char* a, const char* b)
{
   if (!a || !b)
      return -1;

   /* where a contains '_', b can be '_', '-' or ''*/
   for (; *a || *b; a++) {
      if (*a == *b) {
         b++;
      }
      else {
         /* not same - try optional dash */
         if (isdash(*a)) {
            if (isdash(*b)) {
               b++;
            }
            /* we skip the a's dash and try to match b with next a */
         }
         else {
            return (*a - *b);
         }
      }
   }
   return 0;
}

static
const char* cvtalias(const char*a)
{
   const struct s_noid* ns;
   for (ns = noids; ns->o; ns++) {
      /* explicit alias - exact match */
      if (!strcmp(ns->alias, a))
         return ns->s;

      /* name match with optional dashes */
      if (!strcmpdashed(ns->s, a))
         return ns->s;
   }
   return NULL;
}

/* linked to via icclib_a.c (included code below) */
static
int my_OBJ_txt2nid(const char* text)
{
   int nid;
   nid = OBJ_txt2nid(text);
   if (nid == NID_undef) {
      const char* a = cvtalias(text);
      if (a) {
         nid = OBJ_txt2nid(a);
      }
   }
   return nid;
}

/* included via icclib_a.c */
static
EVP_PKEY_CTX* my_EVP_PKEY_CTX_new_id(int id, void* e)
{
   return EVP_PKEY_CTX_new_id(id, e);
}

/* included via icclib_a.c */
static
void my_EVP_PKEY_CTX_free(EVP_PKEY_CTX* pkey_ctx)
{
   EVP_PKEY_CTX_free(pkey_ctx);
}

EVP_PKEY_CTX* EVP_PKEY_CTX_new_from_name(void* libctx, const char* name, const char* propquery)
{
   /* propquery is a V 3 thing - not sure what to do with that */
   EVP_PKEY_CTX* p = EVP_PKEY_CTX_new_id(my_OBJ_txt2nid(name), NULL);
   return p;
}

EVP_PKEY_CTX* EVP_PKEY_CTX_new_from_pkey(void* libctx, EVP_PKEY* pkey, const char* propquery)
{
   /* propquery is a V 3 thing - not sure what to do with that */
   EVP_PKEY_CTX* pctx = EVP_PKEY_CTX_new(pkey, NULL);
   return pctx;
}


/*
* The following are scraped from OpenSSL 3
*/
struct EVP_KEM_t
{
   const char* algorithm;
   const char* properties;
};
typedef struct EVP_KEM_t         EVP_KEM;

#include "Argon2/argon2.h"

/* note - do not use ICC_ variants or will get compile errors on some platforms */
struct EVP_KDF_t
{
   void* prov;
   int name_id;
   char* type_name; /* "ARGON2", "ARGON2ID", "ARGON2I", "ARGON2D" */
   int refCount;
   const char* description;
};
typedef struct EVP_KDF_t EVP_KDF;


struct EVP_KDF_CTX_t
{
    EVP_KDF* meth; /*Method Structure*/
    void* algctx;
};
typedef struct EVP_KDF_CTX_t EVP_KDF_CTX;

static
int EVP_PKEY_CTX_set_kem_op(EVP_PKEY_CTX* ctx, const char* op)
{
   /* this only gets used for RSA anyway */
   /* nothing to do */
   return 1;
}

static
EVP_KEM* EVP_KEM_fetch(const char* algorithm, const char* properties)
{
   EVP_KEM* k = OPENSSL_zalloc(sizeof(EVP_KEM));
   k->algorithm = strdup(algorithm);
   k->properties = strdup(properties);
   return k;
}
static
void EVP_KEM_free(EVP_KEM* wrap)
{
   if (wrap) {
      free((void*)wrap->algorithm);
      wrap->algorithm = 0;
      free((void*)wrap->properties);
      wrap->properties = 0;
      free(wrap);
   }
}

static
int EVP_PKEY_encapsulate_init(EVP_PKEY_CTX* ctx, const unsigned char* params)
{
   /* nothing to do */
   return 1;
}
static
int EVP_PKEY_auth_encapsulate_init(EVP_PKEY_CTX* ctx, EVP_PKEY* authpub, const unsigned char* params)
{
   /* nothing to do */
   return 1;
}
static
int EVP_PKEY_encapsulate(EVP_PKEY_CTX* ctx, unsigned char* wrappedkey, size_t* wrappedkeylen, unsigned char* genkey, size_t* genkeylen)
{
   int rc = OQS_SUCCESS;
   if (!ctx)
      return -1;
   const EVP_PKEY* k = ctx->pkey;
   if (!k)
      return -1;
   if (k->type != ctx->pmeth->pkey_id) {
      /* wrong key type */
      return 0;
   }
   const PQC_EVP_PKEY* pk = (const PQC_EVP_PKEY*)k->pkey.ptr;
   if (!pk)
      return -1;

   if (wrappedkeylen) {
      *wrappedkeylen = pk->kc->length_ciphertext;
   }
   if (genkeylen) {
      *genkeylen = pk->kc->length_shared_secret;
   }
   if (wrappedkey && genkey) {
      rc = ICC_KEM_encaps(pk->kc, wrappedkey, genkey, pk->pkc);
      if (rc != OQS_SUCCESS) {
         return -1;
      }
   }
   if (rc == OQS_SUCCESS) {
      return 1;
   }
   return 0;
}

static
int EVP_PKEY_decapsulate_init(EVP_PKEY_CTX* ctx, const unsigned char* params)
{
   return 1;
}
static
int EVP_PKEY_auth_decapsulate_init(EVP_PKEY_CTX* ctx, EVP_PKEY* authpub, const unsigned char* params)
{
   return 1;
}
static
int EVP_PKEY_decapsulate(EVP_PKEY_CTX* ctx, unsigned char* unwrapped, size_t* unwrappedlen, const unsigned char* wrapped, size_t wrappedlen)
{
   int rc = OQS_SUCCESS;
   if (!ctx)
      return -1;
   const EVP_PKEY* k = ctx->pkey;
   if (!k)
      return -1;
   if (k->type != ctx->pmeth->pkey_id) {
      /* wrong key type */
      return 0;
   }
   const PQC_EVP_PKEY* pk = (const PQC_EVP_PKEY*)k->pkey.ptr;
   if (!pk)
      return -1;

   if (unwrappedlen) {
      *unwrappedlen = pk->kc->length_shared_secret;
   }
   if (unwrapped) {
      rc = ICC_KEM_decaps(pk->kc, unwrapped, wrapped, pk->skc);
      if (rc != OQS_SUCCESS) {
         return -1;
      }
   }
   if (rc == OQS_SUCCESS) {
      return 1;
   }
   return 0;
}

static
EVP_KDF* EVP_KDF_fetch(void *libctx, const char *algorithm,
                       const char *properties)
{
    EVP_KDF *kdf = (EVP_KDF*)OPENSSL_zalloc(sizeof(EVP_KDF));
    kdf->type_name = strdup(algorithm);
    kdf->refCount = 1;
    return kdf;
}

static
EVP_KDF_CTX* EVP_KDF_CTX_new(EVP_KDF *kdf)
{
    EVP_KDF_CTX *kdf_ctx = (EVP_KDF_CTX*)OPENSSL_zalloc(sizeof(EVP_KDF_CTX));
    kdf_ctx->meth = kdf;
    kdf->refCount++;
    return kdf_ctx;
}


struct ICC_Argon2_params {
    uint32_t lanes;
    uint32_t threads; /* Not used in Argon2_hash explicitly but determined by lanes.*/
    uint32_t memcost;
    char* password;
    char* salt;
    char* encoded;
	size_t pwdLen;
	size_t saltLen;
    argon2_type mode;
    argon2_version version; /* possible values ARGON2_VERSION_10, ARGON2_VERSION_13*/
};
typedef struct ICC_Argon2_params Argon2_params;

/*scraped from openssl v3 filename: */

ICC_OSSL_PARAM* ossl_param_construct(const char* key, unsigned int data_type,
    void* data, size_t data_size)
{
    ICC_OSSL_PARAM *res = (ICC_OSSL_PARAM*)OPENSSL_zalloc(sizeof(ICC_OSSL_PARAM));

    res->key = key;
    res->data_type = data_type;
    res->data = data;
    res->data_size = data_size;
    res->return_size = ICC_OSSL_PARAM_UNMODIFIED;
    return res;
}

ICC_OSSL_PARAM* OSSL_PARAM_construct_uint32(const char* key, unsigned int* buf)
{
    return ossl_param_construct(key, ICC_OSSL_PARAM_UNSIGNED_INTEGER, buf,
        sizeof(unsigned int));
}

ICC_OSSL_PARAM* OSSL_PARAM_construct_octet_string(const char* key, void* buf,
    size_t bsize)
{
    return ossl_param_construct(key, ICC_OSSL_PARAM_OCTET_STRING, buf, bsize);
}

ICC_OSSL_PARAM* OSSL_PARAM_construct_end(void)
{
    return ossl_param_construct(NULL, 0, NULL, 0);
}

static
argon2_type get_argon2_type(const char* name) {
    if (strncmp(name, "argon2_d", sizeof("argon2_d")) == 0) {
        return Argon2_d;
    }
    else if (strncmp(name, "argon2_i", sizeof("argon2_i")) == 0) {
        return Argon2_i;
    }
    else if (strncmp(name, "argon2_id", sizeof("argon2_id")) == 0) {
        return Argon2_id;
    }
    else {
        return -1;
    }
}

static
argon2_version get_argon2_version(const char* name) {
    if (name != NULL && strcmp(name, "ARGON2_VERSION_10") == 0) {
        return ARGON2_VERSION_10;
    }
    else {
        return ARGON2_VERSION_13; /*Default*/
    }
}

static int get_ossl_paramValues(Argon2_params* params, const ICC_OSSL_PARAM** ossl_params) {
    int rv = -1;
    const ICC_OSSL_PARAM** pp = ossl_params;
    while ((*pp)->key != NULL) {
        const ICC_OSSL_PARAM* p = *pp;
        if (strncmp(p->key, "lanes", sizeof("lanes")) == 0) {
            params->lanes = *(uint32_t*)p->data;
        }
        else if (strncmp(p->key, "threads", sizeof("threads")) == 0) {
            params->threads = *(uint32_t*)p->data;
        }
        else if (strncmp(p->key, "memcost", sizeof("memcost")) == 0) {
            params->memcost = *(uint32_t*)p->data;
        }
        else if (strncmp(p->key, "pass", sizeof("pass")) == 0) {
            params->password = (char*)p->data;
			params->pwdLen = p->data_size;
        }
        else if (strncmp(p->key, "salt", sizeof("salt")) == 0) {
            params->salt = (char*)p->data;
            params->saltLen = p->data_size;
        }
        else if (strncmp(p->key, "version", sizeof("version")) == 0) {
            params->version = get_argon2_version((char *)p->data);
        }
        else {
            return rv;
        }
        pp++;
    }
    return 0;
}


static
int EVP_KDF_derive(EVP_KDF_CTX* ctx, unsigned char* out,
    size_t outlen, const ICC_OSSL_PARAM** ossl_params)
{
    int result = -1;
#if defined(__MVS__)
    /* we are getting unresolved symbols because openssl has a clashing blake2b.o so can't support it */
    return result;
#else
    Argon2_params params = { 0 };
    if (ctx == NULL)
        return 0;


    result = get_ossl_paramValues(&params, ossl_params);

    params.mode = get_argon2_type(ctx->meth->type_name);
    if (params.mode < 0)
    {
        return 0;
    }

    
    size_t enclen = argon2_encodedlen(2 /*tc*/, params.memcost, params.threads, (uint32_t)params.saltLen, outlen, params.mode);

    params.encoded = calloc(1, enclen);

    result = argon2_hash(2 /*timeCost*/, params.memcost, params.lanes, params.password, params.pwdLen,
        params.salt, params.saltLen, out, outlen, params.encoded, enclen, params.mode, params.version);

    if (result == 0){
        return ICC_OSSL_SUCCESS;
    }
    else {
        return 0;
    }
#endif
}

static
void EVP_KDF_free(EVP_KDF *kdf)
{
   if (kdf) {
      kdf->refCount--;
      if (kdf->refCount == 0) 
      {
          free((void*)kdf->type_name);
          kdf->type_name = NULL;
          OPENSSL_free(kdf);
      }
   }
}

static
void EVP_KDF_CTX_free(EVP_KDF_CTX *ctx)
{
   if (ctx) {
      EVP_KDF_free(ctx->meth);
      ctx->meth = NULL;
      OPENSSL_free(ctx);
    }
}


/* included via icclib_a.c */
static
int  my_i2d_PublicKey(EVP_PKEY* pkey, unsigned char** pp)
{
#if defined(LIBOQS) || defined(LIBDKS)
   if (isPQC(pkey->type) && pkey) {
      return i2d_PQCPublicKey(pkey, pp);
   }
   else
#endif
      return i2d_PublicKey(pkey, pp);
}

/* included via icclib_a.c */
static
EVP_PKEY* my_d2i_PublicKey(int type, EVP_PKEY** a, const unsigned char** pp, long length)
{
#if defined(LIBOQS) || defined(LIBDKS)
   if (isPQC(type)) {
      if (!pp || !*pp) {
         return NULL;
      }
      const unsigned char* p = *pp;
      if (!p) {
         return NULL;
      }
      EVP_PKEY* pkey = EVP_PKEY_new();
      if (pkey == NULL)
         return NULL;
      if (a)
         *a = pkey;

      pkey->type = type;
      {
         ENGINE* tmpeng = NULL;
         const EVP_PKEY_ASN1_METHOD* ameth;

         ameth = EVP_PKEY_asn1_find(&tmpeng, pkey->type);
         if (ameth == NULL) {
            EVP_PKEY_free(pkey);
            return NULL;
         }
         pkey->ameth = ameth;
      }

      if (!d2i_PQCPublicKey(pkey, pp, length)) {
         EVP_PKEY_free(pkey);
         return NULL;
      }

      return pkey;
   }
   else
#endif
      return d2i_PublicKey(type, a, pp, length);
}

unsigned char *my_HKDF_Extract(const EVP_MD *evp_md,
                            const unsigned char *salt, size_t salt_len,
                            const unsigned char *key, size_t key_len,
                            unsigned char *prk, size_t *prk_len)
{
    unsigned int tmp_len;
    HMAC_CTX *hmac = NULL;
    hmac = HMAC_CTX_new();
    HMAC_Init(hmac,salt, (int)salt_len, evp_md);
    HMAC_Update(hmac,key,key_len);
    HMAC_Final(hmac,prk,&tmp_len);
    HMAC_CTX_free(hmac);
    *prk_len = tmp_len; 
    return prk;
}

unsigned char *my_HKDF_Expand(const EVP_MD *evp_md,
                           const unsigned char *prk, size_t prk_len,
                           const unsigned char *info, size_t info_len,
                           unsigned char *okm, size_t okm_len)
{
  unsigned char *ret = okm;
  HMAC_CTX *hmac = NULL;
  unsigned int i =0;
  unsigned char prev[ICC_EVP_MAX_MD_SIZE];
  size_t copy_len = 0;
  unsigned char ctr = 0;
  size_t done_len = 0;
  size_t dig_len = 0;
  size_t n = 0;


  dig_len = EVP_MD_size(evp_md);

  n = okm_len / dig_len;
  if (okm_len % dig_len) {
      n++;
  }
  if (n > 255 || okm == NULL) {
    ret = NULL;
  }
  if (NULL == (hmac = HMAC_CTX_new())) {
    ret = NULL;
  }
  if( NULL != hmac) {
    if (!HMAC_Init(hmac, prk, (int)prk_len, evp_md)) {
      ret = NULL;
    } else {
      for (i = 1; (i <= n); i++) {
        ctr = (unsigned char)i;
        if (i > 1) {
          if (!HMAC_Init(hmac, NULL, 0, NULL)) {
            ret = NULL;
            break;
          }
          HMAC_Update(hmac, prev, dig_len);
        }
        HMAC_Update(hmac, info, info_len);
        HMAC_Update(hmac, &ctr, 1);
        HMAC_Final(hmac, prev, NULL);
        copy_len = (done_len + dig_len > okm_len) ? (okm_len - done_len) :dig_len;
        memcpy(okm + done_len, prev, copy_len);
        done_len += copy_len;
      }
    }
    HMAC_CTX_free(hmac);
  }
  memset(prev,0,sizeof(prev));
  return ret;
}

/* included via icclib_a.c */
static
unsigned char *my_HKDF(const EVP_MD *evp_md,
                       const unsigned char *salt, size_t salt_len,
                       const unsigned char *key, size_t key_len,
                       const unsigned char *info, size_t info_len,
                       unsigned char *okm, size_t okm_len)
{
  unsigned char prk[ICC_EVP_MAX_MD_SIZE];
  unsigned char *ret;
  size_t prk_len;

  if (!my_HKDF_Extract(evp_md, salt, salt_len, key, key_len, prk, &prk_len))
  {
    ret = NULL;
  }
  else
  {
    ret = my_HKDF_Expand(evp_md, prk, prk_len, info, info_len, okm, okm_len);
  }
  memset(prk, 0, sizeof(prk));

  return ret;
}
#if 0
/* Copied from crypto/dsa/dsa_meth.c, see the comments, the droid we want isn't here */
typedef struct {
    /* Parameter gen parameters */
    int nbits;                  /* size of p in bits (default: 2048) */
    int qbits;                  /* size of q in bits (default: 224) */
    const EVP_MD *pmd;          /* MD for parameter generation */
    /* Keygen callback info */
    int gentmp[2];
    /* message digest */
    const EVP_MD *md;           /* MD for the signature */
} DSA_PKEY_CTX;
#endif
/*! @brief generic FIPS checker for pkeys
  @param pk The input pkey
  @param check 0 not capable of doing a sign/verify check. 1 capable of doing a sign/verify check on keygen
        2 Verify only is FIPS approved
  @param nid NID of the algorithm if it can be identified
*/
static int PKEY_FIPS_id(EVP_PKEY *pk, int *check,int *nid)
{
  int rv = 0;
  int tmp,tmp1;
  int id = 0;
  int tnid = 0;
  int size = 0;
  const EC_KEY *eck = NULL;
  const EC_GROUP *ecg = NULL;

  if(NULL == check) {
    check = &tmp;
  }
  *check = 0;
  if(NULL == nid) {
    nid = &tmp1;
  }
  *nid = 0;
  if (NULL != pk)
  {
    id = EVP_PKEY_id(pk);
    *nid = id;
    switch (id)
    {
    case 161: /* PBE2 */
      /* Now work out how to check the PBE params set */
      break;
    case 28: /* dhKeyAgreement */
      size = EVP_PKEY_bits(pk);
      switch (size)
      {
      case 2048:
      case 3072:
      case 4096:
      case 6144:
      case 8192:
        rv = 1;
        break;
      default:
        break;
      }
      break;
    case 1126: /* ffdhe2048 */
    case 1127: /* ffdhe3072 */
    case 1128: /* ffdhe4096 */
    case 1129: /* ffdhe6144 */
    case 1130: /* ffdhe8192 */
      rv = 1;
      break;
      /* Note X*** can't do sign verify */
    case 1087: /* ED25519 */
    case 1088: /* ED448 */
      *check = 1;
      break;
    case 408: /* Generic EC which is what we'll hit*/
      eck = EVP_PKEY_get0_EC_KEY(pk);
      ecg = EC_KEY_get0_group(eck);
      tnid = EC_GROUP_get_curve_name(ecg);
      if(tnid > 0) {
        *nid = tnid;
      }
      switch (tnid)
      {
      case 713: /* secp224r1  P-224 */
      case 415: /* prime256v1 P-256 */
      case 715: /* secp384r1  P-384 */
      case 716: /* secp521r1  P-521 */
      case 726: /* sect233k1  K-233 */
      case 727: /* sect233r1  B-233 */
      case 729: /* sect283k1  K-283 */
      case 730: /* sect283r1  B-283 */
      case 731: /* sect409k1  K-409 */
      case 732: /* sect409r1  B-409 */
      case 733: /* sect571k1  K-571 */
      case 734: /* sect571r1  B-571 */
        rv = 1;
        *check = 1;
        break;
      default:
        break;
      }
      break;
    case 116: /* DSA */
      size = EVP_PKEY_bits(pk);
      if ((size >= 2048) && (size <= 4096)) {
        rv = 1;
        *check = 2; /* Can verify, but not sign */
      }      
      break;
    case 6:   /* rsaEncryption, as with EC we should hit this */
    case 19:  /* RSA */
    case 912: /* RSA PSS */
    case 919: /* RSA OAEP */
      size = EVP_PKEY_bits(pk);
      if ((size >= 2048) && (size <= 4096))
      {
        rv = 1;
        *check = 1;
      }
      break;
    default:
      break;
    }
  }
  return rv;
}

/* included via icclib_a.c */
static
void my_EVP_PKEY_free(EVP_PKEY* pkey)
{
   EVP_PKEY_free(pkey);
}

/* included via icclib_a.c */
static
int my_EVP_PKEY_keygen(ICClib* pcb, EVP_PKEY_CTX* cctx, EVP_PKEY** ppkey);

/* included via icclib_a.c */
static
int my_EVP_PKEY_generate(ICClib* pcb, EVP_PKEY_CTX* ctx, EVP_PKEY** ppkey)
{
   int rv = 0;
   /* V3 API */
   rv = my_EVP_PKEY_keygen(NULL, ctx, ppkey);
   return rv;
}

/* included via icclib_a.c */
static
int my_EVP_PKEY_keygen_init(EVP_PKEY_CTX* ctx)
{
   int rv = 0;
   rv = EVP_PKEY_keygen_init(ctx);
   return rv;
}

/* Generic keygen, trap so we can perform the FIPS key consistancy checks */
/* included via icclib_a.c */
static
int my_EVP_PKEY_keygen(ICClib* pcb, EVP_PKEY_CTX* cctx, EVP_PKEY** ppkey)
{
  int rv = 0;
   int nid = 0;
  int fips = 0; /* FIPS allowed */
   int done = 0, tries = 0, maxRetry = 100;

  RAND_seed(NULL,0); /* Reseed before keygen */
   for (tries = 0; !done && tries < maxRetry; tries++) {
      rv = EVP_PKEY_keygen(cctx, ppkey);
      done = 1;
      /* some keys fail the following test so re-gen in that case */
      /* it appears to be caused by leading zeros in the key (PQC) */
      if (1 == rv && ppkey && *ppkey) {
         EVP_PKEY* pkey = *ppkey;
         int len = 0;
         len = my_i2d_PublicKey(pkey, NULL);
         if (len > 0) {
            const unsigned char* buf = NULL;
            unsigned char* ncpp = NULL;
            buf = ncpp = OPENSSL_malloc(len);
            len = my_i2d_PublicKey(pkey, &ncpp);
            if (len > 0) {
               const unsigned char* pp = buf;
               int kt = pkey->type;
               EVP_PKEY* nkey = NULL;
               nkey = my_d2i_PublicKey(kt, &nkey, &pp, len);
               if (nkey && 1 != EVP_PKEY_cmp(pkey, nkey)) {
                  done = 0; /* retry */
                  EVP_PKEY_free(pkey);
                  *ppkey = NULL;
               }
               EVP_PKEY_free(nkey);
            }
            OPENSSL_free(buf);
         }
      }
   }
   if (1 == rv && !done) {
      /* fatal error */
      /* Note for PQC keys: probability of false negative is (2^8)^maxRetry against */
      MARK("i2d - d2i missmatch", "my_EVP_PKEY_keygen");
      rv = 0;
   }

  if ((pcb != NULL) && (pcb->flags & ICC_FIPS_FLAG))
  {
      int rc = 0;
      size_t siglen = 512;
      int check = 0;

      if ((1 == rv) && (NULL != ppkey))
    {
         EVP_PKEY* pkey = *ppkey;
         fips = PKEY_FIPS_id(pkey, &check, &nid);
      if (1 == check)
      {
            const EVP_MD* md = NULL;
            EVP_MD_CTX* md_ctx = NULL;
        md_ctx = EVP_MD_CTX_new();
            md = EVP_get_digestbyname("SHA-224");
        if (NULL != md_ctx)
        {
               unsigned char* refsig = NULL;
          refsig = ICC_Malloc(8192, __FILE__, __LINE__); /* Large enough for a 4K RSA signature, we won't hit this with anything larger */
          if (NULL != refsig)
          {
                  static unsigned char in[32] = "01234567890abcdefghi01234567890";
                  int inlen = 20;

                  rc = EVP_DigestSignInit(md_ctx, &cctx, md, NULL, pkey);
            if (1 == rc)
            {
                     rc = EVP_DigestSign(md_ctx, refsig, &siglen, in, inlen);
            }
            if (1 == rc)
            {
                     rc = EVP_DigestVerifyInit(md_ctx, &cctx, md, NULL, pkey);
            }
            if (1 == rc)
            {
              rc = EVP_DigestVerify(md_ctx, refsig, siglen, in, inlen);
            }
            if (1 != rc)
            {
                     if (NULL != pkey)
              {
                        EVP_PKEY_free(pkey);
                        *ppkey = NULL;
              }
              rv = -1;
            }
            ICC_Free(refsig);
          }
          EVP_MD_CTX_free(md_ctx);
        }
      }
    }
  if(2 == check) {
    fips = 0; /* DSA */
  }
   }
   if ((NULL != pcb) && (NULL != pcb->callback) && (NULL != ppkey) && (NULL != *ppkey))
  {
    (*pcb->callback)("ICC_EVP_PKEY_keygen", nid, fips);
  }
   if ((NULL != pcb) && (NULL != pcb->trace_callback))
   {
       (*pcb->trace_callback)("ICC_EVP_PKEY_keygen", __func__);
   }
  return rv;
}


/* included via icclib_a.c */
static
int my_EVP_PKEY_sign_init(ICClib *pcb,EVP_PKEY_CTX *pctx)
{
  int rv = 0;
  int fips = 0;
  int nid = 0;
  int check = 0;
  EVP_PKEY *pk = NULL;

  rv = EVP_PKEY_sign_init(pctx);
  if((NULL != pcb->callback) && (1 == rv)) {
    pk =  EVP_PKEY_CTX_get0_pkey(pctx);
    if(NULL != pk) { 
      fips = PKEY_FIPS_id(pk,&check,&nid);
      (*pcb->callback)("ICC_EVP_PKEY_sign_init",nid,fips);
    }
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_EVP_PKEY_verify_init(ICClib *pcb,EVP_PKEY_CTX *pctx)
{
  int rv = 0;
  int fips = 0;
  int nid = 0;
  int check = 0;
  EVP_PKEY *pk = NULL;

  rv = EVP_PKEY_verify_init(pctx);
  if((NULL != pcb->callback) && (1 == rv)) {
    pk =  EVP_PKEY_CTX_get0_pkey(pctx);
    if(NULL != pk) {
      fips = PKEY_FIPS_id(pk,&check,&nid);
      (*pcb->callback)("ICC_EVP_PKEY_verify_init",nid,fips);
    }
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_EVP_DigestSignInit(ICClib *pcb,EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey)
{
  int rv = 0;
  int fips = 0;
  int hfips = 0;
  int check = 0;
  int nid = 0;
  int hnid = 0;

  rv = EVP_DigestSignInit(ctx,pctx,type, e, pkey);
  /* Now check the pkey and the digest for fips validity 
    We'll try to return the nid of the failed whatever in the fail case
  */
  if((NULL != pcb->callback) && (1 == rv)) {
    fips = PKEY_FIPS_id(pkey,&check,&nid);
    if(2 == check) {
      fips = 0;
    }
    if(NULL != type) {
      hnid = EVP_MD_type(type);
      hfips =  FIPS_MDbyNID(hnid);
    }
    if(!fips) {
      (*pcb->callback)("ICC_EVP_DigestSignInit",nid,0);
    } else if(!hfips && (0 != hnid)) {
      (*pcb->callback)("ICC_EVP_DigestSignInit",hnid,0); 
    } else {
      (*pcb->callback)("ICC_EVP_DigestSignInit",nid,1);
    }
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_EVP_DigestVerifyInit(ICClib *pcb,EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey)
{
  int rv = 0;
  int fips = 0;
  int hfips = 0;
  int check = 0;
  int nid = 0;
  int hnid = 0;

  rv = EVP_DigestVerifyInit(ctx,pctx,type, e,pkey);
  if((NULL != pcb->callback) && (1 == rv) ) {
    fips = PKEY_FIPS_id(pkey,&check,&nid);
    if(NULL != type) {  
      hnid = EVP_MD_type(type);
      hfips =  FIPS_MDbyNID(hnid);
    }
    if(!fips) {
      (*pcb->callback)("ICC_EVP_DigestVerifyInit",nid,0);
    } else if(!hfips && (0 != hnid)) {
      (*pcb->callback)("ICC_EVP_DigestVerifyInit",hnid,0); 
    } else {
      (*pcb->callback)("ICC_EVP_DigestVerifyInit",nid,1);
    }
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_SP800_38F_KW(ICClib *pcb,unsigned char *in, int inl, unsigned char *out, int *outl, unsigned char *key, int kl,unsigned int flags) 
{
  int rv = 0;
  int nid = 0;
  int fips = 0;
  rv = SP800_38F_KW(in, inl, out, outl, key, kl,flags);
  if(pcb->callback) {
    switch (kl)
    {
    case 16:
    case 128:
      fips = 1;
      nid = 418;
      break;
    case 24:
    case 192:
      fips = 1;
      nid = 422;
      break;
    case 32:
    case 256:
      fips = 1;
      nid = 426;
      break;
    default:
      break;
    }
    (*pcb->callback)("ICC_SP800_38F_KW",nid,fips);
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_EVP_PKEY_derive_init(ICClib *pcb,EVP_PKEY_CTX *ctx)
{
  int rv = 0;
  int fips = 0; 
  int nid = 0;
  int check = 0;
  EVP_PKEY *pkey = NULL;
  rv = EVP_PKEY_derive_init(ctx);
  if((NULL != pcb->callback) && (1 == rv) ) {
    pkey = EVP_PKEY_CTX_get0_pkey(ctx);
    if(NULL != pkey) {
      fips = PKEY_FIPS_id(pkey,&check,&nid);
      (*pcb->callback)("ICC_EVP_derive_init",nid,fips);
    }
  } 
  return rv;
}

/* included via icclib_a.c */
static
int my_RSA_sign(ICClib *pcb,int nid, const unsigned char *dgst, int dlen, unsigned char *sig, unsigned int *siglen, RSA *rsa)
{
  int rv = 0;
  int fips = 0; 
  int len = 0;

  rv = RSA_sign(nid,dgst, dlen, sig, siglen,rsa);
  if((NULL != pcb->callback) && (1 == rv)) {
    len = RSA_size(rsa);
    if(len >= 256 && len <= 512) { /* Key length is plausible, 2k->4k */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_sign",19,fips);
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_RSA_verify(ICClib *pcb,int nid, const unsigned char *dgst, int dgst_len, const unsigned char *sigbuf, int siglen, RSA *rsa)
{
  int rv = 0;
  int fips = 0; 
  int len = 0;

  rv = RSA_verify(nid,dgst, dgst_len, sigbuf, siglen, rsa);
  if((NULL != pcb->callback) && (1 == rv)) {
    len = RSA_size(rsa);
    if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_verify",19,fips);
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_RSA_public_encrypt(ICClib *pcb,int flen, unsigned char *from,unsigned char *to, RSA *rsa,int padding)
{
  int rv = 0;
  int fips = 0;
  int len = 0;
  int cklen = 0;

  if(NULL != rsa) {
    len = RSA_size(rsa);
  }
  cklen = len;
  if(len > flen) {
    cklen = flen;
  }
  rv = RSA_public_encrypt(flen,from,to,rsa,padding);
  if(1 == rv) {
    if(0 == memcmp(from,to,cklen)) { /* Output unmodified , fail */
      rv = -1;
   }
  }
  if((NULL != pcb->callback) && (1 == rv)) {

     if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_public_encrypt",19,fips);
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_RSA_private_decrypt(ICClib *pcb,int flen, const unsigned char *from,unsigned char *to, RSA *rsa,int padding)
{
  int rv = 0;
  int fips = 0;
  int len = 0;
  int cklen = 0;

  if(NULL != rsa) {
    len = RSA_size(rsa);
  }
  cklen = len;
  if(len > flen) {
    cklen = flen;
  }
  rv = RSA_private_decrypt(flen,from,to,rsa,padding);
  if(1 == rv) {
    if(0 == memcmp(from,to,cklen)) { /* Output unmodified , fail */
      rv = -1;
    }
  }
  if((NULL != pcb->callback) && (1 == rv)) {

     if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_private_decrypt",19,fips);
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_RSA_public_decrypt(ICClib *pcb,int flen, unsigned char *from,unsigned char *to, RSA *rsa,int padding)
{
  int rv = 0;
  int fips = 0;
  int len = 0;
  int cklen = 0;

  if(NULL != rsa) {
    len = RSA_size(rsa);
  }
  cklen = len;
  if(len > flen) {
    cklen = flen;
  }
  rv = RSA_public_decrypt(flen,from,to,rsa,padding);
  if( 1 == rv) {
    if(0 == memcmp(from,to,cklen)) { /* Output unmodified , fail */
      rv = -1;
    }
  }
  if((NULL != pcb->callback) && (1 == rv)) {

     if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_public_decrypt",19,fips);
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_RSA_private_encrypt(ICClib *pcb,int flen, const unsigned char *from,unsigned char *to, RSA *rsa,int padding)
{
  int rv = 0;
  int fips = 0;
  int len = 0;
  int cklen = 0;

  if(NULL != rsa) {
    len = RSA_size(rsa);
  }
  cklen = len;
  if(len > flen) {
    cklen = flen;
  }
  rv = RSA_private_encrypt(flen,from,to,rsa,padding);
  if(1 == rv) {
    if(0 == memcmp(from,to,cklen)) { /* Output unmodified , fail */
      rv = -1;
    }
  }
  if((NULL != pcb->callback) && (1 == rv)) {

     if(len >= 256 && len <= 512) { /* Key length is plausible */
      fips = 1;
    }
    (*pcb->callback)("ICC_RSA_private_encrypt",19,fips);
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_PKCS5_PBKDF2_HMAC(ICClib *pcb,const char *pass, int passlen, const unsigned char *salt, int saltlen, int iters, const EVP_MD *digest, int keylen, unsigned char *out)
{
  int rv = 0;
  int fips = 0; 
  int nid = 0;
  rv = PKCS5_PBKDF2_HMAC(pass, passlen,salt, saltlen, iters, digest, keylen, out);
  if((pcb->callback) && (1 == rv)) {
    nid = EVP_MD_type(digest);
    fips = FIPS_MDbyNID(nid);
    if( 1 == fips) {
      if((saltlen < 16) ||  (iters < 1000) || (keylen < 14) || (passlen < 10) ){
        fips = 0;
      }      
    }
    (*pcb->callback)("ICC_PKCS5_PBKDF2_HMAC",nid,fips);
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_DH_generate_key(ICClib *pcb,DH *dh)
{
  int rv = 0;
  int len = 0;
  int fips = 0;
  RAND_seed(NULL,0); /* Reseed before keygen */
  rv = DH_generate_key(dh);
  if((pcb->callback) && (1 == rv) ) {
    len = DH_size(dh);
    if (len >= 256 && len <= 1024)
    {
      fips = 1;
    }
    if (1 == rv)
    {
      (*pcb->callback)("ICC_DH_generate_key", 0, fips);
    }
  }
  return rv; 
}

/* included via icclib_a.c */
static
int my_DH_compute_key(ICClib *pcb,unsigned char *key,BIGNUM *pub_key,DH *dh)
{
  int nid = 1039;
  int rv = 0; 
  int len = 0;   
  int fips = 0;
  rv = DH_compute_key(key,pub_key,dh);
  if((pcb->callback) && (1 == rv) ) { 
    len = DH_size(dh);
    if (len >= 256 && len <= 1024)
    {
      fips = 1;
    }
    if (1 == rv)
    {
      (*pcb->callback)("ICC_DH_compute_key",nid, fips);
    }
  }
  return rv;
}

/* included via icclib_a.c */
static
int my_DH_compute_key_padded(ICClib *pcb,unsigned char *key,BIGNUM *pub_key,DH *dh)
{
  int nid = 1039;
  int rv = 0; 
  int len = 0;   
  int fips = 0;
  rv = DH_compute_key_padded(key,pub_key,dh);
  if((pcb->callback) && (1 == rv) ) { 
    len = DH_size(dh);
    if (len >= 256 && len <= 1024)
    {
      fips = 1;
    }
    if (1 == rv)
    {
      (*pcb->callback)("ICC_DH_compute_key_padded",nid, fips);
    }
  }
  return rv;
}


#define HKDF_MAXBUF 1024

unsigned char *HKDF_Extract(ICClib *pcb,const EVP_MD *evp_md,
			    const unsigned char *salt, size_t salt_len,
			    const unsigned char *key, size_t key_len,
			    unsigned char *prk, size_t *prk_len)
{
    unsigned int tmp_len = 0;
    HMAC_CTX *hmac = NULL;
    hmac = HMAC_CTX_new();
    HMAC_Init(hmac,salt, (int)salt_len, evp_md);
    HMAC_Update(hmac,key,key_len);
    HMAC_Final(hmac,prk,&tmp_len);
    HMAC_CTX_free(hmac);
    *prk_len = tmp_len; 
    return prk;
}

unsigned char *HKDF_Expand(ICClib *pcb,const EVP_MD *evp_md,
			   const unsigned char *prk, size_t prk_len,
			   const unsigned char *info, size_t info_len,
			   unsigned char *okm, size_t okm_len)
{
  HMAC_CTX *hmac = NULL;
  unsigned int i;
  int fips = 0;
  int nid = -1;
  unsigned char prev[ICC_EVP_MAX_MD_SIZE];
  size_t done_len = 0;
  size_t dig_len = 0;  
  size_t n = 0; 
  size_t copy_len;
  unsigned char ctr;

  dig_len = EVP_MD_size(evp_md);
  n = okm_len / dig_len;
  nid = EVP_MD_type(evp_md);
  fips = FIPS_MDbyNID(nid);

  if (okm_len % dig_len)
    n++;

  if (n > 255 || okm == NULL)
    goto err;

  if ((hmac = HMAC_CTX_new()) == NULL)
    return NULL;

  if (!HMAC_Init(hmac, prk, (int)prk_len, evp_md))
    goto err;

  for (i = 1; i <= n; i++)
  {

    ctr = (unsigned char)i;

    if (i > 1)
    {
      if (!HMAC_Init(hmac, NULL, 0, NULL))
        goto err;

      if (!HMAC_Update(hmac, prev, dig_len))
        goto err;
    }

    if (!HMAC_Update(hmac, info, info_len))
      goto err;

    if (!HMAC_Update(hmac, &ctr, 1))
      goto err;

    if (!HMAC_Final(hmac, prev, NULL))
      goto err;

    copy_len = (done_len + dig_len > okm_len) ? okm_len - done_len : dig_len;

    memcpy(okm + done_len, prev, copy_len);

    done_len += copy_len;
  }

  HMAC_CTX_free(hmac);
  if((NULL != pcb) && (NULL != pcb->callback)) {
    (*pcb->callback)("ICC_HKDF_Expand",nid,fips);
  }
  return okm;

err:
  if(NULL != hmac) {
    HMAC_CTX_free(hmac);
  }
  return NULL;
}

unsigned char *HKDF(ICClib *pcb,const EVP_MD *evp_md,
			const unsigned char *salt, size_t salt_len,
			const unsigned char *key, size_t key_len,
			const unsigned char *info, size_t info_len,
			unsigned char *okm, size_t okm_len)
{
  unsigned char prk[ICC_EVP_MAX_MD_SIZE];
  unsigned char *ret = NULL;
  size_t prk_len = 0;
  
  if (!HKDF_Extract(pcb,evp_md, salt, salt_len, key, key_len, prk, &prk_len))
    return NULL;

  ret = HKDF_Expand(pcb,evp_md, prk, prk_len, info, info_len, okm, okm_len);
  memset(prk,0,sizeof(prk));
	 
  return ret;
}
/* Copied from OpenSSL-FIPS */
int dsa_paramgen_check_g(DSA *dsa)
{
    BN_CTX *ctx = NULL;
    BIGNUM *tmp = NULL;
    BN_MONT_CTX *mont = NULL;
    int rv = -1;
    ctx = BN_CTX_new();
    if (!ctx)
        return -1;
    BN_CTX_start(ctx);
    if (BN_cmp(dsa->g, BN_value_one()) <= 0)
        return 0;
    if (BN_cmp(dsa->g, dsa->p) >= 0)
        return 0;
    tmp = BN_CTX_get(ctx);
    if (!tmp)
        goto err;
    if ((mont = BN_MONT_CTX_new()) == NULL)
        goto err;
    if (!BN_MONT_CTX_set(mont, dsa->p, ctx))
        goto err;
    /* Work out g^q mod p */
    if (!BN_mod_exp_mont(tmp, dsa->g, dsa->q, dsa->p, ctx, mont))
        goto err;
    if (!BN_cmp(tmp, BN_value_one()))
        rv = 1;
    else
        rv = 0;
 err:
    BN_CTX_end(ctx);
    if (mont) {
        BN_MONT_CTX_free(mont);
    }
    BN_CTX_free(ctx);
    return rv;
}

#ifndef NUMITEMS
#define NUMITEMS(x) (sizeof(x)/sizeof((x)[0]))
#endif

/*
* Ref: https://www.di-mgt.com.au/rsa_factorize_n.html
Input: N, e, d.
Output: p and q where pq=N.
1. [Initialize] Set k=de?1.
2. [Try a random g] Choose g at random from {2,...,N?1} and set t=k.
3. [Next t] If t is divisible by 2, set t=t/2 and x=g^t mod N. Otherwise go to step 2.
4. [Finished?] If x>1 and y=gcd(x?1,N)>1 then set p=y and q=N/y, output (p,q) and terminate the algorithm. Otherwise go to step 3.
*/
static
void recalculateCRT(RSA* rsa)
{
   static const unsigned int gs[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97 };
   size_t gi = 0;
   BIGNUM* two;
   BIGNUM* g;
   BIGNUM* k;
   BIGNUM* t;
   BIGNUM* dv;
   BIGNUM* rem;
   BIGNUM* x;
   BIGNUM* y;
   BIGNUM * r1 = NULL, * r2 = NULL;
   BN_CTX* ctx = NULL;
   ctx = BN_CTX_new();
   if (ctx == NULL)
      goto err;
   BN_CTX_start(ctx);
   two = BN_new();
   BN_set_word(two, 2);
   g = BN_new();
   k = BN_secure_new();
   t = BN_secure_new();
   dv = BN_secure_new();
   rem = BN_secure_new();
   x = BN_secure_new();
   y = BN_secure_new();
   r1 = BN_CTX_get(ctx);
   r2 = BN_CTX_get(ctx);
   /* 1. [Initialize] Set k=d*e?1. */
   BN_mul(k, rsa->e, rsa->d, ctx);
   BN_sub_word(k, 1);
   /* 2. [Try a random g] Choose g at random from {2,...,N?1} and set t=k. */
   /* we actually choose g from a table of first primes < 100 */
   for (gi = 0; gi < NUMITEMS(gs); gi++) {
      BN_set_word(g, gs[gi]);
      if (BN_copy(t, k) == NULL) {
         break;
      }
      for (;;) {
         /* 3. [Next t] If t is divisible by 2, set t=t/2 and x=g^t mod N. Otherwise go to step 2. */
         BN_div(dv, rem, t, two, ctx);
         if (BN_is_zero(rem)) {
            if (BN_copy(t, dv) == NULL) {
               break;
            }
         }
         else {
            /* not divisible by 2 - goto step 2.*/
            break;
         }
         /*x*/
         BN_mod_exp(x, g, t, rsa->n, ctx);
         if (BN_is_one(x)) {
            /* goto step 3 */
            continue;
         }
         /*y=gcd(x?1,N)>1*/
         BN_sub_word(x, 1);
         BN_gcd(y, x, rsa->n, ctx);
         if (BN_is_one(y)) {
            /* goto step 3 */
            continue;
         }

         /* finished */
         if (BN_copy(rsa->p, y) == NULL) {
            break;
         }
         BN_div(rsa->q, NULL, rsa->n, rsa->p, ctx);
         if (BN_cmp(rsa->p, rsa->q) < 0) {
            /* swap p & q so p > q */
            BIGNUM * tmp = rsa->p;
            rsa->p = rsa->q;
            rsa->q = tmp;
         }
         {
            if (!BN_sub(r1, rsa->p, BN_value_one()))
               goto err;               /* p-1 */
            if (!BN_sub(r2, rsa->q, BN_value_one()))
               goto err;               /* q-1 */
            if (/* calculate d mod (p-1) */
               !BN_mod(rsa->dmp1, rsa->d, r1, ctx)
               /* calculate d mod (q-1) */
               || !BN_mod(rsa->dmq1, rsa->d, r2, ctx)) {
               goto err;
            }
            /* calculate inverse of q mod p */
            if (!BN_mod_inverse(rsa->iqmp, rsa->q, rsa->p, ctx))
               goto err;
         }
         if (ctx != NULL) {
            BN_CTX_end(ctx);
            BN_CTX_free(ctx);
         }
         return;
      }
   }
err:
   if (ctx != NULL) {
      BN_CTX_end(ctx);
      BN_CTX_free(ctx);
   }
   return;
   /* failed - give up - no more 'gs' to try, can actually try g (prime) < N */
}

static
int RSA_MergePubPri(RSA* rsaPri, const RSA* rsaPub)
{
   int rc = 0;
   int ebitSize = 0;
   ebitSize = BN_num_bits(rsaPri->e);
   if (ebitSize) {
      /* already have public exponent */
      return rc;
   }
   if (!rsaPub) {
      /* no public key supplied */
      return 2;
   }
   if (BN_cmp(rsaPri->n, rsaPub->n)) {
      /* no pub / pri key mismatch */
      return 1;
   }
   /* merge public exponent into private key */
   BN_copy(rsaPri->e, rsaPub->e);
   return rc;
}

/*
** RSA private key should have CRT components but may not.
** Fix the private keys so missing CRT will still work with just mod/exp
** 'pub' == NULL triggers CRT component removal if any zeros
** 'pub' non zero supplies 'e' for CRT recalculation.
*/
int RSA_FixEncodingZeros(RSA* rsa, const RSA* pub, int allowDisableBlinding)
{
   /* see if CRT components are zero and should be deleted */
   /* check them all - any zero means all have to go */
   /* also check if fixed already - nulls */
   int ebitSize = 0;
   int bitSize = rsa->dmp1 ? BN_num_bits(rsa->dmp1) : 1;
   if (bitSize) bitSize = rsa->dmq1 ? BN_num_bits(rsa->dmq1) : 1;
   if (bitSize) bitSize = rsa->iqmp ? BN_num_bits(rsa->iqmp) : 1;
   if (bitSize == 0) {
      /* fixup is required */
      RSA_MergePubPri(rsa, pub);
      ebitSize = BN_num_bits(rsa->e);
      if (ebitSize == 0) {
         /* this flag triggers code that requires 'e' so switch it off */
         rsa->flags &= ~RSA_FLAG_CACHE_PUBLIC;
         /* delete zero all CRT components */
         BN_clear_free(rsa->e);
         rsa->e = NULL;
         BN_clear_free(rsa->p);
         rsa->p = NULL;
         BN_clear_free(rsa->q);
         rsa->q = NULL;
         BN_clear_free(rsa->dmp1);
         rsa->dmp1 = NULL;
         BN_clear_free(rsa->dmq1);
         rsa->dmq1 = NULL;
         BN_clear_free(rsa->iqmp);
         rsa->iqmp = NULL;
      }
      else {
         /* recaculate the CRT components */
         recalculateCRT(rsa);
      }
   }
   return ICC_OSSL_SUCCESS;
}

/* A noop these days */
/* included via icclib_a.c */
static
void my_GHASH(AES_GCM_CTX *gcm_ctx,unsigned char *H,unsigned char *Hash,unsigned char *data,unsigned long datalen)
{

}
#define MyCalloc(x,y) ICC_Calloc(x,y,__FILE__,__LINE__)
#define MyFree(x) ICC_Free(x)

#include "loaded.c" /* Self location code */

#if defined(STANDALONE_ICCLIB)
int check_status( ICC_STATUS *status, const char *file, int line )              
  
{                              
  const char *sev = "UNKNOWN ERROR TYPE";
  int rv = ICC_OK;

  if((status->majRC) != ICC_OK) {
    switch(status->majRC) {
    case ICC_ERROR:
      sev = "ICC_ERROR";
      break;
    case ICC_WARNING:
      sev = "ICC_WARNING";  
      break;
    case ICC_FAILURE:
      sev = "ICC_FAILURE";  
      break;
    case ICC_OPENSSL_ERROR:
      sev = "ICC_OPENSSL_ERROR";
      break;
    case ICC_OS_ERROR:
      sev = "ICC_OS_ERROR";
      break;
    default:
      rv = ICC_ERROR;
      break;
    }
    switch(status->majRC) {
    case ICC_ERROR:
    case ICC_FAILURE:
    case ICC_WARNING:
    case ICC_OPENSSL_ERROR:
    case ICC_OS_ERROR:  
      printf("Line %d: Status Check (%s): majRC: %d minRC: %d Error string: %s\n",line, sev,status->majRC, status->minRC , status->desc);
      rv = status->majRC;
      break;
    default:
      printf("Line %d: Status Check (%s): majRC: %d minRC: %d  \"Something bad happened\"\n",line,sev,status->majRC,status->minRC);
      break;
    }
  }

  return rv;
}




int main(int argc,char *argv[])
{
  int rc = 1;
  static int me = 0;
  double c2t = 0.0;
  ICC_STATUS status;
  if(!Global.initialized) {
    me = 1;
    rc = ICCLoad();
    if(0 != rc) printf("Self test failed\n");
  }
  check_status(&Global.status,__FILE__,__LINE__);
  if(me) {
    ICCUnload();
  }

  global_d[6] = Delta_T(0,&global_d[0]);

  c2t = Delta2Time(1);
  c2t /= 1000000000.0;
  printf("Find paths   %g\nRead conf    %g\nInit OpenSSL %g\nSelf Test    %g\nSig Check    %g\n main()      %g\n",c2t * global_d[1],c2t * global_d[2],c2t * global_d[3],c2t * global_d[4] ,c2t * global_d[5], c2t* global_d[6]);
  /* Added 2021 because we can hit different paths here */
  SetStatusOK(NULL,&status);
  SelfTest(NULL,&status);
  return me;
}


#endif

/* from SP800-90.c */
PRNG* my_get_RNGbyname(ICClib* pcb, const char* algname);

/* Include the function table */
#include "icclib_a.c"

/* Set up the call tables that will be used by the static stub to access
   crypto. function
*/
static void LoadTable(ICC_STATUS* status)
{
   int i = 0, j = 0;
   IN();
   /* NUM_ICCLIBFUNCTIONS -1 because of the NULL,NULL terminal entry */
   for (i = j = 0; (i < (NUM_ICCLIBFUNCTIONS - 1)) && (NULL != Global.funcs[i].name); i++, j++) {
      /* We sometimes need to redirect functions, so provided we
         have a loose match to the name, accept it
      */
      if ((NULL != ICCGlobal_default[j].name) && (NULL != strstr(Global.funcs[i].name, ICCGlobal_default[j].name))) {
         ICCGlobal_default[i].func = Global.funcs[j].func;
      }
      else {
         SetStatusLn2(NULL, status, ICC_ERROR, ICC_LIBRARY_NOT_FOUND, "Symbol not found in function list", (ICCGlobal_default[i].name != NULL) ? ICCGlobal_default[i].name : " prior internal self test failure ", __FILE__, __LINE__);
         break;
      }
   }
   OUT();
}

static void LoadTables(ICC_STATUS* status)
{
   int i, j = 0;
   IN();
   if (ICC_OK == status->majRC) {
      /* Populate the default ICCGlobal table */
      LoadTable(&(Global.status));


      memcpy(&ICCGlobal_Partial, &ICCGlobal_default, sizeof(ICCGlobal_Partial));
      memcpy(&ICCGlobal_Error, &ICCGlobal_default, sizeof(ICCGlobal_Error));
      /* Now winnow the entry points down
         Error state table, I know, but really, it's accurate enough
      */
      for (i = 0; i < (NUM_ICCLIBFUNCTIONS - 1); i++) {
         if (NULL == ICCGlobal_Error[i].name)
            break;
         if ((NULL != strstr(ICCGlobal_Error[i].name, "_new")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "generate")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "Generate")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "Init")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "get_")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "RAND_")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "DES_random_key")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "AES_CCM_Encrypt")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "AES_CCM_Decrypt")) ||
            (NULL != strstr(ICCGlobal_Error[i].name, "SP800_38F_KW"))) {
            ICCGlobal_Error[i].func = NULL;
         }
      }
      /* Init table is a bit simpler
         anything beyond SelfTest isn't there
      */
      for (i = 0; i < (NUM_ICCLIBFUNCTIONS - 1); i++) {
         if (NULL == ICCGlobal_Partial[i].name) break;
         if (NULL != strstr(ICCGlobal_Partial[i].name, "SelfTest")) {
            j = 1;
            continue;
         }
         if (0 != j) {
            ICCGlobal_Partial[i].func = NULL;
         }
      }
   }
   OUT();
}

/* Called from the status code when a fatal error is tripped */
void DisableAPI(void)
{
   memcpy(ICCGlobal_default, ICCGlobal_Error, sizeof(ICCGlobal_default));
}

/*!
  @brief
  lib_attach.
  - Perform consistancy checks on requested state.
  - Attach to the OpenSSL shared library
  - Initialize internal ICC state. (FIPS mode etc)
  - Initialize OpenSSL
  - Initialize PRNG seed
  - Run NIST self tests
  The ICC Mutex is held during this operation.
  - Most port errors happen here.
  @param pcb ICC internal context
  @param status status return
  @return ICC_OSSL_SUCCESS or ICC_FAILURE - Note need to check status.
*/
int lib_attach(ICClib* pcb, ICC_STATUS* status)
{

   int rc = ICC_OSSL_SUCCESS;

   IN();

   if (status == NULL || pcb == NULL) {
      return ICC_FAILURE;
   }
   SetStatusOK(NULL, status);

   *(DWORD*)(pcb->toa) = (DWORD)time(NULL);
   *(DWORD*)(pcb->pIDattach) = ICC_GetProcessId();
   *(DWORD*)(pcb->tIDattach) = ICC_GetThreadId();

   if (getErrorState()) {
      rc = ICC_GetLastError(status);
   }
   if (ICC_OSSL_SUCCESS == rc) {
      if (3 == icc_failure) {
         Global.initialized = 0;
      }
      /*If not valid, return error */
      if ((0 == Global.initialized) && (ICC_OK == Global.status.majRC)) {
         /*Could not load DLL */
         SetStatusLn(pcb, status, ICC_ERROR | ICC_FATAL, ICC_INVALID_STATE,
            (char*)"ICC was not initialized", __FILE__, __LINE__);
      }
      switch (status->majRC) {
      case ICC_ERROR:
      case ICC_OS_ERROR:
      case ICC_OPENSSL_ERROR:
         rc = ICC_FAILURE;
         break;
      case ICC_OK:
      case ICC_WARNING:
      default:
         /* Allow full set of crypto. functions */
         pcb->funcs = ICCGlobal_default;
         /*and prevent further state changes*/
         pcb->lock = 1;
         break;
      }
   }
   SetFlags(pcb, status);
   OUTRC(rc);
   return rc;
}

