/*************************************************************************
// Copyright IBM Corp. 2023
//
// Licensed under the Apache License 2.0 (the "License").  You may not use
// this file except in compliance with the License.  You can obtain a copy
// in the file LICENSE in the source distribution.
*************************************************************************/

/*************************************************************************
// Description: Manually created source for the ICCPKG wrapper for GSkit
//
*************************************************************************/

/*! \IMPLEMENT
  This is the frequently changing part of the code that becomes
  libgsk8iccs.so
  MOST of the code is generated by ICCencapsulator.java as gsk_wrap2_a.c
  which is #included at the end of this file
*/
#define GEN_RAND_SEED_HACK /* Return value from ICC_GenerateRandomSeed() */
#define GETVALUE_HACK /* Return dummy data for some GetValue() calls */



#if defined(JGSK_WRAP)
#include "jcc_a.h"
#  if defined(__MVS__)
#     include "exports/jccstepZOS.h"
#  endif
#  if defined(GEN_RAND_SEED_HACK)
#    undef ICC_GenerateRandomSeed
#    define ICC_GenerateRandomSeed(a,b,c,d)  JCC_GenerateRandomSeed_disabled(a,b,c,d)
#  endif /* GEN_RAND_SEED_HACK */
#  if defined(GETVALUE_HACK)
#    undef ICC_GetValue
#    define ICC_GetValue(a, b, c, d, e) JCC_GetValue_disabled(a, b, c, d, e)
#  endif /* GETVALUE_HACK */

   /* Object cache, disabled because of issues with callbacks */
#   if 0   
#     undef JCC_EVP_get_digestbyname
#     define JCC_EVP_get_digestbyname(a, b) JCC_EVP_get_digestbyname_disabled(a, b)
#     define JCC_EVP_get_cipherbyname(a, b) JCC_EVP_get_cipherbyname_disabled(a, b)
#   endif
#else /* Normal step library */
#  if defined(__MVS__)
#     include "exports/iccstepZOS.h"
#  endif
#  if defined(GEN_RAND_SEED_HACK)
#    define ICC_GenerateRandomSeed(a, b, c, d)  ICC_GenerateRandomSeed_disabled(a, b, c, d)
#  endif
#  if defined(GETVALUE_HACK)
#    define ICC_GetValue(a, b, c, d, e) ICC_GetValue_disabled(a, b, c, d, e)
#  endif /* GETVALUE_HACK */
   /* Object cache, disabled because of problems with FIPS callbacks */
#  if 0 
#     undef ICC_EVP_get_digestbyname
#     define ICC_EVP_get_digestbyname(a, b) ICC_EVP_get_digestbyname_disabled(a, b)
#     define ICC_EVP_get_cipherbyname(a, b) ICC_EVP_get_cipherbyname_disabled(a, b)
#  endif
#endif

#if !defined(GSK_GLOBAL)
#define GSK_GLOBAL ""
#endif




#include "icc.h"
/*
#include "HKDF/hkdf.h"
*/
#include "iccversion.h"
#include "loaded.h"
#include <time.h>
#define TRACE_CODE 1
#include "tracer.h"

static int ok_status(ICC_STATUS *status);
static int default_status(ICC_STATUS *status);
static int truncated_status(ICC_STATUS *status);
static int invalid_status(ICC_STATUS *status);
static int memory_status(ICC_STATUS *status);


#if !defined(JGSK_WRAP) /* Pick up PKCS#11 */
typedef unsigned long (*PF_C_GetFL)(void *);
#if 0
extern unsigned long C_GetFunctionList(void *);
#else
unsigned long C_GetFunctionList(void* x)
{
   /* stub to remove PKCS11 API */
   return -1;
}
#endif
static PF_C_GetFL hook;
#endif

static int trace_inited = 0; /* This is NOT locked, best effort only */
static int ref_count = 0; /* This is NOT locked, best effort only */
static int Ccache_init = 0; /* Status of the FIPS object caches */
static int Ncache_init = 0; /* Status of the non-FIPS object caches */
/*! 
  This is actually a GSkit enum and is used to control the loading of the two
  libraries. The value passed in is a pointer to an integer, in that integer
  bit 0 is the C/ library
  bit 1 is the N/ library
  The reason for doing this is the libraries now initialize on load, if we have a hanger
  we need some way to NOT load that library at all.
  Also found in GSkit's iccstep.h
*/
#define GSK_ICC_ACTIVE_LIBS 52


typedef struct {
  ICC_CTX *Nctx;  /*!< ICC_CTX to use for the newer ICC variant*/
  ICC_CTX *Cctx;  /*!< ICC_CTX for the older - possibly certified variant */
  int prefer_FIPS; /*!< The user has expressed a preference for the FIPS ICC */
#if defined(_WIN32)
  wchar_t mypath[ICC_VALUESIZE];
#else
  char *mypath[ICC_VALUESIZE];
#endif
  int is_wchar; /* Set if we were initialized via ICC_InitW() */
} WICC_CTX;
 
#if defined(__sun) || defined(__hpux)
static int setenv(const char *name,const char *value,int overwrite)
{
  static char x[PATH_MAX];
  if(!overwrite && (NULL != getenv(name))) {
    return 0;
  }
  strcpy(x,name);
  if((strlen(name)+strlen("= ")+strlen(value)+ 1) < PATH_MAX) {
    strcat(x,"= "); 
    strcat(x,value);
    putenv(x);
  }
  return 0;
}
#endif




static int hasC = 1; /*!< Used to enable/disable the C/ (FIPS) tree */
static int hasN = 1; /*!< Used to enable/disable the N/ (Non-FIPS) tree */


#include "gsk_wrap2_a.c" /* Use #include because of the number of shared statics */
#if 0
#include "name_cache.c"  /* Interacts closely with this file as it takes over functions */
#endif

#if defined(GETVALUE_HACK)
#  if defined(_WIN32)
static int fips_is_init = 0;
static wchar_t mypath[ICC_VALUESIZE];
#  endif /* _WIN32 */
/* 
   Nasty hack to fix a flaw in wide character path handling in the FIPS ICC
   instance.
   Should be disabled once it's fixed in the FIPS code
*/



/*!
 *  @brief Get configuration data
 *  @param pcb ICC context pointer returned by a sucessful call to ICC_Init
 *  @param status pointer to a pre-allocated ICC_STATUS variable in which status will be returned
 *  @param valueID ID of parameter to get
 *  @param value pointer to pre-allocated space to contain configuration value data
 *  @param valueLength some of the value passed in.
 *  @return ICC_OK, ICC_WARNING, ICC_ERROR , ICC_FAILURE
 *  @see ICC_RC_ENUM
 */

#  undef ICC_GetValue
#if defined(JGSK_WRAP)
int ICC_LINKAGE JCC_GetValue(ICC_CTX *pcb,ICC_STATUS* status,ICC_VALUE_IDS_ENUM valueID,void* value,int valueLength)
#else
int ICC_LINKAGE ICC_GetValue(ICC_CTX *pcb,ICC_STATUS* status,ICC_VALUE_IDS_ENUM valueID,void* value,int valueLength)
#endif
{
  WICC_CTX *wpcb = (WICC_CTX *)pcb;
  int done = 0;
  int rv = ICC_FAILURE;
  int tmp = 0;
  char *tmpp = NULL;
  IN();
  if(NULL != status) {
    rv = default_status(status);
  }
  if(NULL != wpcb) {
#  if HAVE_N_ICC
    if(NULL != wpcb->Nctx) {
      rv = ICCN_GetValue(wpcb->Nctx,status,valueID,value,valueLength);
    }
#  endif
#  if HAVE_C_ICC 
    if(NULL != wpcb->Cctx) {
#   if defined(_WIN32)
      if(ICC_INSTALL_PATH == valueID) {
        if(wpcb->is_wchar) {
          wcsncpy((wchar_t *)value,wpcb->mypath,valueLength/(sizeof(wchar_t)));
	        rv = ok_status(status);
          done = 1;
        }
      } 
#   endif /* _WIN32 */
      if(!done) {
        rv = ICCC_GetValue(wpcb->Cctx,status,valueID,value,valueLength);
	      done = 1;
      }
    }
#  endif /* HAVE_C_ICC */
    /* This is the normal case if you call before Attach, 
       no sub-contexts until then 
    */
    if(NULL == wpcb->Nctx && NULL == wpcb->Cctx) {
      memset(value,0,valueLength);
      switch(valueID) {
      case ICC_ENTROPY_ESTIMATE:
      case ICC_RNG_INSTANCES:
      case ICC_RNG_TUNER:
      case ICC_ALLOW_INDUCED:
      case ICC_INDUCED_FAILURE:
      case ICC_LOOPS:
      case ICC_SHIFT:
	tmp = sizeof(int);
	if (valueLength < tmp) {
	  rv = invalid_status(status);
	}
	break;
      default: /* String values, yet another case by case switch() */
	switch(valueID) {
	case ICC_VERSION:
	  rv = ok_status(status);	  
	  tmp = strlen(ICC_PRODUCT_VERSION);	  
	  if(tmp >= valueLength) {
	    rv = truncated_status(status); 
	  }
	  strncpy(value,ICC_PRODUCT_VERSION,valueLength);
	  break;
	case ICC_INSTALL_PATH:
	  rv = ok_status(status);
	  tmpp = calloc(1,ICC_VALUESIZE);
	  if(NULL == tmpp) {
	    rv = memory_status(status);
	  } else {
	    gskiccs_path(tmpp,ICC_VALUESIZE);
	    tmp = strlen(tmpp);
	    if(tmp >= valueLength) {
	      rv = truncated_status(status); 
	    }
	    strncpy(value,tmpp,valueLength);
	    free(tmpp);
	  }
	  break;
	case ICC_FIPS_APPROVED_MODE:
	  rv = ok_status(status);
	  if(valueLength < 4) {
	    rv = truncated_status(status); 
	  } else {
	    strncpy(value,"off",valueLength);
	  }
	  break;
	default:
	  break;
	}
	done = 1;
      }
    }
  }
  OUTRC(rv);
  return rv;
}


#endif /* _WIN32 hack */


#if defined(GEN_RAND_SEED_HACK)


#if defined(JGSK_WRAP)
#undef ICC_GenerateRandomSeed
    void ICC_LINKAGE JCC_GenerateRandomSeed(ICC_CTX *pcb, ICC_STATUS *status,
                                            int len, void *buffer) 
#else
#undef ICC_GenerateRandomSeed
    void ICC_LINKAGE ICC_GenerateRandomSeed(ICC_CTX *pcb, ICC_STATUS *status,
                                            int len, void *buffer) 
#endif
{
  WICC_CTX *wpcb = (WICC_CTX *)pcb;
  if(NULL != status) {
    memset(status,0,sizeof(ICC_STATUS));
  }
  if(NULL != wpcb) {
#if defined(HAVE_N_ICC)
    if(NULL != wpcb->Nctx) {
      ICCN_GenerateRandomSeed(wpcb->Nctx,status,len,buffer);
    }
#endif
#if defined(HAVE_C_ICC)
    if(NULL != wpcb->Cctx) {
      ICCC_GenerateRandomSeed(wpcb->Cctx,status,len,buffer);
    }
#endif    
  }
}    
#endif /* GEN_RAND_SEED_HACK */

#if defined(JGSK_WRAP)
ICC_CTX * ICC_LINKAGE JCC_Init(ICC_STATUS* status,const char* iccpath);

int ICC_LINKAGE JCC_Attach(ICC_CTX *pcb,ICC_STATUS* status);

int ICC_LINKAGE JCC_SetValue(ICC_CTX *pcb,ICC_STATUS* status,ICC_VALUE_IDS_ENUM valueID,const void* value);

int ICC_LINKAGE JCC_Cleanup(ICC_CTX *pcb,ICC_STATUS *status);
#else
ICC_CTX * ICC_LINKAGE ICC_Init(ICC_STATUS* status,const char* iccpath);

int ICC_LINKAGE ICC_Attach(ICC_CTX *pcb,ICC_STATUS* status);

int ICC_LINKAGE ICC_SetValue(ICC_CTX *pcb,ICC_STATUS* status,ICC_VALUE_IDS_ENUM valueID,const void* value);

int ICC_LINKAGE ICC_Cleanup(ICC_CTX *pcb,ICC_STATUS *status);

#endif


#if defined(HAVE_N_ICC)
ICC_CTX * ICC_LINKAGE ICCN_Init(ICC_STATUS* status,const char* iccpath);
int ICC_LINKAGE ICCN_Attach(ICC_CTX *pcb,ICC_STATUS* status);
int ICC_LINKAGE ICCN_SetValue(ICC_CTX *pcb,ICC_STATUS* status,ICC_VALUE_IDS_ENUM valueID,const void* value);
int ICC_LINKAGE ICCN_Cleanup(ICC_CTX *pcb,ICC_STATUS *status);
#endif

#if defined(HAVE_C_ICC)
ICC_CTX * ICC_LINKAGE ICCC_Init(ICC_STATUS* status,const char* iccpath);
int ICC_LINKAGE ICCC_Attach(ICC_CTX *pcb,ICC_STATUS* status);
int ICC_LINKAGE ICCC_SetValue(ICC_CTX *pcb,ICC_STATUS* status,ICC_VALUE_IDS_ENUM valueID,const void* value);
int ICC_LINKAGE ICCC_Cleanup(ICC_CTX *pcb,ICC_STATUS *status);
#endif


#if !defined(ICCSTEP_BFN)
const char gskiccs_SCCSInfo[] = 
{
    "@(#)CompanyName:      IBM Corporation\n"
    "@(#)LegalTrademarks:  IBM\n"
    "@(#)FileDescription:  " ICC_DESCRIPTION1 ICC_DESCRIPTION2 "\n"
    "@(#)FileVersion:      " ICC_PRODUCT_VERSION "\n"
    "@(#)LegalCopyright:   Licensed Materials - Property of IBM\n"
    "@(#)                  ICC\n"
    "@(#)                  (C) Copyright IBM Corp. 2002,2018\n"
    "@(#)                  All Rights Reserved. US Government Users\n"
    "@(#)                  Restricted Rights - Use, duplication or disclosure\n"
    "@(#)                  restricted by GSA ADP Schedule Contract with IBM \n"
    "@(#)                  Corp.\n"
    "@(#)ProductName:      " ICC_PRODUCT_NAME "\n"
    "@(#)ProductVersion:   " ICC_PRODUCT_VERSION "\n"
};



#endif


#if defined(_WIN32)
#if defined (JGSK_WRAP)
ICC_CTX * ICC_LINKAGE JCC_InitW(ICC_STATUS* status,const wchar_t* iccpath);
#else
ICC_CTX * ICC_LINKAGE ICC_InitW(ICC_STATUS* status,const wchar_t* iccpath);
#endif
#if defined(HAVE_N_ICC)
ICC_CTX * ICC_LINKAGE ICCN_InitW(ICC_STATUS* status,const wchar_t* iccpath);
#endif
#if defined(HAVE_C_ICC) 
ICC_CTX * ICC_LINKAGE ICCC_InitW(ICC_STATUS* status,const wchar_t* iccpath);
#endif


#if defined(ICCSTEP_BFN)
#  define LIBNAME GSK_MAKESHAREDLIBNAME(ICCSTEP_BFN)
#else
#  define LIBNAME GSK_LIBNAME
#endif

#else

#if defined(ICCSTEP_BFN)
#  define LIBNAME GSK_MAKESHAREDLIBNAME(ICCSTEP_BFN)
#else
#  define LIBNAME GSK_LIBNAME
#endif

#endif

#define MAKESTRING_REALLY(x) #x
#define MAKESTRING(x) MAKESTRING_REALLY(x)

/* entry point */
#define FUNCX ICC_Init
/* name of the entry point as a string */  
#define FUNCNAME MAKESTRING(FUNCX)
/* name of the library (this library) that the entry point is in */


/* GSkit version discovery, note this WILL need to be fixed
   when certified ICC 8 comes along 
*/
#if 1
extern const char ICCC_SCCSInfo[];
#if defined(HAVE_N_ICC)
extern const char ICCN_SCCSInfo[];
#endif
const char *gskiccs_Crypto_VersionInfo[] = {
#if defined(HAVE_C_ICC)
  ICCC_SCCSInfo,
#endif
#if defined(HAVE_N_ICC)            
  ICCN_SCCSInfo,
#endif 
  NULL };
#else 
extern const char ICC_SCCSInfo[];
#if defined(HAVE_N_ICC)
extern const char ICCN_SCCSInfo[];
#endif
const char *gskiccs_Crypto_VersionInfo[] = {
#if defined(HAVE_C_ICC)
  ICC_SCCSInfo,
#endif
#if defined(HAVE_N_ICC)            
  ICCN_SCCSInfo,
#endif  
  NULL };
#endif


static int ignore_fips = 0;
static int env_tested = 0;

int ICC_MemCheck_start(ICC_CTX *ctx,int mode)
{
  return ICC_NOT_IMPLEMENTED;
}

int ICC_MemCheck_stop(ICC_CTX *ctx,int mode)
{
  return ICC_NOT_IMPLEMENTED;
}

static int default_status(ICC_STATUS *status)
{
  if(NULL != status) {
    status->majRC=ICC_FAILURE;
    status->minRC=ICC_NOT_INITIALIZED;
    strcpy(status->desc,"ICC is not initialized");
  }
  return ICC_ERROR;
}
static int ok_status(ICC_STATUS *status)
{
  if(NULL != status) {
    status->majRC=ICC_OK;
    status->minRC=0;
    strcpy(status->desc,"O.K.");
  }
  return ICC_OK;
}
static int  memory_status(ICC_STATUS *status)
{
   if(NULL != status) {
      status->majRC = ICC_ERROR;
      status->minRC = ICC_NOT_ENOUGH_MEMORY;
      strncpy(status->desc,"Memory allocation failed (gsk_wrap2.c)",ICC_MAXPATHLENGTH-1);
   }
   return ICC_ERROR;
}  
static int invalid_status(ICC_STATUS *status)
{
  if(NULL != status) {
       status->majRC = ICC_ERROR;
       status->minRC = ICC_INVALID_PARAMETER;
       strncpy(status->desc,"Value does not meet the minimum size requirement (gsk_wrap2.c)",ICC_MAXPATHLENGTH-1);
  }
  return ICC_FAILURE;
}             
static int  truncated_status(ICC_STATUS *status)
{
   if(NULL != status) {
      status->majRC = ICC_WARNING;
      status->minRC = ICC_VALUE_TRUNCATED;
      strncpy(status->desc,"Value has been truncated",ICC_MAXPATHLENGTH-1);
   }
   return ICC_WARNING;
}                


/*!
  @brief check to see if an environment variable is set, and if set is
  plausably set to yes.
  @param str the variable to check
  @return 1 if the var is not set or is not set to "yes", 0 otherwise
*/
static int isYes(char *str)
{
  int rv = 0;
  if( NULL != str ) { /* Starts with Y,y,1 ?? */
    if(str[0] == 'Y' || str[0] == 'y' || str[0] == '1' ) {
      rv = 1; /* Assume it's some variant of "yes" then */
    }
  }
  return rv;
}

static void libsCheck() 
{
  static int env_tested = 0;
  char *env = NULL;
  int i = 0;

  IN();

  if(!env_tested) {
    env_tested = 1;
    env = getenv("GSK_ICC_ACTIVE_LIBS");
    MARK("GSK_ICC_ACTIVE_LIBS",(NULL != env) ? env : "(null)");
    if(NULL != env) {
      i = atoi(env);
      hasC = (i & 1);
      hasN = (i & 2);
    }

    /* 
       Force the status if the code was built without the external library by intent
    */
#if !defined(HAVE_C_ICC)
    hasC = 0;
#endif
#if !defined(HAVE_N_ICC)
    hasN = 0;
#endif
  }

  OUT();
}

/* Deferred startup, ICC_Init() only returns a non-NULL context
   because at this point we don't know whether FIPS or non-FIPS 
   is wanted
*/

ICC_CTX * ICC_LINKAGE ICC_Init(ICC_STATUS* status,const char* iccpath)
{

  WICC_CTX *wctx = NULL;

  if(!trace_inited) {
    trace_inited = 1;
    TRACE_START_EX("gskit step library",NULL);
  }
  IN();
  ref_count++;
  ok_status(status);
  wctx = (WICC_CTX *)calloc(1,sizeof(WICC_CTX));
  if(NULL != wctx) {
    if(NULL != iccpath) {
      strncpy((char *)(wctx->mypath),iccpath,ICC_VALUESIZE -1);
    } else {
      *(char *)(wctx->mypath) = 0;
    }
    wctx->is_wchar = 0;
  }
  OUT();
  return (ICC_CTX *)wctx;
}

static void ICC_InitReal(WICC_CTX *wctx, ICC_STATUS *status, int fips) {
  char *tmppath = NULL;
  ICC_STATUS *stat = NULL;

  IN();
  if ((NULL != wctx) && (NULL != status))
  {
    libsCheck();
    tmppath = (char *)calloc(MAX_PATH, 1);
    stat = (ICC_STATUS *)calloc(1, sizeof(ICC_STATUS));
    if ((NULL == wctx) || (NULL == tmppath) || (NULL == stat))
    {
      memory_status(status);
    }
    else
    {
      /* Generic for all OS's past here */
      default_status(status);
      /* New context */
      if (0 != *(char *)(wctx->mypath))
      {
        /* User provided path ? */
        strncpy(tmppath, (char *)(wctx->mypath), MAX_PATH - 3);
#if defined(_WIN32)
        strcat(tmppath, "\\N");
#else
        strcat(tmppath, "/N");
#endif
      }
      else
      { /* Use automatic path */
        FUNCTION_NAME(MYNAME, _path)
        (tmppath, MAX_PATH - 4);
        /* If autopath didn't work, try the gskit global default path */
        if (0 == strlen(tmppath) && 0 != strlen(GSK_GLOBAL))
        {
          strncpy(tmppath, GSK_GLOBAL, MAX_PATH - 4);
        }
#if defined(_WIN32)
        strcat(tmppath, "\\N");
#else
        strcat(tmppath, "/N");
#endif
#if !defined(JGSK_WRAP)
        hook = C_GetFunctionList; /* So the linker will pull in the PKCS#11 lib */
        if (NULL == hook)
        {
          strcat(tmppath, ""); /* Do nothing, shut up the optimizer on HP/UX */
        }
#endif
      }
#if defined(HAVE_N_ICC)
      if (hasN && !fips)
      {
        MARK("ICCN_Init()", tmppath);
        wctx->Nctx = ICCN_Init(status, tmppath);
        if (NULL == wctx->Nctx) {
           MARK("ICCN_Init() failed", stat->desc);
           OUTRC(stat->majRC);
           OUTRC(stat->minRC);
        }
      } /* hasN */
#endif
#if defined(HAVE_C_ICC)
      if (hasC)
      {
        /* Old "C"ertified context */
        /* User provided path ? */
        if (0 != *(char *)(wctx->mypath))
        {
          strncpy(tmppath, (char *)(wctx->mypath), MAX_PATH - 3);
#if defined(_WIN32)
          strcat(tmppath, "\\C");
#else
          strcat(tmppath, "/C");
#endif
        }
        else
        { /* Use automatic path*/
          FUNCTION_NAME(MYNAME, _path)
          (tmppath, MAX_PATH - 4);
          /* If autopath didn't work, try the gskit global default path */
          if (0 == strlen(tmppath) && 0 != strlen(GSK_GLOBAL))
          {
            strncpy(tmppath, GSK_GLOBAL, MAX_PATH - 4);
          }
#if defined(_WIN32)
          strcat(tmppath, "\\C");
#else
          strcat(tmppath, "/C");
#endif
        }
        if (fips)
        {
          MARK("ICCC_Init()", tmppath);
          wctx->Cctx = ICCC_Init(stat, tmppath);
          if (NULL == wctx->Cctx) {
             MARK("ICCC_Init() failed", stat->desc);
             OUTRC(stat->majRC);
             OUTRC(stat->minRC);
          }
        }
      } /* hasC */
#endif
      /* If the primary CTX failed but the secondary
       didn't, return the correct status
    */
      if ((NULL == wctx->Nctx) && (NULL != wctx->Cctx))
      {
        memcpy(status, stat, sizeof(ICC_STATUS));
      }
#if defined(_WIN32)
      if (NULL != wctx->Cctx)
      {
        fips_is_init = 1;
      }
#endif
    }
  }
  if (NULL != stat) {
    free(stat);
  }
  if (NULL != tmppath) {
    free(tmppath);
  }
  OUT();
}
#if defined(_WIN32)
/* Deferred startup, ICC_Init() only returns a non-NULL context
   because at this point we don't know whether FIPS or non-FIPS 
   is wanted
*/

ICC_CTX *ICC_LINKAGE ICC_InitW(ICC_STATUS *status, const wchar_t *iccpath) 
{
  WICC_CTX *wctx = NULL;
  
  if(!trace_inited) {
    trace_inited = 1;
    TRACE_START_EX("gskit step library",NULL);
  }
  IN();
  ref_count++;
  ok_status(status);
  wctx = (WICC_CTX *)calloc(1, sizeof(WICC_CTX));
  if (NULL != wctx) {
    if (NULL != iccpath) {
      wcsncpy(wctx->mypath, iccpath, ICC_VALUESIZE - 1);
    } else {
      wctx->mypath[0] = 0;
    }
    wctx->is_wchar = 1;
  }
  OUT();
  return (ICC_CTX *)wctx;
}
static void ICC_InitWReal(WICC_CTX *wctx, ICC_STATUS *status, int fips) {
  wchar_t *tmppath = NULL;
  ICC_STATUS *stat = NULL;

  tmppath = (wchar_t *)calloc(MAX_PATH, sizeof(wchar_t));
  stat = (ICC_STATUS *)calloc(1, sizeof(ICC_STATUS));

  IN();
  default_status(status);

  /* New context */
  /* User provided path ? */

  if ((0 != wctx->mypath[0]) && wcslen(wctx->mypath) < (MAX_PATH - 3)) {
    wcsncpy(tmppath, wctx->mypath, MAX_PATH - 3);
    wcscat(tmppath, L"\\N");
  } else { /* Use automatic path */
    FUNCTION_NAME(MYNAME, _pathW)(tmppath, MAX_PATH - 4);
    wcscat(tmppath, L"\\N");
  }
#if defined(HAVE_N_ICC)
  if (hasN && !fips) {
    MARK("ICCN_InitW()","path is wchar_t");
    wctx->Nctx = ICCN_InitW(status, tmppath);
  }
#endif /* HAVE_N_ICC */

  /* Old "C"ertified context */
  /* User provided path ? */
  if ((0 != wctx->mypath[0]) && wcslen(wctx->mypath) < (MAX_PATH - 3)) {
    wcsncpy(tmppath, wctx->mypath, MAX_PATH - 3);
    wcscat(tmppath, L"\\C");
  } else { /* Use automatic path*/
    FUNCTION_NAME(MYNAME, _pathW)(tmppath, MAX_PATH - 4);
    wcscat(tmppath, L"\\C");
  }
#if defined(HAVE_C_ICC)
  if (hasC && fips) {
    MARK("ICCC_InitW()","path is wchar_t");
    wctx->Cctx = ICCC_InitW(stat, tmppath);
  }
#endif /* HAVE_C_ICC */
  /* If the primary CTX failed but the secondary
     didn't, return the correct status
  */
  if ((NULL == wctx->Nctx) && (NULL != wctx->Cctx)) {
    memcpy(status, stat, sizeof(ICC_STATUS));
  }
  if (NULL != wctx->Cctx) {
      fips_is_init = 1;
  }

  if (NULL != stat) {
    free(stat);
  }
  if (NULL != tmppath) {
    free(tmppath);
  }
  OUT();
}
#endif
/* 
   Note hasC/hasN don't need to impact anything other than ICC_Init()/ICC_SetValue 
*/

int ICC_LINKAGE ICC_Attach(ICC_CTX *pcb,ICC_STATUS* status)
{
  WICC_CTX * wctx = NULL;
  int rv = ICC_FAILURE;
  ICC_STATUS tstatus;
  int fstate = 0;
  default_status(status);
  default_status(&tstatus);

  IN();

  wctx = (WICC_CTX *)pcb;
  if(wctx->prefer_FIPS && !ignore_fips) {
    fstate = 1;
  }
  if (NULL != wctx) {
#if defined(_WIN32)
    if (0 != wctx->is_wchar) {
      ICC_InitWReal((WICC_CTX *)pcb, status, fstate);
      if ((NULL == wctx->Cctx) && (NULL == wctx->Nctx)) {
        ICC_InitWReal((WICC_CTX *)pcb, status, !fstate);
      }
    } else {
      ICC_InitReal((WICC_CTX *)pcb, status, fstate);
      if ((NULL == wctx->Cctx) && (NULL == wctx->Nctx)) {
        ICC_InitReal((WICC_CTX *)pcb, status, !fstate);
      }
    }
#else
    ICC_InitReal((WICC_CTX *)pcb, status, fstate);
    if ((NULL == wctx->Cctx) && (NULL == wctx->Nctx)) {
      ICC_InitReal((WICC_CTX *)pcb, status, !fstate);
    }
#endif
    MARK("internal ICC_FIPS_APPROVED_MODE set",wctx->prefer_FIPS ? "on" : "off");
    ICC_SetValue(pcb, status, ICC_FIPS_APPROVED_MODE,wctx->prefer_FIPS ? "on" : "off");
    if (NULL != wctx->Cctx) {
#if defined(HAVE_C_ICC)
      rv = ICCC_Attach(wctx->Cctx, status);
      /* If that failed, clean it up and fall back to the older one */
      if (!(ICC_OK == rv || ICC_WARNING == rv)) {
        /* FIPS context is MIA */
        ICCC_Cleanup(wctx->Cctx, &tstatus);
        wctx->Cctx = NULL;
      }
#   if 0      
      if (NULL != wctx->Cctx) {
        if (0 == Ccache_init) {
          Ccache_init = 1;
          init_caches(wctx);
        }
      }
#   endif      
#endif
    } else if (NULL != wctx->Nctx) {
#if defined(HAVE_N_ICC)
      /* We didn't have FIPS context left in the race
         try with the new one
      */
      rv = ICCN_Attach(wctx->Nctx, status);
      if (!(ICC_OK == rv || ICC_WARNING == rv)) {
        ICCN_Cleanup(wctx->Nctx, &tstatus);
        wctx->Nctx = NULL;
      } 
#   if 0      
      if (NULL != wctx->Nctx) {
        if (0 == Ncache_init) {
          Ncache_init = 1;
          init_caches(wctx);
        }
      }
#   endif           
#endif
    }
    /* We need to check that a status wasn't already set by an actual context screaming
      in pain and closing down or we'll lose that error
      */
    if(0 == status->majRC && NULL == wctx->Cctx && NULL == wctx->Nctx) {
      rv = default_status(status);
    }
  }
  OUTRC(rv);

  return rv;
}
/* 
  Note that this function is active before there are contexts as it sets state
*/

int ICC_LINKAGE ICC_SetValue(ICC_CTX *pcb,ICC_STATUS* status,ICC_VALUE_IDS_ENUM valueID,const void* value)
{
  WICC_CTX *wctx = (WICC_CTX *)pcb;
  int rv = ICC_OK , rvN = ICC_ERROR ,rvC = ICC_ERROR;
  char *env = NULL;
  char buffer[20];


  IN();

  ok_status(status);

  if (!env_tested) {
    env_tested = 1;
    env = getenv("ICC_IGNORE_FIPS");
    ignore_fips = isYes(env);
  }
  /* The only possibilities here are GSkit disabling one or more of the crypto
     trees, that doesn't get passed down
  */
  if (GSK_ICC_ACTIVE_LIBS == valueID) {
    sprintf(buffer,"%2d",*(int*)value);
    MARK("GSK_ICC_ACTIVE_LIBS",buffer);
    hasC = 0;
    if ((*(int *)value) & 1) {
      hasC = 1;
    }
    hasN = 0;
    if ((*(int *)value) & 2) {
      hasN = 1;
    }
  } else {
    /* FIPS approved mode we catch if we can */
    if (ICC_FIPS_APPROVED_MODE == valueID) {
      MARK("ICC_FIPS_APPROVED_MODE in", (char *)value);
      if (NULL != wctx) {
        if (0 == strcasecmp("on", (char *)value)) {
          wctx->prefer_FIPS = 1;
        }
        if (0 == strcasecmp("off", (char *)value)) {
          wctx->prefer_FIPS = 0;
        }
      }
      MARK("ICC_FIPS_APPROVED_MODE set to",wctx->prefer_FIPS ? "on":"off");
    }
    if ((NULL == wctx) || ((NULL == wctx->Nctx) && (NULL == wctx->Cctx))) {
      /* Do nothing */
    } else {
      rv = rvN = ICC_ERROR;
#if defined(HAVE_N_ICC)
      if (NULL != wctx->Nctx) {
        rv = rvN = ICCN_SetValue(wctx->Nctx, status, valueID, value);
      }
#endif
      {
        /* This has to be on the stack, it must be thread safe,
           and we may be half way through hooking the memory
           callbacks
        */
        ICC_STATUS status1, *stat;
        stat = &status1;
#if defined(HAVE_C_ICC)
        if (NULL != wctx->Cctx) {
          rv = rvC = ICCC_SetValue(wctx->Cctx, stat, valueID, value);
        }

#endif
        /* If the New ctx failed but the old suceeded ...
           i.e. attempting to enter FIPS mode
           delete the New context
        */
        if ((NULL != wctx->Cctx) && (rvC == ICC_ERROR)) {
          if ((NULL != wctx->Nctx) && (rvN != ICC_ERROR)) {
            rv = rvN;
          } else {
            rv = rvC;
          }
        }
        if ((NULL != wctx->Nctx) && (rvN == ICC_ERROR)) {
          if ((NULL != wctx->Cctx) && (rvC != ICC_ERROR)) {
            /* copy the stat structure to that returned to the caller */
            memcpy(status, stat, sizeof(ICC_STATUS));
            rv = rvC;
          } else {
            rv = rvN;
          }
        }
      }
    }
  }

  OUTRC(rv);
  return rv;
} 

/*!
  @brief clean up the ICC context

  @note At this point there'll normally only be one active
  context - unless someone did ICC_Init()/ICC_Cleanup() 
  with no attach in between
*/

int ICC_LINKAGE ICC_Cleanup(ICC_CTX *pcb,ICC_STATUS *status) 

{
  WICC_CTX *wctx = (WICC_CTX *)pcb;
  int rv = ICC_OSSL_SUCCESS;

  IN();

  default_status(status);
  if( NULL != wctx ) {
#if defined(HAVE_N_ICC)
    if(wctx->Nctx != NULL) {
      rv = ICCN_Cleanup(wctx->Nctx,status);
      wctx->Nctx = NULL;
    }
#endif    
#if defined(HAVE_C_ICC)
    if(wctx->Cctx != NULL) {
      rv = ICCC_Cleanup(wctx->Cctx,status);
      wctx->Cctx = NULL;
    }
#endif
  }
  free(wctx);
  OUTRC(rv);
  /* We accept that this won't always work but it avoids a file handle leak in most cases */
  ref_count--;
  if(0 >= ref_count) {
    Ccache_init = 0;
    Ncache_init = 0;
    TRACE_END_EX();
    trace_inited = 0;
    ref_count = 0;
  }  
  return rv;
}
    

#include "loaded.c"
int gskiccs_path(char *returned_path,int path_len)
{
  int rv = 0;
  rv = FUNCTION_NAME(MYNAME,_path)(returned_path,path_len);
  return rv;
}
int gskiccs8_path(char *returned_path, int path_len) {
  int rv = 0;
  rv = FUNCTION_NAME(MYNAME, _path)(returned_path, path_len);
  return rv;
}

#if defined(_WIN32)
int gskiccs_pathW(wchar_t *returned_path,int path_len)
{
  int rv = 0;
  rv = FUNCTION_NAME(MYNAME,_pathW)(returned_path,path_len);
  return rv;
}
int gskiccs8_pathW(wchar_t *returned_path, int path_len) {
  int rv = 0;
  rv = FUNCTION_NAME(MYNAME, _pathW)(returned_path, path_len);
  return rv;
}
#endif


/* build as an exe so we can test some of this stuff */
#if defined(STANDALONE)

/* Note that this is tricky to test as it needs gskit_crypto lib in the library
   search path BUT the self location code will identify RIGHT HERE as the library location
   so the easy way to test is to copy it to that dir and run it there

   This is unavoidable as we duplicate a lot of the code that went into the step library when 
   we build this.

   */
int main(int argc, char *argv[]) {
  ICC_CTX *ctx = NULL;
  ICC_STATUS status;

  /* FIPS mode off */
  if( NULL == (ctx = ICC_Init(&status,NULL)) ) {
    fprintf(stderr,"ICC_Init fails\n");
    exit(1);
  }
 
  if( ICC_OK != ICC_SetValue(ctx,&status,ICC_FIPS_APPROVED_MODE,"off") ) {
      fprintf(stderr,"ICC_SetValue fails (FIPS off)\n");
  }

  if(ICC_ERROR == ICC_Attach(ctx,&status)) {
    fprintf(stderr,"ICC_Attach fails\n");
  }
  if(ctx != NULL) { 
#if 0
    cache_test((WICC_CTX *)ctx);
#endif    
    if(ICC_OSSL_SUCCESS != ICC_Cleanup(ctx,&status)) {
      fprintf(stderr,"ICC_Cleanup fails\n");
    }
  }
  /* FIPS mode on */
  if (NULL == (ctx = ICC_Init(&status, NULL))) {
    fprintf(stderr, "ICC_Init fails\n");
    exit(1);
  }

  if (ICC_OK != ICC_SetValue(ctx, &status, ICC_FIPS_APPROVED_MODE, "on")) {
    fprintf(stderr, "ICC_SetValue fails (FIPS on)\n");
  }

  if (ICC_ERROR == ICC_Attach(ctx, &status)) {
    fprintf(stderr, "ICC_Attach fails\n");
  }
  if (ctx != NULL) {
#if 0  
    cache_test((WICC_CTX *)ctx);
#endif    
    if (ICC_OSSL_SUCCESS != ICC_Cleanup(ctx, &status)) {
      fprintf(stderr, "ICC_Cleanup fails\n");
    }
  }

#if defined(_WIN32)
  if (NULL == (ctx = ICC_InitW(&status, NULL))) {
    fprintf(stderr, "ICC_Init fails\n");
    exit(1);
  }

  if (ICC_ERROR == ICC_SetValue(ctx, &status, ICC_FIPS_APPROVED_MODE, "on")) {
    fprintf(stderr, "ICC_SetValue fails (FIPS)\n");
  }

  if (ICC_ERROR == ICC_Attach(ctx, &status)) {
    fprintf(stderr, "ICC_Attach fails\n");
    exit(1);
  }
  if (ICC_OSSL_SUCCESS != ICC_Cleanup(ctx, &status)) {
    fprintf(stderr, "ICC_Cleanup fails\n");
  }
#endif
  return 0;
}

#endif /* STANDALONE */

